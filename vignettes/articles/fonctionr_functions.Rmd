---
title: "Manuel d'utilisation"
output:
  html_document:
    toc: true
    number_sections: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  out.width = "100%"
)
```

L'objectif de `fonctionr` est de faciliter l'analyse de données issues de sondages complexes, dont la manipulation est parfois laborieuse. `fonctionr` a été développé dans l'idée de réduire la taille du code à écrire pour produire les résultats descriptifs et d'analyses bivariées les plus courants.

Le package a également été construit pour pouvoir utiliser directement les résultats produits dans un rapport. Ainsi, `fonctionr` produit en une seule fonction : un tableau de résultats avec les indicateurs voulus, les effectifs et leurs intervalles de confiance ; un graphique prêt à être publié et le plus souvent un test statistique le plus approprié aux variables étudiées. Il est aussi possible de directement exporter ces trois résultats dans un fichier Excel.

Ce guide se structure de la manière suivante. Dans un premier temps on décrit les différentes fonctions, ce qu'elles produisent et dans quels cas elles peuvent être utilisées. Dans un deuxième temps, on présente un tableau récapitulatif des arguments. De nombreux arguments revenant dans plusieurs fonctions, il est plus facile de présenter la structure globale de ceux-ci que de se répéter pour chaque fonction.

# Présentation des différentes fonctions

La plupart des fonctions de `fonctionr` permettent, à partir de données issues d'un sondage (complexe mais aussi simple), de produire une liste qui contient la plupart du temps ces trois éléments :

-   Un graphique qui permet la visualisation des indicateurs calculés avec leurs intervalles de confiance. Il s'agit d'un objet `ggplot2` qui peut donc aussi être modifié par la suite. Le graphique se veut suffisamment finalisé pour être directement utilisable dans une publication ;

-   Un ou plusieurs dataframe qui reprennent les chiffres sur base desquels le graphique est construit. Ceux-ci reprennent généralement le nom de l'indicateur, sa valeur, les bornes d'intervalle de confiance, le nombre de personnes dans l'échantillon dans chaque catégorie, l'estimation du nombre de personnes dans la population dans chaque catégorie et les bornes de l'intervalle de confiance de cette estimation ;

-   Les différents résultats d'un test statistique lorsqu'il y en a un qui est pertinent.

La plupart des fonctions permettent aussi d'exporter directement ces trois résultats dans un format Excel, dans l'idée de pouvoir facilement communiquer les résultats à une tierce personne, ou à un graphiste dans le cas du travail de mise en page d'un rapport.

Dans la suite de cette partie, nous passons les fonctions en revue en indiquant quels sont leurs objectifs et spécificités.

## `distrib_discrete()` : distribution d'une variable catégorielle

`distrib_discrete()`, avec `distrib_d()` comme alias, calcule la distribution (en proportions relatives) des différentes modalités d'une variables qualitative. Pour l'exemple, nous utilisons la base de données de l'enquête SILC menée en Autriche en 2006, contenue dans le package `laeken`. Nous chargeons d'abord les données et recodons le statut socio-économiques (`pl030`) pour lui donner des labels intelligibles, utilisés dans la suite des exemples :

```{r}
library(fonctionr)
library(patchwork)

# Loading of data
data(eusilc, package = "laeken")

# Recoding eusilc$pl030 into eusilc$pl030_rec
eusilc$pl030_rec <- NA
eusilc$pl030_rec[eusilc$pl030 == "1"] <- "Working full time"
eusilc$pl030_rec[eusilc$pl030 == "2"] <- "Working part time"
eusilc$pl030_rec[eusilc$pl030 == "3"] <- "Unemployed"
eusilc$pl030_rec[eusilc$pl030 == "4"] <- "Student"
eusilc$pl030_rec[eusilc$pl030 == "5"] <- "Retired"
eusilc$pl030_rec[eusilc$pl030 == "6"] <- "Permanently disabled"
eusilc$pl030_rec[eusilc$pl030 == "7"] <- "Fulfilling domestic tasks"
```

Ci-dessous, la fonction `distrib_d()` décrit la distribution des différents statuts socio-économiques dans le dataframe `eusilc`, avec une le poids `rb050`[^1]. Comme on le voit, les variables sont indiquées sans guillemets, à la manière de la syntaxe du `tidyverse`.

[^1]: Précisons que dans cet exemple, il n'y a pas de plan de sondage qui est mentionné. Seule la variable de pondération est introduite. Nous aborderons ce point ultérieurement.

```{r}
# Computation, taking sample design into account
eusilc_dist_d <- distrib_d(
  data = eusilc,
  weights = rb050,
  quali_var = pl030_rec,
  probs = c(.2, .15, .1, .1, .25, .1, .1),
  title = "Distribution of socio-economic status",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

Nous affichons ensuite le graphique contenu dans la liste produite :

```{r}
eusilc_dist_d$graph
```

La liste contient également un dataframe `tab` qui reprend les chiffres sur base desquels le graphique est construit. Il comprend les colonnes suivantes : le nom de la modalité (`pl030_rec`), l'estimation de la proportion de la population appartenant à la modalité (`prop`), les bornes inférieure (`prop_low`) et supérieure (`prop_upp`) de l'intervalle de confiance de cette estimation à un niveau de confiance de 95%, le nombre de personnes dans l'échantillon appartenant à la modalité (`n_sample`), l'estimation du nombre de personnes dans la population appartenant à la modalité (`n_weighted`), et les bornes inférieure (`n_weighted_low`) et supérieure (`n_weighted_upp`) de l'intervalle de confiance de cette estimation à un niveau de confiance de 95% :

```{r}
eusilc_dist_d$tab
```

La liste contient pour finir le résultat du test statistique dans l'objet `test.stat`. Dans ce cas, il s'agit du khi2 d'adéquation. Ce test est réalisé avec comme hypothèse nulle la répartition de la population selon le vecteur mentionné dans l'argument `probs = c(.2, .15, .1, .1, .25, .1, .1)`, c'est-à-dire 20% de travailleurs à temps plein, 15% de travailleurs à temps partiel, 10% de chômeurs, 10% d'étudiants, 25% de pensionnés, 10% de personnes en incapacité permanente de travail et 10% de personnes au foyer. Si aucun vecteur n'avait été mentionné dans `probs`, aucun test n'aurait été effectué. Si le vecteur n'a pas une somme de 1, il est ajusté pour avoir une telle somme. Notons que la p-valeur du test est mentionnée sur le graphique.

```{r}
eusilc_dist_d$test.stat
```

## `distrib_group_discrete()` : distribution d'une variable catégorielle par groupe

`distrib_group_discrete()`, avec `distrib_group_d()` comme alias, calcule la distribution (en pourcentages) des différentes modalités d'une variables qualitative selon les modalités d'une autre variable qualitative, que l'on peut considérer comme des groupes. Par rapport aux autres fonctions, faute de représentation adéquate, les intervalles de confiance ne sont pas indiqués sur le graphique. Le test statistique repris est celui du khi2 de Pearson avec l'ajustement de Rao & Scott. Ce test est réalisé avec comme hypothèse nulle le fait que les deux variables qualitatives (d'intérêt et de groupe) soient statistiquement indépendantes.

L'exemple ci-dessous montre la distribution des fréquences des différents statuts socio-économiques (`pl030_rec`) selon la nationalité (`pb220a`).

```{r}
eusilc_dist_group_d <- distrib_group_d(eusilc,
  weights = rb050,
  group = pb220a,
  quali_var = pl030_rec,
  title = "Distribution of socio-economic status according to nationality",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_dist_group_d$graph
```

```{r}
eusilc_dist_group_d$tab
```

```{r}
eusilc_dist_group_d$test.stat
```

## `prop_group()` : proportion par groupe

`prop_group()` calcule des proportions pour les différentes modalités d'une variable qualitative, que l'on peut considérer comme des groupes. Pour indiquer la proportion à calculer, l'utilisateur peut indiquer soit une variable dichotomique, soit directement une expression (sans guillemet, à la manière du `tidyverse`) à partir de laquelle la proportion est calculée. L'exemple ci-dessous compare la proportion d'individus qui bénéficient d'une allocation de chômage (calculé avec l'expression `py090n > 0`) selon les différents statuts socio-économiques (`pl030_rec`).

```{r}
eusilc_prop <- prop_group(eusilc,
  group = pl030_rec,
  prop_exp = py090n > 0,
  weights = rb050,
  title = "% of ind. receiving unemployment benefits in their hh by soc.-eco. stat.",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_prop$graph
```

Le graphique et le tableau contiennent une modalité `Total` qui reprend l'estimation de la proportion pour l'ensemble de la population de référence. Dans le dataframe `tab` produit, on trouve :

-   l'estimation du nombre de personnes dans la population pour lesquelles le critère de proportion est vérifié (`n_true_weighted`) accompagné de ses bornes inférieure (`n_true_weighted_low`) et supérieure (`n_true_weighted_upp`) de l'intervalle de confiance à un niveau de confiance de 95% ;
-   le nombre total de personnes dans la population pour lesquelles les données sont valides[^2] (`n_tot_weighted`) accompagné de ses bornes inférieure (`n_tot_weighted_low`) et supérieure (`n_tot_weighted_upp`) de l'intervalle de confiance.

[^2]: Les personnes exclues, parce que, par exemple, la variable dichotomique prend une valeur `NA` et que l'on a décidé de ne pas les prendre en compte, ne sont pas reprises dans `n_tot_weighted,` de manière à ce que le ratio entre `n_true_weighted` et `n_tot_weighted` soit égal à `prop`.

Le test statistique réalisé est celui du khi2 de Pearson avec l'ajustement de Rao & Scott. Ce test est réalisé avec comme hypothèse nulle le fait que les deux variables qualitatives (les variables dichotomique *proportion vraie-fausse* et de groupe) soient statistiquement indépendantes .

```{r}
eusilc_prop$tab
```

```{r}
eusilc_prop$test.stat
```

## `central_group()` : valeur centrale (moyenne/médiane) par groupe

`central_group()` compare la valeur centrale d'une variable quantitative selon les modalités d'une variable qualitative, que l'on peut considérer comme des groupes. Deux valeurs centrales sont possibles :

-   la moyenne, quand l'argument `type = "mean"` ou pour l'alias `mean_group()` ;
-   la médiane, quand l'argument `type = "median"` ou pour l'alias `median_group()`.

L'argument `type` est prédéfini pour les fonctions "alias". Il ne doit pas être utilisé par l'utilisateur s'il utilise les fonctions "alias". Pour indiquer la tendance centrale à calculer, l'utilisateur peut indiquer soit une variable quantitative, soit directement une expression (sans guillemet, à la manière du `tidyverse`) à partir de laquelle une nouvelle variable quantitative est calculée. L'exemple ci-dessous compare le revenu équivalent mensuel moyen (calculé avec l'expression `eqIncome / 12`) selon les différents statuts socio-économiques des personnes (`pl030_rec`). Le graphique et le tableau contiennent une modalité "Total" qui reprend l'estimation de tendance centrale pour l'ensemble de la population de référence.

Pour `mean_group()`, le test statistique effectué est un test de Wald[^3]. Ce test est réalisé avec comme hypothèse nulle le fait que les coefficients d'une régression linéaire pour les modalités de la variable qualitative (les groupes) sur la variable quantitative soient nuls. Pour `median_group()`, le test statistique effectué est celui de Kruskal Wallis.

[^3]: Voir : <https://stackoverflow.com/questions/72843411/one-way-anova-using-the-survey-package-in-r>

```{r}
eusilc_mean <- mean_group(eusilc,
  group = pl030_rec,
  quanti_exp = eqIncome / 12,
  weights = rb050,
  title = "Mean of monthly equivalised income in household by socio-economic status",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_mean$graph
```

```{r}
eusilc_mean$tab
```

```{r}
eusilc_mean$test.stat
```

## `many_val()` : calculer plusieurs indicateurs

`many_val()` réalise des calculs de proportion ou de tendance centrale simultanément pour plusieurs variables différentes. La fonction permet de calculer trois résultats différents :

-   Le calcul de proportions quand l'argument `type = "prop"` ou pour l'alias `many_prop()` ;
-   Le calcul de moyennes quand l'argument `type = "mean"` ou pour l'alias `many_mean()` ;
-   Le calcul de médianes quand l'argument `type = "median"` ou pour l'alias `many_median()`.

L'argument `type` est prédéfini pour les fonctions "alias". Il ne doit pas être utilisé par l'utilisateur s'il utilise les fonctions "alias". Les variables pour lesquelles on veut réaliser ce calcul sont indiquées sans guillemets dans un vecteur passé à l'argument `list_vars`. Contrairement à `prop_group()` ou `central_group()`, on ne peut pas indiquer d'expression : ce doit être des variables dichotomisées (pour les proportions) ou quantitatives (pour les moyennes ou médianes). Le dataframe `tab` produit, contenant les indicateurs, est analogue à celui produit par `prop_group()` pour les proportions et `central_group()` pour les moyennes/médianes. Pour des raisons de lisibilité, ces fonctions ne calculent aucun test statistique.

L'exemple ci-dessous compare les revenus mensuels moyens de l'emploi salarié, d'une activité d'indépendant et d'une allocation de chômage dans la totalité de la population.

```{r}
# Computation, taking sample design into account
eusilc_many_mean <- many_mean(eusilc,
  list_vars = c(py010n, py050n, py090n),
  list_vars_lab = c("salaires", "revenus d'une activité indépendant", "allocation de chômage"),
  weights = rb050,
  unit = "€",
  title = "Income from wage, independant worker and unemployement benefits",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_many_mean$graph
```

```{r}
eusilc_many_mean$tab
```

## `many_val_group()` : calculer plusieurs indicateurs par groupe

`many_val_group()` fonctionne comme `many_val()`, mais permet d'indiquer une variable qualitative de groupes : les résultats sont alors différenciés selon les différentes modalités de cette variable (= les groupes). Trois calculs sont possibles :

-   La comparaison de proportions quand l'argument `type = "prop"` ou pour l'alias `many_prop_group()` ;
-   La comparaison de moyennes quand l'argument `type = "mean"` ou pour l'alias `many_mean_group()` ;
-   La comparaison de médianes quand l'argument `type = "median"` ou pour l'alias `many_median_group()`.

L'argument `type` est prédéfini pour les fonctions "alias". Il ne doit pas être utilisé par l'utilisateur s'il utilise les fonctions "alias". L'exemple ci-dessous compare les revenus mensuels moyens de l'emploi salarié, d'une activité d'indépendant et d'une allocation de chômage des femmes et des hommes.

```{r}
# Computation, taking sample design into account
eusilc_many_mean_group <- many_mean_group(eusilc,
  group = rb090,
  list_vars = c(py010n, py050n, py090n),
  list_vars_lab = c("salaires", "revenus d'une activité indépendant", "allocation de chômage"),
  weights = rb050,
  unit = "€",
  title = "Income from wage, independant worker and unemployement benefits by sex",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_many_mean_group$graph
```

```{r}
eusilc_many_mean_group$tab
```

## `distrib_continuous()` : distribution d'une variable continue

`distrib_continuous()`, avec `distrib_c()` comme alias, calcule la distribution d'une variable continue. L'argument `type` permet d'indiquer quel type de valeur centrale doit être calculée et indiquée sur le graphique : `"mean"` pour la moyenne et `"median"` pour la médiane. Par défaut, c'est la médiane qui est calculée et affichée. `bw` indique le degré de "lissage" de la densité. Une valeur plus élevée conduira à davantage lisser la densité et masquera davantage les variations locales. `resolution` indique la "finesse" du calcul de la densité. Avec une résolution plus faible, il y aura moins de points et on verra graphiquement les petites droites reliant les points de densité. Une grande résolution implique cependant des calculs plus longs.

L'exemple ci-dessous décrit la distribution de l'âge. L'objet produit est une liste qui comprend quatre éléments. On trouve `graph` et `tab`, comme dans les autres fonction.

```{r}
distrib_age <- distrib_c(eusilc, age, type = "mean", bw = .7)
```

```{r}
distrib_age$graph
```

```{r}
distrib_age$tab
```

L'objet `dens` reprend la densité calculée, et l'objet `quant` reprend les différents quantiles retenus. Dans cette fonction, il n'y a pas de test statistique calculé <!--# A terme si => à changer à ce moment là -->.

```{r}
head(distrib_age$dens)
```

```{r}
distrib_age$quant
```

## `distrib_group_continuous()` : distribution d'une variable continue par groupe

`distrib_group_continuous()`, avec `distrib_group_c()` comme alias, calcule la distribution d'une variables continue selon les modalités d'une variable qualitative, que l'on peut considérer comme des groupes. Comme pour `distrib_continous()`, la fonction produit une liste contenant un graphique (`graph`), une densité (`dens`), une table (`tab`), les quantiles retenus (`quant`). On trouve aussi une boite à moustache (`moustache`) qui indique les bornes dans lesquelles on trouve différentes proportions de la population autour de la médiane (par défaut : 50%, 75% et 95% - les proportions peuvent être paramétrées dans l'argument `moustache_probs`). Un test statistique est aussi implémenté. Comme pour `central_group()`, si l'utilisateur choisi de calculer la médiane (le choix par défaut), le test statistique effectué est celui de Kruskal Wallis ; s'il ou elle choisi de calculer la moyenne, test statistique effectué est un test de Wald.

L'exemple ci-dessous compare la distribution des revenus équivalents selon le statut socio-économique. Comme pour `central_group()`, il est possible d'utiliser une expression quantitative au lieu d'une variable. Ici, c'est le revenu équivalent annuel divisé par 12 qui est retenu pour qu'il soit exprimé en montant mensuel.

```{r}
distrib_income <- distrib_group_c(eusilc,
  pl030_rec,
  eqIncome / 12,
  type = "mean",
  limits = c(0, 4100),
  bw = .7
)
```

```{r}
distrib_income$graph
```

```{r}
distrib_income$tab
```

```{r}
head(distrib_income$dens)
```

```{r}
head(distrib_income$quant)
```

```{r}
head(distrib_income$moustache)
```

# Tableau récapitulatif des arguments

Comme nous l'avons vu, la majorité des fonctions de `fonctionr` se ressemblent. La plupart des arguments se retrouvent dans plusieurs fonctions. Le tableau ci-dessous reprend la totalité des argument en indiquant chaque fois pour quelle(s) fonction(s) il est utilisé. L'ordre repris est celui des fonctions et les couleurs regroupent les arguments selon leur "catégorie". Cette dernière a une visée pédagogique et regroupe ensemble des arguments dont le rôle est similaire. Dans la suite, nous aborderons successivement les arguments liés à la base de donnée utilisée, les arguments indispensables qui doivent obligatoirement être mentionnés, les arguments clés (c'est-à-dire pas obligatoire mais ayant une influence sur les résultats) et les arguments esthétiques - qui influencent le graphique.

```{r, echo=FALSE}
library(knitr)
library(kableExtra)

tableau_recap <- tibble::tribble(
   ~`Catégorie d’argument`,            ~type,    ~prop_group,  ~many_val_group,       ~many_val, ~central_group, ~distrib_group_discrete, ~distrib_discrete, ~distrib_group_continuous, ~distrib_continuous,    ~esth_graph,
         "Base de données",             "df",         "data",           "data",          "data",         "data",                  "data",            "data",                    "data",              "data",             "",
         "Base de données",             "df",             "",               "",              "",             "",                      "",                "",                        "",                  "",          "tab",
           "indispensable",         "quoted",        "group",          "group",              "",        "group",                 "group",                "",                   "group",                  "",             "",
           "indispensable",         "quoted",             "",               "",              "",             "",                      "",                "",                        "",                  "",          "var",
           "indispensable",         "quoted",     "prop_exp",               "",              "",             "",                      "",                "",                        "",                  "",             "",
           "indispensable",         "quoted",             "",               "",              "",   "quanti_exp",                      "",                "",              "quanti_exp",        "quanti_exp",             "",
           "indispensable",         "quoted",             "",               "",              "",             "",             "quali_var",       "quali_var",                        "",                  "",             "",
           "indispensable",         "quoted",             "",      "list_vars",     "list_vars",             "",                      "",                "",                        "",                  "",             "",
     "Esthétique : labels",         "string",             "",  "list_vars_lab", "list_vars_lab",             "",                      "",                "",                        "",                  "",             "",
           "indispensable",         "quoted",             "",               "",              "",             "",                      "",                "",                        "",                  "",        "value",
           "indispensable",         "string",             "",           "type",          "type",         "type",                      "",                "",                    "type",              "type",             "",
            "argument clé",         "quoted",        "facet",          "facet",         "facet",        "facet",                 "facet",           "facet",                   "?????",             "?????",        "facet",
            "argument clé",         "quoted",   "filter_exp",     "filter_exp",    "filter_exp",   "filter_exp",            "filter_exp",      "filter_exp",              "filter_exp",        "filter_exp",             "",
         "Base de données",    "dot dot dot",            "…",              "…",             "…",            "…",                     "…",               "…",                       "…",                  "",             "",
            "argument clé",        "logical",  "na.rm.group",    "na.rm.group",              "",  "na.rm.group",           "na.rm.group",                "",             "na.rm.group",                  "",             "",
            "argument clé",        "logical",  "na.rm.facet",    "na.rm.facet",   "na.rm.facet",  "na.rm.facet",           "na.rm.facet",     "na.rm.facet",                   "?????",             "?????",             "",
            "argument clé",         "string",             "",               "",              "",             "",             "na.rm.var",       "na.rm.var",                        "",                  "",             "",
            "argument clé",         "string",      "na.prop",               "",              "",             "",                      "",                "",                        "",                  "",             "",
            "argument clé",         "string",             "",        "na.vars",       "na.vars",             "",                      "",                "",                        "",                  "",             "",
            "argument clé", "numeric vector",             "",               "",              "",             "",                      "",                "",               "quantiles",         "quantiles",             "",
            "argument clé", "numeric vector",             "",               "",              "",             "",                      "",                "",         "moustache_probs",                  "",             "",
            "argument clé",        "numeric",             "",               "",              "",             "",                      "",           "probs",                        "",                  "",             "",
            "argument clé",         "string",  "prop_method",    "prop_method",   "prop_method",             "",           "prop_method",     "prop_method",                        "",                  "",             "",
      "Esthétique de base",        "numeric",             "",               "",              "",             "",                      "",                "",                      "bw",                "bw",             "",
      "Esthétique de base",        "numeric",             "",               "",              "",             "",                      "",                "",              "resolution",        "resolution",             "",
      "Esthétique de base",        "numeric",             "",               "",              "",             "",                      "",                "",                  "height",                  "",             "",
      "Esthétique de base",        "numeric",             "",               "",              "",             "",                      "",                "",                  "limits",            "limits",             "",
      "Esthétique de base",        "logical",      "reorder",               "",       "reorder",      "reorder",                      "",         "reorder",                 "reorder",                  "",      "reorder",
      "Esthétique de base",         "string",             "",       "position",              "",             "",                      "",                "",                        "",                  "",             "",
      "Esthétique de base",        "logical",      "show_ci",        "show_ci",       "show_ci",      "show_ci",                      "",         "show_ci",                        "",                  "",             "",
      "Esthétique de base",         "quoted",             "",               "",              "",             "",                      "",                "",          "show_mid_point",                  "",    "error_low",
      "Esthétique de base",         "quoted",             "",               "",              "",             "",                      "",                "",           "show_mid_line",     "show_mid_line",    "error_upp",
      "Esthétique de base",        "logical",             "",               "",              "",             "",                      "",                "",        "show_ci_errorbar",                  "",             "",
      "Esthétique de base",        "logical",             "",               "",              "",             "",                      "",                "",           "show_ci_lines",     "show_ci_lines",             "",
      "Esthétique de base",        "logical",             "",               "",              "",             "",                      "",                "",            "show_ci_area",      "show_ci_area",             "",
      "Esthétique de base",        "logical",             "",               "",              "",             "",                      "",                "",        "show_quant_lines",  "show_quant_lines",             "",
      "Esthétique de base",        "logical",             "",               "",              "",             "",                      "",                "",          "show_moustache",                  "",             "",
      "Esthétique de base",        "logical",       "show_n",         "show_n",        "show_n",       "show_n",                      "",          "show_n",                  "show_n",            "show_n",             "",
      "Esthétique de base",         "quoted",             "",               "",              "",             "",                      "",                "",                        "",                  "",        "n_var",
      "Esthétique de base",        "logical",   "show_value",     "show_value",    "show_value",   "show_value",            "show_value",      "show_value",              "show_value",        "show_value",   "show_value",
      "Esthétique de base",        "logical",     "show_lab",       "show_lab",      "show_lab",     "show_lab",              "show_lab",        "show_lab",                "show_lab",          "show_lab",             "",
      "Esthétique de base",         "string",   "total_name",               "",              "",   "total_name",                      "",                "",                        "",                  "",             "",
      "Esthétique de base",         "string",             "",               "",              "",             "",                      "",                "",                        "",                  "",   "name_total",
   "Esthétique : chiffres",        "numeric",        "scale",          "scale",         "scale",             "",                 "scale",           "scale",                        "",                  "",        "scale",
   "Esthétique : chiffres",        "numeric",       "digits",         "digits",        "digits",       "digits",                "digits",          "digits",                  "digits",            "digits",       "digits",
   "Esthétique : chiffres",         "string",         "unit",           "unit",          "unit",         "unit",                  "unit",            "unit",                    "unit",              "unit",         "unit",
   "Esthétique : chiffres",         "string",          "dec",            "dec",           "dec",          "dec",                   "dec",             "dec",                     "dec",               "dec",          "dec",
  "Esthétique : graphique",         "string",         "fill",               "",              "",         "fill",                      "",            "fill",                        "",                  "",         "fill",
  "Esthétique : graphique",         "string",             "",            "pal",           "pal",             "",                   "pal",                "",                     "pal",               "pal",             "",
  "Esthétique : graphique",        "numeric",             "",      "direction",     "direction",             "",             "direction",                "",                        "",                  "",             "",
  "Esthétique : graphique",         "string",             "",               "",              "",             "",                      "",                "",           "pal_moustache",                  "",             "",
  "Esthétique : graphique",         "string",             "",               "",              "",             "",                      "",                "",                   "color",             "color",             "",
  "Esthétique : graphique",        "numeric",             "",               "",              "",             "",                      "",                "",                   "alpha",                  "",             "",
  "Esthétique : graphique",        "numeric",        "dodge",          "dodge",         "dodge",        "dodge",                 "dodge",           "dodge",                        "",                  "",        "dodge",
   "Esthétiques : lettres",         "string",         "font",           "font",          "font",         "font",                  "font",            "font",                    "font",              "font",         "font",
   "Esthétiques : lettres",        "numeric", "wrap_width_y",   "wrap_width_y",  "wrap_width_y", "wrap_width_y",          "wrap_width_y",    "wrap_width_y",            "wrap_width_y",                  "", "wrap_width_y",
   "Esthétiques : lettres",        "numeric",             "", "wrap_width_leg",              "",             "",        "wrap_width_leg",                "",                        "",                  "",             "",
   "Esthétiques : lettres",        "numeric",             "",    "legend_ncol",              "",             "",           "legend_ncol",                "",                        "",                  "",             "",
     "Esthétique : labels",         "string",        "title",          "title",         "title",        "title",                 "title",           "title",                   "title",             "title",        "title",
     "Esthétique : labels",         "string",     "subtitle",       "subtitle",      "subtitle",     "subtitle",              "subtitle",        "subtitle",                "subtitle",          "subtitle",     "subtitle",
     "Esthétique : labels",         "string",         "xlab",           "xlab",          "xlab",         "xlab",                  "xlab",            "xlab",                    "xlab",              "xlab",         "xlab",
     "Esthétique : labels",         "string",         "ylab",           "ylab",          "ylab",         "ylab",                  "ylab",                "",                    "ylab",              "ylab",         "ylab",
     "Esthétique : labels",         "string",             "",     "legend_lab",              "",             "",            "legend_lab",                "",                        "",                  "",             "",
     "Esthétique : labels",         "string",      "caption",        "caption",       "caption",      "caption",               "caption",         "caption",                 "caption",           "caption",      "caption",
                  "Export",         "string",  "export_path",    "export_path",   "export_path",  "export_path",           "export_path",     "export_path",             "export_path",       "export_path",             ""
  )

tableau_recap <- tableau_recap[tableau_recap$`Catégorie d’argument` != "Export", ]
tableau_recap <- tableau_recap[, names(tableau_recap) != "esth_graph"]
pal_tableau_recap <- hcl.colors(9, "Pastel1", rev = F)

tableau_recap |>
kbl() |>
  kable_paper(full_width = F, font_size = 12) |> 
  row_spec(0, bold = T, color = "black") |>
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Base de données"), color = "black", background = pal_tableau_recap[1]) |> 
  row_spec(which(tableau_recap$`Catégorie d’argument`=="indispensable"), color = "black", background = pal_tableau_recap[2]) |> 
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Esthétique : labels"), color = "black", background = pal_tableau_recap[3]) |> 
  row_spec(which(tableau_recap$`Catégorie d’argument`=="argument clé"), color = "black", background = pal_tableau_recap[4]) |>
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Esthétique de base"), color = "black", background = pal_tableau_recap[5]) |>
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Esthétique : chiffres"), color = "black", background = pal_tableau_recap[6]) |>
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Esthétique : graphique"), color = "black", background = pal_tableau_recap[7]) |>
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Esthétiques : lettres"), color = "black", background = pal_tableau_recap[8]) |>
  row_spec(which(tableau_recap$`Catégorie d’argument`=="Esthétique : labels"), color = "black", background = pal_tableau_recap[9])
```

# Les arguments liés à la base de données utilisée

`data` est bien entendu un argument fondamental car il indique la base de donnée à utiliser. Comme l'objectif du package est de permettre une analyse des sondages complexes, il peut s'agir d'un objet `survey` ou d'un objet `srvyr`, qui contiennent les différentes informations sur le plan de sondage (poids, strates, PSU...). Il est possible que l'objet `survey` ou `srvyr` soit un objet avec avec des *replicate weights* pour utiliser les méthodes de rééchantillonnage pour estimer la variance d'échantillonnage.

Il est également possible que `data` soit un dataframe. Dans ce cas, si aucune autre précision n'est apportée, les fonctions font l'hypothèse d'un sondage aléatoire simple. Ainsi, `fonctionr` peut être utilisé pour l'analyse des sondages complexes mais aussi des sondages aléatoires simple. Mais `fonctionr` peut créer un objet de sondage complexe à partir d'un dataframe. Les arguments définissant le design de l'enquête (poids, strates, etc.) doivent alors être indiqués dans l'argument `…` (dot-dot-dot). Cette manière de procéder fonctionne pour les sondages complexes classiques mais pas pour les sondages complexes intégrant des *replicate weights*. Si l'ont veut intégrer des *replicates weights*, il est nécessaire de créer d'abord un objet `survey` ou `srvyr` et d'utiliser cet objet dans `fonctionr`.

Les exemples ci-dessous montrent trois manière différentes de prendre en compte un même plan de sondage : en l'indiquant directement dans la fonction de `fonctionr`, en créant d'abord un objet `survey` et en créant d'abord un objet `srvyr`.

```{r}
library(survey)
library(srvyr)

# Un exemple où on indique directement dans la fonction de fonctionr les différents éléments du plan de sondage
eusilc_prop_1 <- prop_group(eusilc,
  group = pl030_rec,
  prop_exp = py090n > 0,
  strata = db040,
  ids = db030,
  weights = rb050,
  title = "dataframe"
)

# Un exemple où utilise un objet survey
eusilc_survey <- svydesign(id = ~db030, strat = ~db040, weight = ~rb050, data = eusilc)
eusilc_prop_2 <- prop_group(eusilc_survey,
  group = pl030_rec,
  prop_exp = py090n > 0,
  title = "survey object",
  ylab = "",
  wrap_width_y = 15
)

# Un exemple où utilise un objet srvyr
eusilc_srvyr <- as_survey_design(eusilc, ids = db030, strata = db040, weights = rb050)
eusilc_prop_3 <- prop_group(eusilc_srvyr,
  group = pl030_rec,
  prop_exp = py090n > 0,
  title = "srvyr object",
  ylab = "",
  wrap_width_y = 15
)
```

```{r}
eusilc_prop_1$graph | eusilc_prop_2$graph | eusilc_prop_3$graph
```

# Les arguments indispensables

Les arguments indispensable sont des arguments qui sont nécessaire au bon fonctionnement des fonctions et qui ne peuvent prendre aucune valeur par défaut. Ces arguments sont principalement de différents types : variables qualitatives, expressions ou listes de variables. Les variables/colonnes sont toujours indiquées sans guillemets, à la manière de la syntaxe du `tidyverse`.

-   `group` et `quali_var` sont des variables qualitatives qui indiquent les groupes ou variables qualitative dont on veut calculer la distribution. Les variables indiquées pour ces arguments sont transformées en facteurs pour leur usage dans la fonction.

-   `prop_exp` et `quanti_exp` sont des expressions qui permettent de calculer les proportions ou tendances centrales. Ces arguments peuvent être des variables (une variable binaire 0-1 pour `prop_exp` et une variable numérique pour `quanti_exp`) ou une expression qui produit une variable (binaire pour `prop_exp` et quantitative pour `quanti_exp`). Ainsi, il n'est pas nécessaire de préparer à l'avance les variables binaire ou la quantitative, elles peuvent être calculées "à la volée". Précisons que seuls les variables de la base de données, les opérateurs et les valeurs numérique sont autorisés dans les expressions ; les objets extérieurs (par exemple un seuil contenu dans un vecteur stocké dans l'environnement global) ne sont pas autorisés.

-   `list_vars` doit être un vecteur reprenant l'ensemble des variables reprises dans les fonctions `many_val()` et `many_val_group()` ainsi que leurs alias. Pour `many_prop()` et `many_prop_group()`, les variables doivent être binaires (il aurait été trop compliqué d'introduire ici des expressions) et pour `many_mean()`, `many_mean_group()`, `many_median()` et `many_median_group()`, les variables doivent être numériques. L'argument `list_vars_lab` permet d'indiquer le label pour les variables à l'aide d'un vecteur. Bien qu'il ne s'agisse pas d'un argument indispensable, nous l'avons placé juste après `list_vars` pour faciliter l'utilisation des fonctions. Pour cet argument, les guillemets doivent être utilisé pour indiquer les labels des variables.

Dans l'exemple ci-dessous, on calcule la proportion des répondant qui travaillent et dont le salaire net annuel était inférieur à 12000€. On peut ainsi introduire des expressions complexe dans les fonctions.

```{r}
eusilc_prop_NA_excl <- prop_group(eusilc,
  group = rb090,
  prop_exp = (pl030 == "1" | pl030 == "2") & py010n < 12000,
  weights = rb050,
  title = "% of the population that works and whose wage is less than 12000€ net",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_prop_NA_excl$graph
```

# Les arguments clés : pas obligatoires mais influençant les résultats

Les arguments clés sont des arguments qui ne sont pas indispensable mais qui influencent les résultats. On y retrouve plusieurs types d'arguments.

-   `facet` est une variable qualitative qui produit des facettes dans le dataframe de résultats `tab` et dans le graphique `ggplot2`. Comme `group` et `quali_var`, la variable indiquée pour cet argument est transformée en facteur pour leur usage dans la fonction. Par défaut, les facettes ne sont pas produites.

-   `filter_exp` est une expression qui permet de filtrer les données de manière à produire les résultats sur une partie de l'échantillon. Comme il s'agit d'une expression, il est possible de mettre en oeuvre des conditions de filtres complexe et multiples, par exemple sélectionner uniquement les personnes âgées de moins de 60 ans, dont le revenu mensuel est inférieur à 3000€ et qui sont célibataires. Si une possibilité de filtrage est inclue dans les fonctions, c'est pour que le filtrage des données soit réalisé après la définition du plan de sondage, afin que le filtrage ne modifie pas celui-ci[^4]. Ici aussi, seules les variables de la base de données, les opérateurs et les valeurs numérique sont autorisés dans les expressions.

-   `prop_method` est un argument qui permet de choisir le type de correction pour l'estimation des intervalles de confiance d'une proportion, notamment pour éviter d'avoir des bornes inférieures à 0 ou supérieures à 1. Les valeurs peuvent prendre celles mentionnées dans l'argument method de `svyciprop()` du package `survey`[^5]. Par défaut, c'est la méthode `"beta"` qui est utilisée.

-   `quantiles` est un argument qui permet de choisir, sous forme d'un vecteur, les quantiles à calculer et à indiquer sur le graphique dans `distrib_continuous()` et `distrib_group_continuous()`. Par défaut, ce sont des déciles qui sont calculés.

[^4]: Voir : <https://notstatschat.rbind.io/2021/07/22/subsets-and-subpopulations-in-survey-inference/>

[^5]: Voir : <https://search.r-project.org/CRAN/refmans/survey/html/svyciprop.html>

## Le traitement des `NA`

Nous expliquons ici plus précisément le traitement des `NA` dans les fonctions, car les possibilités sont multiples. Nous avons décidé de laisser des possibilités différentes selon les variables dans lesquelles se trouvent les `NA` : groupes, variables d'intérêts, expressions, etc.

-   `na.rm.group`, `na.rm.facet`, `na.rm.var` indiquent respectivement la manière dont les éventuels `NA` dans les variables `group`, `facet` et dans `quali_var` sont traités. Si l'argument est `TRUE`, les `NA` sont retirés dans les calculs. Si l'argument est `FALSE`, une modalité spécifique est créée pour les `NA`. Dans ce cas, ils prennent toujours la couleur gris clair sur le graphique, pour pointer leur spécificité. Dans le cas où ils sont retirés, ils ne sont pas pris en compte pour calculer le total, le cas échéant. Par défaut, l'argument prend la valeur `FALSE`, c'est-à-dire que les `NA` sont supprimés des analyses.

Dans l'exemple ci-dessous, on compare la distribution des statuts socio-professionnels entre régions, en y ajoutant une modalité `NA` pour le statut (il s'agit des personnes de moins de 16 ans qui ne sont pas interrogées), en filtrant les données pour ne conserver que les personnes de plus de 11 ans et introduisant la variable sexe comme facette. Comme nous le verrons, la couleur des `NA` est toujours grise et ne dépend pas de la palette de couleur, de manière à les identifier spécifiquement.

```{r}
eusilc_dist_group_d <- distrib_group_d(eusilc,
  group = db040,
  quali_var = pl030_rec,
  na.rm.var = FALSE,
  facet = rb090,
  filter_exp = age > 11,
  weights = rb050,
  title = "Distribution of socio-economic status according to region and gender",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_dist_group_d$graph
```

-   `na.prop` indique la manière dont les éventuels `NA` sont traités dans les variables introduites dans `prop_exp`. Si l'argument prend la valeur `"rm"`, tous les `NA` présents dans au moins une des variable faisant partie de `prop_exp` sont exclus avant de procéder aux calculs. De cette manière, la proportion est calculée uniquement sur les observations "valides". Dans ce cas, pour des raisons évidentes, il n'est pas possible d'utiliser la fonction `is.na()` dans `prop_exp` (on ne peut pas calculer la proportion de personnes dont le statut professionnel est `NA` si on a supprimé les `NA`). Si l'argument prend la valeur `"include"`, les `NA` ne sont pas retirés avant de procéder aux calculs et la proportion est calculée sur l'ensemble des observations, `NA` compris. Cela peut être utile quand les `NA` n'indiquent pas une valeur manquante mais une situation spécifique. Par exemple, dans une variable mesurant les points obtenu par des étudiants à un examen, le `NA` peut indiquer que l'étudiant était absent ; on peut donc vouloir calculer la proportion d'étudiants ayant au moins 12/20 en conservant les absents au dénominateur, ce qui est possible avec `na.prop = "include"`. Par défaut, `na.prop` prend la valeur `"rm"`. Précisons que pour `central_group()` et ses alias `mean_group()` et `median_group()`, il n'y a pas d'argument permettant de choisir le traitement des `NA` dans `quanti_exp`. Les observations comprenant au moins un `NA` dans une variable indiquée dans `quanti_exp` sont automatiquement exclues des calculs, car il n'y a pas d'autres possibilité qui soit pertinente.

Les deux graphiques ci-dessous comparent la part de travailleurs selon le sexe en excluant ou en incluant les `NA`. Les taux du second graphique sont plus faible, car dans celui-ci les personnes n'ayant pas de statut socio-professionnel (ex. les enfants) sont comptabilisés dans le dénominateur.

```{r}
eusilc_prop_NA_excl <- prop_group(eusilc,
  group = rb090,
  prop_exp = pl030 == "1" | pl030 == "2",
  weights = rb050,
  na.prop = "rm",
  title = "% workers (NA excluded)"
)

eusilc_prop_NA_incl <- prop_group(eusilc,
  group = rb090,
  prop_exp = pl030 == "1" | pl030 == "2",
  weights = rb050,
  na.prop = "include",
  title = "% workers (NA included)"
)
```

```{r}
eusilc_prop_NA_excl$graph | eusilc_prop_NA_incl$graph
```

-   `na.vars` indique la manière dont les `NA` doivent être traités dans les différentes variables de `many_val()` et `many_val_group()`. Si l'argument prend la valeur `"rm"`, les `NA` sont exclus séparément dans chaque variable. Il en résulte que l'échantillon ne sera pas toujours le même pour chacune des variables calculées, mais on conserve un maximum d'observations. Si l'argument prend la valeur `"rm.all"`, les observations qui comprennent au moins un `NA` dans n'importe quelle des variables de `list_vars` sont exclues. Cette manière de procéder exclut plus d'observations mais permet d'avoir un échantillon identique pour toutes les variables. Par défaut, `na.vars` prend la valeur `"rm"`. <!--# François : Je me demande s'il ne faut pas mettre un exemple sur na.vars ici, mais je n'en vois pas de bien à partir du jeu de données SILC Autriche -->

# Les arguments esthétiques

Les arguments esthétiques sont des arguments qui affectent uniquement le graphique produit et pas la table, ni le test statistique. Pour des raisons pédagogique, nous aborderons successivement les arguments d'esthétique de base, d'esthétique graphique, d'esthétique des chiffres, d'esthétique des lettres et les labels.

## L'esthétique de base

-   `reorder` est un argument qui, en prenant la valeur `TRUE`, permet de réordonner les catégories selon leur valeur décroissante. Si `reorder = FALSE`, les catégories ne sont pas réordonnées et c'est l'ordre des *levels* de la variable qui est utilisé si c'est un facteur, ou l'ordre alphabétique si c'est une variable string. La catégorie `NA` - quand elle existe (par exemple avec `na.rm.group = FALSE`) - et la catégorie "Total" ne sont jamais réordonnées et sont toujours positionnées dans le bas du graphique. En cas de facettes, les catégories sont réordonnées sur base de chaque catégorie médiane. Par exemple, si l'on utilise des facettes dans `prop_group()`, la fonction identifie, pour chaque groupe, quelle est la proportion médiane par groupe et puis elle va ordonner les groupes sur bases de ces médianes. Par défaut, `reorder` prend la valeur de `FALSE`. `reorder` n'est pas disponible dans `distrib_group_discrete()` et `many_val_group()` ainsi que ses alias (`many_prop_group()`, `many_mean_group()` et `many_median_group()`), car il y a plusieurs proportions ou indicateurs et il est difficile de choisir sur lequel ou laquelle réordonner.

Dans l'exemple ci-dessous, les revenus moyens des statut socio-économique sont réordonnés. Comme il y a des facettes, c'est le médian de chaque catégorie qui est utilisée pour construire. Par exemple, la catégorie "Permanently disabled" se situe en troisième position, car sa valeur médiane (15199€) se entre entre le médian de la catégorie "Student" (15097€) et de la catégorie "Working part time" (16511€).

```{r}
eusilc_mean_reorder <- mean_group(eusilc,
  group = pl030_rec,
  quanti_exp = eqIncome,
  facet = pb220a,
  weights = rb050,
  reorder = TRUE,
  unit = "€",
  title = "Mean of eq. income by status and nationality",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_mean_reorder$graph
```

-   `position` est un argument qui ne se trouve uniquement dans `many_val_group()` et qui peut prendre les valeurs de `"dodge"` et de `"stack"`. Avec `"dodge"`, les barres ne sont pas empilées. Avec `"stack"`, les barres sont empilées dans chaque groupe. Cette option peut avoir un intérêt quand les variables ont vocation à être additionnées, par exemple avec des revenus selon différentes sources qui peuvent former un revenu total. `"dodge"` est la valeur par défaut.

Dans l'exemple ci-dessous, il est pertinent d'empiler les barres indiquant les différents revenus pour visualiser le revenu total. Cependant, dans ce cas, on peut plus indiquer les intervalles de confiance sur le graphique.

```{r}
#Exemple avec Stack 
eusilc_many_mean_group_2a <- many_mean_group(eusilc,
  group = rb090,
  list_vars = c(py010n, py050n, py090n),
  list_vars_lab = c("salaires", "revenus d'une activité indépendant", "allocation de chômage"),
  weights = rb050,
  position = "stack",
  title = "position = 'stack'",
  legend_ncol = 2
)
#Exemple avec dodge 
eusilc_many_mean_group_2b <- many_mean_group(eusilc,
  group = rb090,
  list_vars = c(py010n, py050n, py090n),
  list_vars_lab = c("salaires", "revenus d'une activité indépendant", "allocation de chômage"),
  weights = rb050,
  position = "dodge",
  title = "position = 'dodge'",
  legend_ncol = 2
)
```

```{r}
eusilc_many_mean_group_2a$graph | eusilc_many_mean_group_2b$graph
```

-   `show_ci`, `show_n`, `show_value` et `show_lab` permettent de montrer ou cacher différents éléments sur le graphique avec les valeurs `TRUE` et `FALSE` :

    -   l'intervalle de confiance (`show_ci`),
    -   le nombre de personnes dans l'échantillon (`show_n`),
    -   l'estimation de l'indicateur (`show_value`)
    -   les titres et sous-titres du graphiques, des axes et de la légende (`show_lab`).

Faute de représentation graphique adéquate, `show_ci` n'est pas un argument de la fonction `distrib_group_discrete()`. Pour cette fonction, il est pas possible de représenter les intervalles de confiance sur le graphique, mais ils sont bien calculé dans le dataframe `tab`. C'est aussi le cas pour `many_val_group()` et ses alias quand `position = "stack"`. Précisons aussi que dans `distrib_group_discrete()`, seules les valeurs supérieures à 2% sont indiquées sur le graphique pour des raisons de lisibilité. Pour `distrib_continuous()` l'argument `show_n` indique les effectifs de l'échantillon pour chaque quantile.

-   `total_name` indique le nom qui doit être mentionné à côté du résulat du total dans le graphique. Par défaut, il s'agit de "Total", mais l'utilisateur peut indiquer autre chose de plus spécifique.

Dans l'exemple ci-dessous, on ne montre plus les intervalles de confiances, les valeurs de l'indicateur et les labels des titres, par contre on montre le nombre de personnes dans l'échantillon et on a changé le nom du "Total".

```{r}
eusilc_prop <- prop_group(eusilc,
  group = db040,
  prop_exp = pl030 == "1" | pl030 == "2",
  weights = rb050,
  show_ci = FALSE,
  show_n = TRUE,
  show_value = FALSE,
  show_lab = FALSE,
  total_name = "Total Austria"
)
```

```{r}
eusilc_prop$graph
```

Certains arguments sont spécifiques aux fonctions `distrib_continous()` et `distrib_group_continous()` :

-   `height` indique la hauteur des courbes de densité dans `distrib_group_continuous()`. Une valeur plus élevée mènent à des courbes plus hautes qui peuvent éventuellement se chevaucher. La valeur par défaut est 0.8.

-   `limits` indique les limites de l'axe des abscisses du graphique . Par défaut, il n'y a pas de limites, ce qui revient à montrer sur le graphique la totalité de la distribution. Cependant, cela peut poser problème pour des distributions asymétriques avec quelques valeurs extrêmes, par exemple pour les variables de revenu. `limits` permet de zoomer sur la partie du graphique la plus intéressante qui reprend la majorité des observations. Précisons qu'il ne s'agit pas d'un filtre, mais d'un zoom : les déciles, valeurs centrales et moustaches sont toujours calculées sur l'ensemble de la distribution. En cas d'utilisation de zoom important, il est conseillé d'utiliser une résolution plus élevée. A noter que lorsque `show_n = TRUE` pour `distrib_continous()`, on n'indique pas les effectifs pour les quantiles qui ne sont pas complètement représentés quand on utilise l'argument `limits`.

-   D'autres arguments de type `show_*` sont spécifiques à ces deux fonctions. C'est le cas de `show_mid_line`, `show_ci_lines`, `show_ci_area`, `show_quant_lines` qui se retrouvent dans les deux fonctions de distribution continue et `show_mid_point`, `show_ci_errorbar` et `show_moustache` qui sont spécifiques à `distrib_group_continuous()`.

    -   `show_mid_point` et `show_mid_line` permettent de montrer la valeur centrale, médiane ou moyenne, sous la forme d'un point ou d'une ligne.
    -   `show_ci_errorbar`, `show_ci_lines` et `show_ci_area` permettent de montrer l'intervalle de confiance de la valeur centrale sous la forme d'une barre d'erreur de lignes en pointillée ou d'une aire colorée.
    -   `show_quant_lines` permet de tracer des lignes pour les valeurs des quantiles sur le graphique.
    -   `show_moustache` permet de montrer la boite à moustache.

Par défaut, `distrib_continuous()` indique la la valeur centrale par une ligne et ses intervalles de confiance par des lignes pointillées et ne trace pas de ligne pour les quantiles. Par défaut, `distrib_group_continuous()` indique les valeurs centrales par des points et leurs intervalles de confiance par des barres d'erreurs, et ne dessine pas d'autres éléments que la moustache sur le graphique .

Dans l'exemple ci-dessous, nous comparons les revenus du travail des travailleurs à temps partiel selon la région, en modifiant de nombreuses options graphiques. `bw` étant plus faible, la distribution est moins lissée et on peut y observer des variations de densités plus locales. `resolution` étant plus faible, on peut déceler les droites qui composent les courbes de densité. `limits` permet de se concentrer sur la plage de valeur (de -500€ à 3000€) qui contient la grande majorité des observations. `height` a été défini pour que les aires de densité se chevauchent. Pour que ce chevauchement soit esthétique, `alpha` a été réglé à `.3` pour des aires transparentes et une bordure a été ajoutée avec `color = black`. On a indiqué la médiane sous la forme d'une ligne. Ses intervalles de confiance sont indiqués par deux lignes en pointillées et une aire colorées. Les déciles sont indiqués par des lignes verticales grises et on a masqué la moustache. Notez que le revenu du travail mensuel est directement calculé dans l'expression en additionnant le salaire avec le revenu d'une activité indépendante avant de diviser le tout par 12.

```{r}
distrib_income_2 <- distrib_group_c(eusilc,
  db040,
  (py010n + py050n) / 12,
  filter_exp = pl030 == 2,
  bw = .7,
  resolution = 50,
  height = 1.5,
  limits = c(-500, 3000),
  show_mid_point = F,
  show_value = F,
  show_mid_line = T,
  show_ci_errorbar = F,
  show_ci_lines = T,
  show_ci_area = T,
  show_quant_lines = T,
  show_moustache = F,
  color = "black",
  pal = "purple",
  alpha = .4
)
```

```{r}
distrib_income_2$graph
```

## L'esthétique graphique

-   `dodge` indique l'épaisseur des barres et peut aller de `0` (barre invisible car d'épaisseur nulle) à `1` (barre se touchant car ne laissant aucun espace entre elles). La valeur par défaut est de `0.9`.

-   Les couleurs des barres peuvent être indiquées dans les arguments `fill` et `pal`.

    -   `fill` est utilisé pour les graphiques monochrome (`prop_group()`, `central_group()` et ses alias, `distrib_discrete()`<!--# et esth_graph(), mais déplacé dans une autre page -->). Les couleurs de base de R ou un code couleur hexadécimal peuvent être indiqués dans `fill`.
    -   `pal` est utilisé pour les graphiques avec plusieurs couleurs. pal doit reprendre le nom d'une palette des packages `MetBrewer`, `MoMAColors` ou `PrettyCols`. L'argument direction permet d'inverser le sens de la palette, en remplaçant le `1`, par défaut, par `-1` pour avoir le sens opposé. Pour `many_val()` et ses alias, `pal` peut aussi prendre une couleur unie (couleur de R ou code hexadécimal) si l'utilisateur souhaite un graphique monochrome.

Les couleurs des `NA` et des totaux, quand ils sont présents sont toujours gris (`grey`) et gris foncé (`grey40`) et ne sont pas modifiable par les arguments `fill` ou `pal`. Par défaut, des couleurs ou des palettes de couleurs différentes ont été choisies pour chacune des fonctions, y compris les alias, pour éviter la confusion des graphiques.

Dans l'exemple ci-dessous, on utilise une autre palette de couleur et des barres plus fines.

```{r}
eusilc_dist_group_d <- distrib_group_d(eusilc,
  group = db040,
  quali_var = pl030_rec,
  weights = rb050,
  pal = "VanGogh2",
  dodge = .5,
  title = "Distribution of socio-economic status according to region",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_dist_group_d$graph 
```

-   Dans `distrib_continuous()` et `distrib_group_continuous()`, `pal` peut soit prendre la valeur d'une couleur, soit un vecteur reprenant plusieurs couleurs. Dans le cas d'une seule couleur, les graphiques seront monochrome, dans le cas de plusieurs couleurs, une palette de couleur est créée en passant par les différentes couleurs indiquées pour colorer les différents quantiles, la première couleur indiquant la coloration des premiers et derniers quantiles, et la dernière couleur indiquant la coloration du quantile central[^6]. Précisons que le vecteur de `pal` doit être un vecteur de couleur de R ou de codes hexadécimaux, mais pas une des palettes des packages `MetBrewer`, `MoMAColors` ou `PrettyCols` utilisées dans `pal` pour les autres fonctions. Par défaut `distrib_continuous()` utilise un dégradé de bleu pour les quantiles et `distrib_group_continuous()` colorie les courbes de densité en gris, de manière à ne pas surcharger le graphique avec les quantiles. Ces deux fonction ont aussi l'argument `color` qui permet de définir la couleur de la ligne supérieure de la courbe de densité. Par défaut cette ligne n'est pas affichée.

-   `distrib_group_continuous()` comprend aussi l'argument `pal_moustache` qui détermine les couleurs de la moustache et `alpha` qui détermine la transparence de la couleur de la densité. `pal_moustache` fonctionne comme `pal` et peut comprendre une couleur unie ou un vecteur de couleur. Mais logiquement, il n'est pas pertinent de représenter une moustache monochrome. Comme pour pour `pal`, il n'est pas nécessaire de définir chaque teinte de couleur individuellement, puisque la fonction produit une palette de couleur comprenant tous les dégradés nécessaires. `alpha` peut prendre une valeur allant de 0 (couleur totalement transparente et donc invisible) à 1 (couleur sans transparence). Avoir un certain degré de transparence est particulièrement utile si les différentes courbes se superposent (quand `height` est élevé).

[^6]: En cas d'un nombre pair de quantiles, par exemple pour des déciles ou des quartiles, les deux catégories centrales prennent des couleurs différentes : c'est celle du haut qui prend la couleur indiquée en dernière position du vecteur `pal`.

Dans l'exemple ci-dessous, on utilise trois couleurs pour construire la palette qui va colorier l'aire de la densité et on trace la courbe de densité en rouge.

```{r}
distrib_age_2 <- distrib_c(eusilc,
  age,
  type = "mean",
  quantiles = seq(.05, .95, .05),
  limits = c(10, 100),
  color = "red",
  pal = c("purple", "green3", "orange"),
  show_n = T
)
```

```{r}
distrib_age_2$graph
```

## L'esthétique des chiffres

L'esthétique des chiffres concernent la manière dont l'estimation de l'indicateur est affichée sur le graphique. Ainsi, ces argument n'ont une utilité que si `show_value = TRUE`.

-   `scale` est un argument qui n'est utilisé que dans les graphique exprimant des proportion. Il indique le dénominateur par lequel il faut interpréter le chiffre. Par défaut, `scale = 100` pour interpréter les chiffres mentionnés en pourcentage. Par exemple on peut donner une valeur de `1000` pour interpréter les chiffres en pour mille ou une valeur de `1` pour interpréter les chiffres comme de simple proportions.

-   `digits` indique le nombre de décimales qui doivent être affichées pour les valeurs sur le graphique. Par défaut, `digit = 0`, ce qui conduit à ne pas afficher de décimales.

-   `unit` indique l'unité à indiquer sur le graphique. Pour `distrib_discrete()`, `prop_group()`, `many_prop()` et `many_prop_group(`), par défaut `unit = "%"`. Pour les autres fonction, par défaut `unit = NULL`, c'est-à-dire une absence d'unité indiquée sur le graphique. N'importe quel caractère ou chaîne de caractère peut être utilisée : `"€"`, `"m²"`, etc.

-   `dec` indique le caractère qui doit être utilisé pour marqué la décimale dans les chiffes. Cet argument n'est utile que quand `digits` est supérieur à 0. Par défaut, `dec = ","`, parce que la virgule est le caractère le plus utilisé pour marqué la décimale dans le monde francophone.

Dans l'exemple ci-dessous, on compare la proportion de travailleurs par région, mais en l'exprimant en pour mille et non en pour cent, en adaptant l'unité (`"‰"`), en conservant un chiffre après la virgule et en utilisant le point comme caractère pour la décimale et non la virgule.

```{r}
eusilc_prop <- prop_group(eusilc,
  group = db040,
  prop_exp = pl030 == "1" | pl030 == "2",
  weights = rb050,
  scale = 1000,
  digits = 1,
  unit = "‰",
  dec = ".",
  title = "Proportion of workers by region, in ‰",
  subtitle = "Example with austrian SILC data from 'laeken' package"
)
```

```{r}
eusilc_prop$graph
```

## L'esthétique des lettres

-   `font` indique la police qui est utilisée pour l'ensemble du texte dans le graphique. Actuellement trois polices sont directement incluses dans `fonctionr` : `"Roboto"`, `"Montserrat"` et `"Gotham Narrow"`. Par défaut, `font = "Roboto"`.

-   `wrap_width_y` et `wrap_width_leg` indiquent le nombre de caractères avant d'aller à la ligne, pour respectivement les différent labels de l'axe des ordonnées et les différents labels de la légende. Ces valeurs sont par défaut de 25 caractères. `wrap_width_leg` n'est présent que pour les graphiques ayant une légende : `distrib_group_discrete()` et `many_val_group()` et ses alias. Précisons aussi que le `_y` renvoie à l'axe des y tel qu'il est situé sur le graphique, après la transformation `coord_flip()` qui a lieu dans les fonctions. Ainsi, il s'agit souvent des groupes, de la variable qualitative pour `distrib_discrete()` ou de la liste des variables pour `many_val()` et `many_val_group(`) et leurs alias.

-   `legend_ncol` indique le nombre maximum de colonnes dans la légende. Par défaut, il y a quatre colonnes maximum. Le nombre de lignes dans la légende s'ajuste au nombre maximum de colonnes. `legend_ncol` n'est aussi présent que pour les graphiques ayant une légende : `distrib_group_discrete(`) et `many_val_group()` et ses alias.

## Les labels

Les arguments de label ne sont utilisés que si `show_lab = TRUE`, qui est la valeur par défaut. Si `show_lab = FALSE`, aucun des labels ci-dessous n'est indiqué.

-   `title`, `subtitle`, `xlab`, `ylab`, `legend_lab` et `caption` indiquent les textes à reprendre comme titre du graphique, sous-titre du graphique, titre de l'axe des abscisses, titre de l'axe des ordonnées, titre de la légende et de *caption* (la petite légende en bas à droite du graphique). Précisons que `xlab` et `ylab` font référence aux axes tels qu'ils sont situés sur le graphique, c'est-à-dire après la transformation `coord_flip()` qui a lieu dans les fonctions. `legend_lab` n'est présent que pour les graphiques ayant une légende : `distrib_group_discrete()` et `many_val_group()` ainsi que ses alias. Le *caption* étant souvent déjà utilisé pour indiquer la p valeur du test statistique, l'utilisation de l'argument `caption` ajoute un texte en dessous de la mention de la p valeur du test statistique.

-   Dans le cas où les arguments de label ne sont pas renseignés par l'utilisateur, il n'y a pas de titre, pas de sous-titre et pas de *caption* (autre que la p valeur du test statistique). Par contre, `xlab`, `ylab` et, pour les graphiques avec légende, `legend_lab` indiquent par défaut les noms de la variable ou de l'expression qui est, pour `xlab`, précédé d'une précision sur la nature du calcul : "Moyenne : ...", "Distribution : ..."

-   Il est possible d'indiquer certains label et d'autres non, par exemple si l'on souhaite un titre mais pas de sous-titre. Il suffit de ne compléter que les arguments de labels que l'on souhaite voir écrits sur le graphique. Cependant, pour `xlab`, `ylab` et `legend_lab`, le label par défaut, basé sur le nom des variables, est alors écrit sur le graphique. Si l'on souhaite avoir un label vide, il faut indiquer, respectivement, `xlab = ""`, `ylab =""` ou `legend_lab = ""`. L'utilisation de `xlab = NULL`, `ylab = NULL` ou `legend_lab = NULL` conduira à l'écriture du label par défaut.

-   Comme argument de label, on peut aussi mentionner l'argument `lists_vars_lab` que l'on a déjà expliqué plus haut et qui peut être aussi considéré comme un label.

Dans l'exemple ci-dessous, on a changé la police (Montserrat), on a mis à la ligne les labels de l'ordonnée à partir de 10 caractères et ceux de la légende à partir de 15 caractères et on a limité à trois colonnes pour la légende. On a également introduit manuellement les titres, sous-titres, *caption* et titre de légende, en conservant le label par défaut pour le titre de l'axe des abscisses et en n'ayant pas de titre pour l'axe des ordonnées.

```{r}
eusilc_dist_group_d <- distrib_group_d(eusilc,
  group = db040,
  quali_var = pl030_rec,
  weights = rb050,
  font = "Montserrat",
  wrap_width_y = 10,
  wrap_width_leg = 15,
  legend_ncol = 3,
  title = "Distribution of socio-economic status according to region",
  subtitle = "Example with austrian SILC data from 'laeken' package",
  ylab = "",
  legend_lab = "Status",
  caption = "Source : EU-SILC"
)
```

```{r}
eusilc_dist_group_d$graph
```
