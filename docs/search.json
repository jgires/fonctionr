[{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-11","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.11","title":"Changelog","text":"Date : 2025-02-11 Modification des fonctions qui calculent des totaux, pour afficher en gras le label ainsi que les indicateurs du total. Pour ce faire, le package ggtext est désormais utilisé ; il y donc une dépendance en plus. La fonction distrib_group_discrete() affiche désormais l’unité % sur l’axe des x par défaut, c’est-à-dire lorsque l’unité est définie comme un espace vide (\"\") et que l’argument scale vaut 100.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-10","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.10","title":"Changelog","text":"Date : 2024-12-17 Ajout de palettes spécifiques pour l’Observatoire de la Santé et du Social. Export de la fonction official_pal(). Ajout de la possibilité de désaturer, éclaircir ou foncer les palettes de couleur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-9","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.9","title":"Changelog","text":"Date : 2024-09-15 Ajout de l’argument lang qui permet l’affichage des indications sur les graphiques en trois langues : français, néérlandais, anglais. Ajout d’exemples dans la documentation des fonctions.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-8","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.8","title":"Changelog","text":"Date : 2024-09-04 Ajout du calcul de totaux pour central_group() et prop_group() avec les group.fill activés. Ajout du calcul de totaux pour distrib_group_d() et many_val_group(). Ajout d’un theme “IWEPS” pour les graphiques. L’argument show_lab devient show_labs (avec un s) pour toutes les fonctions. L’argument de couleur fill devient pal pour toutes les fonctions (par cohérence).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-7","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.7","title":"Changelog","text":"Date : 2024-08-04 Modifications substancielles pour central_group() : ajout de la possibilité de faire des sous-groupes (argument group.fill) par groupe. Ajout de la possibilité dans central_group() de ne pas calculer le total.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-6","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.6","title":"Changelog","text":"Date : 2024-07-20 Ajout de la possibilité dans prop_group() de ne pas calculer le total. Dans make_surface(), l’option position = \"bottom\" change également la position de la surface minimale affichée lorsque compare = T (suggestion de Robin). Optimisation du code (très légère augmentation de la vitesse).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-5","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.5","title":"Changelog","text":"Date : 2024-07-07 Modifications substancielles pour prop_group() : ajout de la possibilité de faire des sous-groupes (argument group.fill) par groupe. La fonction make_surface() est terminée : documentation et checks. Modification du code relatif aux palettes de couleurs pour compatibilité avec la nouvelle version de PrettyCols (changement de nom d’un argument). Corrections mineures à divers endroits du code. Le check n’indique désormais plus d’erreur, warning ou note.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-4","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.4","title":"Changelog","text":"Date : 2024-06-29 Ajout de l’export excel pour distrib_continuous() et distrib_group_continuous(). De légères modifications des outputs de ces deux fonctions ont été apportées pour rendre l’export propre. Ajout de trois polices d’écriture dans fonctionr : Helvetica Neue, League Gothic et Amatic.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-3","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.3","title":"Changelog","text":"Date : 2024-06-06 Amélioration de l’affichage des aires de densité dans distrib_group_continuous() lorsque la palette est d’une seule couleur (ne voit plus les limites des quantiles). Ajout des facets dans make_surface(). Mise à la ligne automatique de caption tous les 100 caractères dans toutes les fonctions.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-2","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.2","title":"Changelog","text":"Date : 2024-05-27 Correction d’un bug sur le reorder des valeurs dans distrib_group_continuous().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-1","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.1","title":"Changelog","text":"Date : 2024-05-25 Correction d’un bug dans la plupart des fonctions sur le reorder des valeurs par la médiane des résultats utilisé pour les facets (la fonction est désormais écrite avec des guillemets : FUN = \"median\". Sans cela, il y avait dans certains cas particuliers une erreur).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-0","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.0","title":"Changelog","text":"Date : 2024-04-26 La documentation été complétée pour que le package puisse être utilisé par des personnes tierces. Le package commence à être diffusable. Le bug avec la ligne du geom_line qui est coupée pour distrib_group_continuous() est réglé. bug d’ordonnancement des facteurs réglé dans esth_graph().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-13","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.13","title":"Changelog","text":"Date : 2024-04-20 Création de make_surface() comme fonction indépendante utilisable sur n’importe quel tableau de résultats. Ajout de la possibilité d’afficher le résultat d’un test statistique dans esth_graph().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-12","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.12","title":"Changelog","text":"Date : 2024-04-04 Création de distrib_continuous() et distrib_group_continuous(). Modification du thème theme_fonctionr() pour qu’il soit plus adapté aux nouvelles fonctions.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-11","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.11","title":"Changelog","text":"Date : 2024-03-17 Réécriture du code de toutes les fonctions (sauf esth_graph() et pivot_longer_survey()) : simplification + structuration. Nouvelle logique des na.rm finalisée pour toutes les fonctions (différenciation de na.rm.group et na.rm.facet, introduction de na.rm.var pour distrib_group_d() et distrib_d()). Ajout de checks pour vérifier si la couleur/palette est valide : couleur/palette par défaut si la couleur introduite est invalide. Création d’une fonction interne de création de palettes, permettant de produire les palettes de différentes institutions (pour l’instant Vivalis et Perspective, pour tester).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-10","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.10","title":"Changelog","text":"Date : 2024-03-15 Ajout des argument na.rm.facet dans prop_group() et central_group(). Possibilité de mettre une couleur unie pour many_val(). Création de l’argument na.vars pour many_val() et many_val_group().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-9","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.9","title":"Changelog","text":"Date : 2024-03-05 Ajout des palettes dans many_val().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-8","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.8","title":"Changelog","text":"Date : 2024-03-03 Modification des checks pour voir si les variables indispensables existent bien dans data : simplification du code et message plus clair et utile pour l’utilisateur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-7","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.7","title":"Changelog","text":"Date : 2024-03-01 Ajout de many_val() comme fonction plus générale qui englobe many_prop(). Il y désormais la possibilité de calculer des moyennes et des médianes avec les alias many_mean() et many_median(). Plus de parcimonie pour l’import des packages extérieurs dans le namespace. Changement de nom des arguments : na.var devient na.prop et facet.var devient facet. Début de simplification du code dans un de facilité pour la maintenance et les modifs futures.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-6","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.6","title":"Changelog","text":"Date : 2024-02-22 Ajout d’un check de l’expression dans prop_group(), évitant de produire des résultats incohérents.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-5","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.5","title":"Changelog","text":"Date : 2024-02-19 Implémentation du trycatch() sur le test statistique dans prop_group() : le test statistique est désormais bypassé si les conditions ne sont pas remplies et ne stoppe donc plus prop_group() en cas d’erreur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-4","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.4","title":"Changelog","text":"Date : 2024-02-17 Implémentation de checks pour vérifier que les variables de many_prop_group() soient bien binaires, et pour éviter les variables à une modalité pour quali_var dans distrib_group_discrete(). Correction d’un bug dans esth_graph().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-3","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.3","title":"Changelog","text":"Date : 2024-02-17 Implémentation de l’export excel pour many_prop() et many_val_group().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-2","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.2","title":"Changelog","text":"Date : 2024-02-14 Implémentation du test statistique pour distrib_discrete(). Correction d’un bug découvert à cette occasion, qui empêchait de faire fonctionner distrib_discrete() avec na.rm.group = FALSE.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-1","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.1","title":"Changelog","text":"Date : 2024-02-14 Amélioration des fonctions internes de vérification de la validité des arguments. Celles-ci renvoient désormais un message plus clair pour l’utilisateur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-0","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.0","title":"Changelog","text":"prop_group() : ajout de la possibilité de calculer des proportions en comptant les NA au dénominateur avec l’argument na.var = \"include\". Dans ce cas, l’expression prop_exp peut contenir la fonction .na() pour calculer la proportion de valeurs manquantes. many_val_group() : changement de l’ordre des labels pour que l’ordre des couleurs corresponde à l’ordre sur le graphique. Ajout d’exemples dans la documentation à partir des données SILC inclues dans le package laeken. Correction de bugs mineurs.","code":""},{"path":[]},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"en-général","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"En général","title":"Changelog","text":"L’utilisation de ggtext été implémentée de manière un peu bricolée (comme un code en “surcouche”). Ça fonctionne, mais le code est largement simplifiable (mieux pour la lisibilité). Si l’implémente de manière durable, à revoir. BUG : si une variable de design == le nom d’un objet externe, ça fonctionne => APPROFONDIR ET REGLER CA ? Rendre l’usage non interactif (= la programmation via d’autres fonctions) possible => gros travail, usage de rlang à la place de substitute(). Les couleurs des palettes sont attachées au groupe (many_val_group()) ou à l’indicateur (many_val()), mais pas à la position. De ce fait, lorsque reorder = T, l’ordre des couleurs de la palette n’est pas respecté => changer le comportement ? Bug à l’import de fonctionr du fait de collision entre MetBrewer, MoMAColors, PrettyCols et les fonctions de base ? Je ne comprends pas le message. Documenter tous les arguments des différentes fonctions + vérifier que les explications sont bien correctes (quelques erreurs, par ex. à cause de copier-coller ou de l’ajout de nouveaux argument avec la nouvelle logique des na.rm). Voir ici pour savoir les différentes options possibles dans la doc : https://r-pkgs.org/man.html. Vérifier que les scripts sont bien commentés pour qu’se rappelle ce qu’fait (il manque des notes et quelques explications d’opérations dont je ne rappelle plus le ). Passer le code de chaque fonction en revue pour cleaner / harmoniser / simplifier.=> En cours : il faut encore checker le code du graphique ggplot. => L’ajout de ggtext pour mettre le total en gras compliqué le code Ajouter des exemples pour chaque fonction (pour le site) : manque pivot_longer_survey(), esth_graph(). Vérifier les messages à l’utilisateur : voir quoi garder, corriger, traduire, indiquer les accents (é, è…), ajouter des guillemets pour les arguments dans les checks, mieux écrire les résultats des tests stat (ne sait pas quelle est l’hypothèse nulle).=> Traduire ces messages selon la langue ? Ou tout en anglais ? Mettre des conditions pour réaliser les tests (n min, distribution, variances égales…). Changer la fonction scales::pvalue, qui n’est plus valide (superseded) => Faire une fonction maison en interne ? Ajouter des checks pour les inputs : Pas mettre les mêmes colonnes dans les différents arguments ? (group, var_distrib, facet_var, etc.). Les cluster / strates / weights n’apparaissent pas dans le message de la console avec les replicates => pourquoi ?","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"distrib_c","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"distrib_c","title":"Changelog","text":"Ajouter le test stat univarié avec comme H0 mu dans la population. Apparemment la fonction n’est pas pré-programmée dans survey, il faut la faire soi-même. Ajouter la possibilité de facets.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"distrib_group_c","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"distrib_group_c","title":"Changelog","text":"Le groupe NA est transfomé en level du facteur de groupe. De ce fait, il n’apparaît pas toujours en dernier, notamment lorsque reorder = T. Régler ça (pas cohérent avec les autres fonctions). Faire en sorte que le nom du groupe soit toujours le même dans les sorties de la liste (pour le moment, parfois “group”, parfois le nom de la variable) => implique de changer l’argument = des left_join() dans le script, et donc le nommage des colonnes. Ajouter la possibilité de facets. La colonne central dans l’objet dens produit n’pas de valeur y_ridges. Un peu cleaner le script : il y des étapes inutiles qui pourraient être simplifiées, notamment dans la création des valeurs centrales. Ajouter la possibilité d’un total.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"central_group","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"central_group","title":"Changelog","text":"Bypasser l’erreur du test stat avec tryCatch().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"distrib_group_d","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"distrib_group_d","title":"Changelog","text":"Implémenter un test stat lorsqu’il y des facets => via modélisation loglinéaire, mais j’ai un peu de mal à comprendre les erreurs de survey (erreurs fréquentes). Redondance du code avec total pour le geom_text() ?","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"many_val_group","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"many_val_group","title":"Changelog","text":"Améliorer l’alignement des effectifs avec show_n = T lorsque position == \"stack\" Redondance du code avec total pour le geom_text() ? Fusionner many_val_group() et many_val() ! => + Ajouter la possibilité de group.fill pour les deux","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"make_surface","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"make_surface","title":"Changelog","text":"Ajouter la détection automatique des IC (possible si les colonnes sont du même nom que la valeur, mais terminant par _low et _upp). Ajouter les checks (penser le cas spécifique de pvalue). Lorsque facet, mieux penser l’alignement entre mêmes modalités ? Ajouter les arguments dec et éventuellement scales.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"esth_graph","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"esth_graph","title":"Changelog","text":"Changer le nom. Ajouter le check pour l’argument pvalue. Régler le pb si multiples NA + voir si un pb se pose avec multiples totaux. => BUG : la condition stoppe si multiples NAs avec facettes même si 1 seul NA par facette (condition trop stricte => ça doit passer)","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"en-général-1","dir":"Articles","previous_headings":"To do list > Améliorations","what":"En général","title":"Changelog","text":"Faire une fonction commune pour la création de palettes + checks => redondance inutile entre les fonctions. Réécrire le code du test pour avoir la formule originale => possible avec eval(), voir code de central_group(). Voir si peut créer une fonction commune à toutes les fonctions du package pour créer le ggplot => ce serait une large simplification. Pour l’instant, il y déjà un thème commun theme_fonctionr. Créer une fonction de check des inputs indispensables (car redondance entre les 4 fonctions)=> Pour l’instant c’est fait “en dur” : difficultés de créer une fonction du fait de l’usage du tidyverse : il faut sans doute utiliser les fonctions de rlang. L’import des packages peut être optimisé : il n’est pas utile d’importer des packages extérieurs entiers dans le NAMESPACE, cela augmente le risque de collisions de noms de fonctions => un bon résumé ici : https://mdneuzerling.com/post/-ive-learnt--making--r-package/ et pour plus de détails : https://r-pkgs.org/dependencies--practice.html.=> faire : importer seulement les fonctions utiles (mutate, select, etc.).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"distrib_group_d-1","dir":"Articles","previous_headings":"To do list > Améliorations","what":"distrib_group_d","title":"Changelog","text":"Ajouter les n par “cellule” ? Ajouter les effectifs totaux par groupe ? (dans le nom du groupe ?) Réordonner les levels sur la variable group ? Mais selon quelle valeur (vu qu’il y en plusieurs) ? Celle du premier level de la variable var_distrib ? Possibilité d’indiquer un vecteur avec une palette de couleur ?","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"filtrage","dir":"Articles","previous_headings":"To do list > Notes","what":"Filtrage","title":"Changelog","text":"Il semble qu’il faille filtrer après la déclaration du design. Si ne le fait pas, considère le design sur l’objet filtré (avec moins de PSU / strates qu’il y en en réalité), ce qui sous-estime potentiellement la distribution d’échantillonnage. Voir : https://stats.stackexchange.com/questions/411026/---important--make-survey-design-object-svydesign-function--r--https://notstatschat.rbind.io/2021/07/22/subsets--subpopulations--survey-inference/ => De ce fait, j’ai inclus une option de filtre (filter_exp) dans les fonctions (qui filtre après la déclaration du design), qui évite de filtrer l’objet avant en dégradant le design. => Vérifier que c’est bien OK ! FAIRE : expliquer dans la doc !","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"bivarié-ou-3-variables","dir":"Articles","previous_headings":"To do list > Fonctions à créer","what":"Bivarié ou 3 variables+","title":"Changelog","text":"Superposition de 2 statistiques (bar + lines) avec échelles différentes. Tableau croisé avec résidus ou couleur par proportion (proportions par c, l, ou total)","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"quest-ce-quun-sondage","dir":"Articles","previous_headings":"Préambule","what":"Qu’est-ce qu’un sondage ?","title":"Complex design","text":"Pour produire des informations sur la population, réalise souvent des sondages sur un échantillon, sur lequel réalise une enquête. parle de sondage dès que l’enquête un échantillon, c’est-à-dire un sous-ensemble de la population. Le mot “sondage” est souvent associé aux enquêtes pré-électorales ou d’opinion. Les sondages ne se limitent en réalité pas à ces domaines : les grandes enquêtes européennnes SILC, EFT, EWCS, PISA, ESS… sont par exemple des sondages. enquête un échantillon plutôt que la population pour des raisons pratiques et financières : enquêter toute la population coûte un prix astronomique, et est très compliqué à organiser (nécessite un grand nombre d’enquêteur-trice-s, qui doivent réaliser des nombreux déplacements pénibles, etc.). Par ailleurs, les enquêtes exhaustives (= recensements) ne peuvent être réalisées qu’à des périodes relativement espacées et sont limitées en terme de contenu, pour les raisons pratiques évoquées. Cependant, travailler sur un échantillon implique des procédures complexes dans l’analyse, qui demandent la mobilisation et la compréhension de la théorie de la statistique inférentielle. Sa mise en pratique ne s’improvise pas et demande un apprentissage minimal : c’est l’objet de cette page d’en faire l’introduction.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"quest-ce-quun-bon-échantillon-probabiliste","dir":"Articles","previous_headings":"Préambule","what":"Qu’est-ce qu’un bon échantillon (probabiliste) ?","title":"Complex design","text":"Un échantillon est souvent présenté comme un “modèle réduit” de la population, dont la qualité première serait la “représentativité”, c’est-à-dire la même répartition des catégories que dans la population. Il s’agit de la manière dont été popularisée la condition de validité des enquêtes, qui est pourtant assez trompeuse ! En réalité, les statisticiens n’utilisent pas la notion de “représentativité”, et celle-ci est souvent utilisée à tort et à travers. Par exemple, il est souvent utile de sur-représenter ou sous-représenter certaines catégories de la population dans le sondage, ce qui engendre de facto que l’échantillon n’est plus “représentatif” au sens strict. De plus, la représentativité de l’échantillon est impossible à connaître pour les éléments inconnus, ceux pour lesquels réalise justement l’enquête ! Ce qui est réellement important dans un sondage, c’est : Que la sélection des individus soit aléatoire, et que cette sélection aléatoire s’opère selon un plan défini et connu. Qu’il n’y ait pas de biais dans l’échantillon, possiblement du fait d’un taux de réponse plus bas de certaines catégories par rapport à d’autres. Que la diversité des situations dans l’échantillon soit aussi riche que celle dans la population. En comparaison de ces éléments, la taille de l’échantillon, critère dont parle beaucoup, est peu garant de qualité. Un petit échantillon bien fait est beaucoup plus intéressant qu’un grand échantillon mal construit, dont les résultats seront biaisés et peu utilisables.","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"la-fluctuation-déchantillonnage","dir":"Articles","previous_headings":"Un hasard prédictible","what":"La fluctuation d’échantillonnage","title":"Complex design","text":"L’échantillon doit être le produit d’une sélection aléatoire. En tout cas, c’est la condition pour pouvoir faire de l’inférence statistique, c’est-à-dire induire de manière fiable les caractéristiques de la population sur la base d’un échantillon, qui n’en est qu’une sélection partielle ! Il existe des échantillons non probabilistes, mais inférer les caractéristiques observées à la population est beaucoup moins solide et beaucoup plus risqué. Il faut savoir que la sélection d’un échantillon est soumise au hasard, qui implique une fluctuation d’échantillonnage. Autrement dit, le hasard de l’échantillonnage fait que l’n’obtient jamais exactement le vrai résultat, celui dans la population ! C’est la raison pour laquelle parle toujours d’estimation lorsqu’s’intéresse au résultat dans un échantillon. Par exemple, des groupes qui ont en réalité la même moyenne dans la population pourraient obtenir des estimations de leurs moyennes différentes dans l’échantillon. comprend que le risque est de conclure trop rapidement à une différence entre ces groupes dans la population sur base des résultat dans l’échantillon, alors que cette différence n’existe tout simplement pas ! Il s’agit là de l’élément qui rend l’analyse de données d’enquête plus compliquées que celle de chiffres issus de la population. L’intérêt de la statistique inférentielle est qu’elle permet de réduire largement le risque de se tromper. Elle permet notamment de calculer des intervalles de confiance, et de procéder à des tests statistiques, qui permettent de baliser ce risque.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"la-distribution-déchantillonnage","dir":"Articles","previous_headings":"Un hasard prédictible","what":"La distribution d’échantillonnage","title":"Complex design","text":"Par quel miracle l’inférence est-elle possible, sans même connaître les caractéritiques de la population ? C’est parce que le hasard suit des règles connues que l’peut faire de l’inférence. Si tire des milliers d’échantillons aléatoires à partir de la même population, peut observer comment se distribue la moyenne de ces échantillons. Il s’agit en termes statistiques de la distribution d’échantillonnage. Et la distribution d’échantillonnage de la moyenne suit une loi bien connue : une loi normale. Par ailleurs, la moyenne de cette distribution est égale à la moyenne réelle ! Malgré la fluctuation d’échantillonnage, l’estimation de la moyenne dans l’échantillon tend donc à être égale à la moyenne réelle dans la population. dit que la moyenne d’échantillon est un estimateur non biaisé de la moyenne dans la population. Ce sont précisément ces éléments qui rendent possibles l’inférence et qui permettent de calculer des intervalles de confiance et de procéder aux tests statistiques. Il faut bien avoir à l’esprit que la distribution d’échantillonnage est estimée théoriquement selon les caractéristiques de l’échantillon. Il faut donc toujours bien faire attention à ce que les conditions soient remplies pour estimer correctement la distribution d’échantillonnage (conditions de distribution des variables, du nombre d’effectifs, etc.). La distribution d’échantillonnage ne suit par exemple pas toujours une loi normale. Par ailleurs, même lorsqu’elle est normale, la distribution d’échantillonnage peut avoir une variance (“largeur”) plus ou moins grande, notamment si la variance de la variable dont estime la moyenne est grande. Il est facile de le comprendre en imaginant une situation où la variance est nulle : si tous les individus ont la même caractéristique dans la population, la distribution d’échantillonnage ne présentera qu’une unique valeur et l’estimation de la moyenne de cette caractéristique dans un échantillon sera très précise puisqu’elle sera toujours la même. Toute la difficulté de la statistique inférentielle est de bien estimer quelle serait la distribution d’échantillonnage (forme, caractéristiques) des estimateurs que l’utilise (= les résultats que l’calcule : des moyennes, proportions…), afin de pouvoir faire des tests statistiques ou calculer des intervalles de confiance adaptés aux données.","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"tests-dhypothèse","dir":"Articles","previous_headings":"Outils de la statistique inférentielle","what":"Tests d’hypothèse","title":"Complex design","text":"Imaginons que l’veuille être assurés que la différence des moyennes constatée dans l’échantillon entre 2 groupes est réelle (= se retrouve dans la population). Pour cela, peut faire un test d’hypothèse. Les tests d’hypothèses reposent entièrement sur les caractéristiques de la distribution d’échantillonnage. Le test agit en quelque sorte comme une expérience de pensée qui repose sur cette question : “et s’il n’y avait en réalité pas de différence malgré celle que l’constate ?” le test fournit la probabilité de trouver une différence au moins aussi grande que celle que l’constate alors qu’il n’y en en réalité aucune dans la population (sous l’hypothèse que la différence entre les deux groupes vaut 0, si le dit plus formellement). Le principe est que si cette probabilité est trop faible, alors rejette l’hypothèse que les groupes seraient les mêmes dans la population (et conclut alors à une différence). Cette expérience de pensée est l’astuce qu’trouvée les statisticiens pour prendre une décision en l’absence d’autres éléments. La contrepartie de cette “astuce” est néanmoins forte : l’échantillon doit être aléatoire et non biaisé, et doit connaître le type de sélection aléatoire (= le plan de sondage), pour estimer correctement la distribution d’échantillonnage.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"intervalles-de-confiance","dir":"Articles","previous_headings":"Outils de la statistique inférentielle","what":"Intervalles de confiance","title":"Complex design","text":"Un autre élément fondamental de la statistique inférentielle est l’intervalle de confiance. Celui-ci est souvent présenté comme l’intervalle dans lequel il y X % de chance que se situe la valeur réelle. Cette interprétation n’est pas correcte, car la valeur réelle est une constante : elle est ou n’est pas dans l’intervalle. La probabilité est donc soit de 100%, soit de 0%. L’objectif de l’intervalle de confiance est en réalité de montrer que notre mesure ponctuelle dans l’échantillon est un produit de la fluctuation d’échantillonnage, et qu’elle est assortie d’une incertitude. L’intervalle de confiance rappelle que si avait tiré un autre échantillon aléatoire, la valeur du résultat dans l’échantillon aurait été différente ! Il invite ainsi à considérer le résultat non comme une valeur, mais une plage de valeurs possibles. Techniquement, l’intervalle de confiance est déterminé sur base de l’estimation de la distribution d’échantillonnage et est par construction centré autour de la moyenne d’échantillon. Il indique toutes les valeurs possibles de la moyenne d’échantillon si la vraie moyenne était celle que l’observe, avec la distribution d’échantillonnage que l’estime dans l’échantillon. Mais il faut bien se rendre compte que l’estime tout cela via l’échantillon dont dispose, lui-même soumis à la fluctuation d’échantillonnage : est peut-être dans le cas où la moyenne d’échantillon est fort éloignée de la moyenne réelle ou celui où la distribution d’échantillonnage est mal estimée via l’échantillon ; l’intervalle de confiance peut alors ne pas comprendre la vraie valeur ! L’intervalle de confiance se réfère en réalité à une perspective d’échantillonnage répété : un intervalle de confiance à un niveau de confiance de X % est un intervalle qui capture la valeur réelle dans la population dans X % des échantillons, si répétait l’échantillonnage un grand nombre de fois. Comprendre précisément ce qu’est un intervalle de confiance permet de mieux comprendre les résultats obtenus. Cela permet notamment de se rendre compte que tendanciellement, si tout est fait dans les règles de l’art, 5% des intervalles de confiance dans un rapport ne comprennent PAS la vraie valeur ! C’est peu et à la fois beaucoup… Mais c’est inévitable et c’est l’erreur minimale : si les intervalles de confiances sont mal estimés, cette erreur est certainement supérieure. Si les intervalles de confiance ne sont pas calculés du tout, alors, strictement parlant, la valeur estimée dans l’échantillon est toujours erronée : elle n’est jamais exactement celle de la population. C’est la raison pour laquelle il est plus cohérent de considérer les résultats issus d’un échantillon comme des plages possibles. Notre package fonctionr produit à la fois les intervalles de confiance et un test statistique le plus adapté au calcul demandé, sur base du design réel de l’enquête. Ci-dessous, calcule la proportion à recevoir des revenus du chômage (py090n supérieurs à 0). indique que les strates sont les régions (strata = db040) et les PSU sont les ménages (ids = db030). Les intervalles de confiance et le résultat du test statistique sont affichés sur le graphique. Dans le cas de prop_test(), le test d’hypothèse est un khi2 avec comme hypothèse nulle l’égalité de toutes les proportions.  Les intervalles de confiance se trouvent sous forme de données dans le dataframe tab avec les résultats : Les résultats du test se trouvent dans l’objet test.stat :","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  eusilc_prop <- prop_group(   eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   strata = db040,   ids = db030,   weight = rb050,   reorder = T,   title = \"Proportion of individuals receiving income from unemployment in their household\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop$graph eusilc_prop$tab #> # A tibble: 8 × 11 #>   pl030_rec                   prop prop_low prop_upp n_sample n_true_weighted #>   <fct>                      <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 Fulfilling domestic tasks 0.0485   0.0369   0.0624     1207          31048. #> 2 Permanently disabled      0.209    0.148    0.282       178          21975. #> 3 Retired                   0.0177   0.0134   0.0229     3146          31988. #> 4 Student                   0.0194   0.0106   0.0323      736           7666. #> 5 Unemployed                0.732    0.690    0.770       518         221878. #> 6 Working full time         0.0818   0.0741   0.0899     5162         234629. #> 7 Working part time         0.110    0.0921   0.130      1160          69869. #> 8 Total                     0.0916   0.0863   0.0971    12107         619054. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl> eusilc_prop$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 475.2, ndf = 5.9608, ddf = 35711.0201, p-value < 2.2e-16"},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"ce-qui-influence-la-précision-statistique","dir":"Articles","previous_headings":"","what":"Ce qui influence la précision statistique :","title":"Complex design","text":"Trois éléments influencent la précision statistique (entendue comme p-valeur d’un test et taille d’un intervalle de confiance).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"la-manière-dont-la-ou-les-variables-se-distribuent-dans-la-population","dir":"Articles","previous_headings":"Ce qui influence la précision statistique :","what":"1° La manière dont la (ou les) variable(s) se distribue(nt) dans la population","title":"Complex design","text":"Pour une moyenne, plus la variance de la variable d’intérêt est grande, plus l’intervalle de confiance le sera aussi. Cet effet est important, mais par définition ne peut pas le contrôler. Voici par exemple la moyenne du revenu équivalent par décile de revenu, calculé à partir de SILC en Autriche. Les effectifs de l’échantillon pour chacun des déciles sont semblables. Pourtant, les intervalles de confiance sont différents. remarque notamment que le dernier décile un intervalle plus grand. Cela indique indirectement que la variance de cette variable est plus élevée pour le dixième décile (ce qui est cohérent, les revenu s’étendant jusque très haut pour cette dernière catégorie). Cet élément est notamment la raison pour laquelle stratifie un échantillon, c’est-à-dire qu’découpe la population en strates dans lesquelles va faire des tirages aléatoire séparés (voir plus bas). Dans ce cas, pourrait augmenter le taux de sondage dans le 10ème décile, pour augmenter la précision des indicateurs relatifs au revenu pour ce décile (ce qui se manifesterait pour une diminution de l’intervalle de confiance). Ce point renvoie au fait qu’il est important de construire un échantillon dont maximise la diversité !","code":"# Creation of deciles svyeusilc <- svydesign(id = ~db030, strata = ~db040, weights = ~rb050, data = eusilc) quant <- svyquantile(~eqIncome, svyeusilc, quantiles = seq(.1, .9, .1), ci = F)[[1]] eusilc$rev_eq_dec <- cut(   eusilc$eqIncome,   breaks = c(min(eusilc$eqIncome), quant, max(eusilc$eqIncome)),   include.lowest = T,   dig.lab = 0   )  # Computation with fonctionr eusilc_mean <- mean_group(   eusilc,   group = rev_eq_dec,   quanti_exp = eqIncome / 12,   strata = db040,   ids = db030,   weight = rb050,   show_n = T,   title = \"Mean of equivalised income\",   subtitle = \"Example with austrian SILC data from 'laeken' package\",   ) eusilc_mean$graph"},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"la-taille-de-léchantillon","dir":"Articles","previous_headings":"Ce qui influence la précision statistique :","what":"2° La taille de l’échantillon","title":"Complex design","text":"Un échantillon plus grand sera plus précis. Apportons cependant deux précisions. Premièrement, contrairement à ce qu’imagine parfois intuitivement , le taux de sondage (= la part de la population interrogée) n’pas d’effet. Ainsi, un échantillon de 1000 personnes dans une commune de Belgique sera aussi précis (pour dire des choses sur les habitants de cette commune) qu’un échantillon de 1000 personnes aux États-Unis (pour dire des choses sur les Américains). En théorie, il y un léger effet du taux de sondage quand celui-ci est très important - par exemple si l’constitue un échantillon reprenant 10%, 20% ou 50% de la population de référence. Mais dans la pratique, nous n’avons jamais été confrontés à un échantillon avec un taux de sondage si grand. Peut-être que si les moyens de constituer un échantillon de 50% de la population, les moyen d’interroger tout le monde à l’aide d’un recensement exhaustif. Deuxièmement, la précision dépend de la racine carrée de la taille de l’échantillon. Cela implique un rendement décroissant : doubler la taille de l’échantillon n’augmente la précision que de 40%. Par conséquent, il est illusoire de vouloir atteindre des niveaux de précisions très élevés à partir d’enquêtes. La plupart des enquêtes ont des tailles d’échantillon tournant autour de quelques milliers de répondants, ce qui est suffisant pour pouvoir en tirer des informations utiles, mais sans que ce soit trop coûteux. Par ailleurs, l’estimation de la moyenne tend assez vite vers la vraie valeur, montrant qu’il ne faut pas nécessairement d’énormes échantillons pour pouvoir dire quelque chose. C’est d’autant plus vrai que les intervalles de confiance fonctionnent toujours pour de très petits échantillons, nous protégeant de mauvaises interprétations !","code":""},{"path":"https://jgires.github.io/fonctionr/articles/complex_design.html","id":"le-design-de-lenquête","dir":"Articles","previous_headings":"Ce qui influence la précision statistique :","what":"3° Le design de l’enquête","title":"Complex design","text":"En réalité, les enquêtes procèdent rarement, pour des raisons pratiques, par des sondages aléatoires simples. Deux méthodes sont généralement utilisées (souvent conjointement) : la stratification et le sondage en plusieurs degrés. La stratification permet d’améliorer la précision statistique en tirant plusieurs “sondages” dans des populations différentes. Par exemple (cela se fait fréquemment), pour un échantillon belge peut tirer séparément des ménages interrogés dans les différentes provinces (et Bruxelles). Cela permet d’éviter d’avoir “par hasard” un peu plus de Limbourgeois et un peu moins de Bruxellois dans l’échantillon. Cela permet aussi d’augmenter le taux de sondage dans certaines strates dont la variance des variables d’intérêt est élevée, et donc d’augmenter la précision des estimations, celle-ci étant dépendante de la variance - voir plus haut. La stratification permet ainsi d’augmenter la diversité présente dans l’échantillon, critère important dans la constitution d’échantillon. Le principe fondamental n’est pas de construire un modèle réduit de la population, mais d’aller chercher l’information là où elle est ! L’augmentation de la précision est d’autant plus élevée que les variables de stratification sont liées aux phénomènes étudiés. Les variables utilisées pour la stratification peuvent être diverses : province, type de ménage, revenu, sexe… la seule contrainte est qu’il est nécessaire de disposer des variables de stratification dans la base de données servant au tirage de l’échantillon. Les sondages à plusieurs degrés fonctionnent de la manière suivante. des unités primaires (le terme de PSU, pour primary sampling units est largement utilisé) qu’tire au hasard et, ensuite, au sein de ces PSU sélectionnées, tire des individus qu’interroge. Par exemple, tire au hasard 100 communes en Belgique et ensuite tire au hasard, uniquement dans ces communes-là, des personnes qu’va interroger. Contrairement à la stratification, recourir à des sondages en plusieurs degrés dégrade la précision statistique de l’enquête - parce que les personnes appartenant à un même PSU (ex. habitant une même commune) ont tendance à plus se ressembler que deux personnes prise au hasard dans l’ensemble de l’échantillon. En effet, si tire 100 personnes en Belgique tirés dans 10 communes tirées aléatoirement, aura une plus grande variance d’échantillonnage (car l’échantillon tiré sera différent si l’tire Seraing et Saint-Josse-Ten-Noode que si l’tire Knokke-Heist et Uccle) que si l’tire directement 100 personnes en Belgique. Si cette méthode un effet négatif sur la précision, pourquoi l’utilise-t-? la réponse est simple : c’est parce que cela coûte moins cher. En effet, fait des économies substantielles en recrutant un interviewer pour interroger 10 personnes dans une même commune qu’en lui demandant de courir aux quatre coins de la Belgique pour interroger 10 personnes. Cette réduction des coût permet d’interroger plus de personnes (avec un même budget), ce qui augmente la précision statistique souvent suffisamment pour mener à une balance coût-bénéfices positive. Précisons que c’est moins le cas à Bruxelles car le territoire est bien plus petit, mais en général dans le reste de la Belgique, c’est le cas. Comme de nombreuses enquêtes sont menées au niveau belge, le plan de sondage ne diffère pas entre les régions, à l’exception de l’enquête SILC qui, depuis 2019, n’utilise pas de PSU géographiques à Bruxelles. Les deux types de PSU les plus fréquents sont des PSU géographiques (communes, parties, de communes, quartiers, secteurs statistiques…) et les ménages. Le dernier cas est illustré dans les données de l’enquête SILC où l’l’interroge toutes les personnes de 16 ans et plus d’un même ménage. Cet effet est aussi important car les membre d’un même ménage ont tendance à se ressembler (ils vivent dans un même logement, ont des ressources communes, constate une certaine forme d’homogamie dans les couples…). Dans des domaine de recherches spécifique, peut être confronté à d’autres types de PSU. Par exemple, en sciences de l’éducation, les écoles ou les classes sont des PSU fréquents. Quand s’intéresse au travail, il est possible d’être confronté à des entreprises ou établissement comme PSU. L’effet des PSU sur la variance est d’autant plus fort que les membres d’un même PSU se ressemble d’un point de vue du phénomène étudié. Théoriquement, si la variable étudiée est indépendante de la variable PSU, l’effet du PSU serait nul et il serait moins cher et donc préférable de ne sélectionner qu’un seul PSU. Mais, ce raisonnement est très théorique car nous ne voyons pas d’exemples de phénomène qui serait géographiquement uniforme. Cependant, l’usage des PSU (cela fonctionne assez bien) montre que malgré le fait qu’il y des différences de moyennes entre unités géographique, il y quand même une diversité importante au sein des différentes unités géographiques. Ex. même s’il y des communes avec une population en moyenne plus pauvre et d’autres avec une population en moyenne plus riche, les revenus varient fortement à l’intérieur des communes. Le graphique ci-dessous montre l’effet de la prise en compte ou non des strates et PSU. Il s’agit du taux de pauvreté selon la taille des ménages en Autriche, calculé à partir de SILC. Dans le premier calcul, ne prend pas en compte les strates et PSU. Dans le deuxième calcul, les prend en compte : indique que les strates sont les régions (strata = db040) et les PSU sont les ménages (ids = db030). Les arguments du design sont passé à srvyr, package que nous utilisons en interne (qui les passe lui-même à survey). Tous les arguments de déclaration du design de srvyr sont opérationnels, voir : http://gdfe.co/srvyr/reference/as_survey_design.html. Il faut noter que lorsqu’n’indique ni strate ou PSU, fonctionr considère qu’il s’agit d’un échantillon aléatoire simple ; notre package est donc tout à fait adapté à ce genre de situation. voit que les pourcentages calculés sont exactement les mêmes. Mais les estimations apparaissent moins précises à droite (si regarde les intervalles de confiance) lorsque l’prend en compte les strates et surtout les PSU ; elles sont néanmoins plus justes ! constate donc que la non considération des strates et PSU peut fortement changer les choses. Ici c’est le cas car le taux de pauvreté est calculé au niveau individuel, mais en affectant à chaque individu le revenu équivalent du ménage. , l’enquête SILC est construite avec comme premier niveau un tirage aléatoire de ménages, dans lesquels tous les individus sont ensuite interrogés. Des individus du même ménage ont donc exactement le même revenu ! En ne considérant pas les PSU, fait comme si ces individus faisaient partie de ménages différents (améliorant la précision des estimations), ce qui est faux. Cela montre la nécessite de bien comprendre le design de l’enquête et ses implications !  constate également que les p-valeurs des deux tests sont différentes :","code":"# Poverty threshold eusilc$poverty <- NA eusilc$poverty[eusilc$eqIncome < .6*quant[5]] <- 1 eusilc$poverty[eusilc$eqIncome > .6*quant[5]] <- 0  # Household size eusilc$hsize_rec <- eusilc$hsize eusilc$hsize_rec[eusilc$hsize > 6] <- \"7+\"  eusilc_poverty1 <- prop_group(   eusilc,   group = hsize_rec,   prop_exp = poverty,   weight = rb050,   show_n = T,   title = \"Poverty rates\",   subtitle = \"Simple random sampling\",   )  eusilc_poverty2 <- prop_group(   eusilc,   group = hsize_rec,   prop_exp = poverty,   strata = db040,   ids = db030,   weight = rb050,   show_n = T,   title = \"Poverty rates\",   subtitle = \"With stratas & PSU\",   ) eusilc_poverty1$graph | eusilc_poverty2$graph eusilc_poverty1$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 26.384, ndf = 5.9449, ddf = 88138.3758, p-value < 2.2e-16 eusilc_poverty2$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 6.5896, ndf = 5.072, ddf = 30386.134, p-value = 3.379e-06"},{"path":"https://jgires.github.io/fonctionr/articles/esthetic_functions.html","id":"theme_fonctionr-load_and_active_fonts","dir":"Articles","previous_headings":"","what":"theme_fonctionr() & load_and_active_fonts()","title":"Fonctions esthétiques","text":"theme_fonctionr() est une fonction qui permet d’appliquer le thème de fonctionr à un objet ggplot2. Cette fonction un intérêt si l’veut uniformiser l’esthétique de tous les graphiques pour une publication - ceux qui sont produits avec fonctionr et ceux qui ne le sont pas. L’argument font permet d’indiquer la police d’écriture à utiliser : une police disponible sur votre système ou une de celles directement contenues dans fonctionr. La fonction load_and_active_fonts() est automatiquement exécutée lorsque theme_fonctionr() est appliqué : celle-ci pour de rendre disponibles les polices incluses dans le package. Cette fonction est par ailleurs autonome et permet de charger facilement les polices d’écriture contenues dans fonctionr afin de les rendre disponibles pour n’importe quelle utilisation avec ggplot2. Voir la documentation de la fonction pour connaître les polices incluses dans le package.","code":"# Loading of data data(eusilc, package = \"laeken\")  tab1 <- eusilc |>   as_survey_design(ids = db030, strata = db040, weights = rb050) |>   group_by(pb220a) |>   summarise(     prop = survey_mean(eqIncome > 10000, proportion = T, vartype = \"ci\", na.rm = T)   )  ggtab1 <- tab1 |>   ggplot(aes(x = pb220a, y = prop)) +   geom_col() +   labs(title = \"I'm a graphic\") +   coord_flip()  ggtab2 <- ggtab1 +   theme_fonctionr(font = \"Montserrat\")  ggtab1 | ggtab2"},{"path":"https://jgires.github.io/fonctionr/articles/esthetic_functions.html","id":"esth_graph","dir":"Articles","previous_headings":"","what":"esth_graph()","title":"Fonctions esthétiques","text":"esth_graph() est une fonction qui permet de construire facilement une graphique similaire à ceux produit par les autres fonction mais directement à partir d’une tableau de résultats calculé antérieurement. Cette fonction un intérêt si l’veut appliquer l’esthétique graphique de fonctionr mais à des indicateurs qui ne sont pas calculés par une fonction de fonctionr. esth_graph() permet aisément d’intégrer plusieurs éléments que l’retrouve dans d’autres graphiques produits par fonctionr : valeurs de l’indicateur, bornes d’intervalle de confiance, nombres d’individus dans l’échantillon. La logique d’esth_graph() est différente de celle de theme_fonctionr() : la première fonction produit un graphique à partir d’une table, alors que la seconde applique un thème à un graphique existant. En comparaison des autres fonctions, esth_graph() n’pas d’argument data, mais un argument tab qui doit correspondre à la table avec les indicateurs (il s’appelle tab car il doit être similaire à l’objet tab produit par la plupart des fonctions de fonctionr). Les arguments var et value sont obligatoires et ils indiquent respectivement les colonnes dans tab avec nom de l’indicateur et sa valeur. reorder et show_value. error_low, error_upp et n_var permettent d’indiquer les colonnes dans tab où se trouvent les bornes inférieures et supérieures des barres d’erreurs et le nombre de personnes dans l’échantillon. Par défaut, ces arguments ont une valeur NULL, ce qui conduit à ne pas montrer ces éléments dans le graphique. name_total permet d’indiquer le nom du total dans tab de manière à ce que cette valeur soit mise en évidence (couleur et position) dans le graphique.","code":"tab2 <- eusilc |>   as_survey_design(ids = db030, strata = db040, weights = rb050) |>   group_by(db040) |>   cascade(     mean = survey_mean(eqIncome, vartype = \"ci\"),     n = unweighted(n()),     .fill = \"Total\"   )  esth_graph(tab2,   value = mean,   var = db040,   error_low = mean_low,   error_upp = mean_upp,   n_var = n,   name_total = \"Total\",   reorder = T,   digits = 1,   unit = \"€\" )"},{"path":"https://jgires.github.io/fonctionr/articles/esthetic_functions.html","id":"make_surface","dir":"Articles","previous_headings":"","what":"make_surface()","title":"Fonctions esthétiques","text":"make_surface() permet de créer la représentation de différentes valeurs déja calculées en tant que surfaces - sous la forme de carrés. Il s’agit d’un graphique potentiellement intéressant si l’veut représenter la taille des logements en m², par exemple. La fonction est purement graphique ; elle s’applique sur un dataframe de plusieurs lignes comprenant les modalités/groupes à comparer (argument var) et la valeur pour chacun d’eux (value). La fonction est donc idéalement applicable au dataframe tab produit par central_group(). Notre package fonctionr étant destiné à l’analyse inférentielle, les bornes supérieures et inférieures des intervalles de confiance peuvent être indiquées (error_low et error_upp) ; elles sont alors affichées sur le graphique d’une manière originale, comme carrés en pointillés autour de la valeur dans l’échantillon (show_ci = FALSE pour les désactiver). L’ordonnancement des modalités selon la valeur est possible avec l’argument reorder = TRUE.  La fonction dispose de plusieurs options graphiques. Elle peut afficher des facettes en renseignant la variable dans l’argument facet (le dataframe doit être au format tidy). Le réordonnancement des modalités fonctionne également avec des facettes : dans ce cas, les couleurs des carrés permettent de facilement repérer l’ordre différent par modalité de facette ; peut indiquer dans pal n’importe quelle des palettes de couleur des packages MetBrewer, MoMAColors ou PrettyCols. L’argument compare = TRUE permet d’afficher la surface la plus petite en surimposition de chaque carré (par modalité de facette le cas échéant), pour facilement visualiser les inégalités entre les groupes. L’argument position permet de régler l’alignement des surfaces au centre ou en bas (\"mid\" ou \"bottom\"). L’argument bg (qui signifie background) permet de définir la couleur du fond.","code":"eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  eusilc_mean <- mean_group(   eusilc,   group = pl030_rec,   quanti_exp = py010n + py050n + py090n + py100n + py110n + py120n + py130n + py140n,   filter_exp = !pl030_rec %in% c(\"Student\", \"Fulfilling domestic tasks\") & db040 == \"Tyrol\",   weights = rb050 ) eusilc_mean$tab |>    make_surface(     var = pl030_rec,     value = mean,     error_low = mean_low,     error_upp = mean_upp,     reorder = T,     wrap_width_lab = 15,     unit = \"€\",     title = \"Equivalised income in household by socio-economic status\",     subtitle = \"Example with austrian SILC data from 'laeken' package\"   ) eusilc_mean_region <- mean_group(   eusilc,   group = pl030_rec,   facet = db040,   quanti_exp = py010n + py050n + py090n + py100n + py110n + py120n + py130n + py140n,   filter_exp = !pl030_rec %in% c(\"Student\", \"Fulfilling domestic tasks\") & db040 %in% c(\"Tyrol\", \"Upper Austria\", \"Vienna\", \"Vorarlberg\"),   weights = rb050 ) eusilc_mean_region$tab |>    make_surface(     var = pl030_rec,     facet = db040,     value = mean,     error_low = mean_low,     error_upp = mean_upp,     reorder = T,     show_ci = F,         compare = T,     bg = \"lightgoldenrod1\",     position = \"bottom\",     wrap_width_lab = 15,     unit = \"€\",     pal = \"Lively\",     title = \"Equivalised income in household by socio-economic status\",     subtitle = \"Example with austrian SILC data from 'laeken' package\"   )"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"présentation-des-différentes-fonctions","dir":"Articles","previous_headings":"","what":"Présentation des différentes fonctions","title":"Manuel d'utilisation","text":"La plupart des fonctions de fonctionr permettent, à partir de données issues d’un sondage (complexe mais aussi simple), de produire une liste qui contient la plupart du temps ces trois éléments : Un graphique qui permet la visualisation des indicateurs calculés avec leurs intervalles de confiance. Il s’agit d’un objet ggplot2 qui peut donc être modifié par la suite. Ce graphique est suffisamment finalisé pour être directement utilisable dans une publication ; Un ou plusieurs dataframe qui reprennent les chiffres sur base desquels le graphique est construit. Ceux-ci reprennent généralement le nom de l’indicateur, sa valeur, les bornes d’intervalle de confiance, le nombre de personnes dans l’échantillon dans chaque catégorie, l’estimation du nombre de personnes dans la population dans chaque catégorie et les bornes de l’intervalle de confiance de cette estimation ; Les différents résultats d’un test statistique lorsqu’il y en un qui est pertinent. La plupart des fonctions permettent aussi d’exporter directement ces trois résultats dans un format Excel, dans l’idée de pouvoir facilement communiquer les résultats à une tierce personne, ou à un graphiste dans le cas du travail de mise en page d’un rapport. Dans la suite de cette partie, nous passons les fonctions en revue en indiquant quels sont leurs objectifs et spécificités.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_discrete-distribution-dune-variable-catégorielle","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_discrete() : distribution d’une variable catégorielle","title":"Manuel d'utilisation","text":"distrib_discrete(), avec distrib_d() comme alias, calcule la distribution (en proportions relatives) des différentes modalités d’une variables qualitative. Pour l’exemple, nous utilisons la base de données anonymisée de l’enquête SILC menée en Autriche en 2006, contenue dans le package laeken. Nous chargeons d’abord les données et recodons le statut socio-économiques (pl030) pour lui donner des labels intelligibles, utilisés dans la suite des exemples : Ci-dessous, la fonction distrib_d() décrit la distribution des différents statuts socio-économiques dans le dataframe eusilc, en utilisant la variable de pondération rb0501. Comme le voit, les variables sont indiquées sans mentionner le dataframe (var au lieu de df$var) et sans guillemets, à la manière de la syntaxe du tidyverse. Nous affichons ensuite le graphique contenu dans la liste produite :  La liste contient également un dataframe tab qui reprend les chiffres sur base desquels le graphique est construit. Il comprend les colonnes suivantes : le nom de la modalité (pl030_rec), l’estimation de la proportion de la population appartenant à la modalité (prop), les bornes inférieure (prop_low) et supérieure (prop_upp) de l’intervalle de confiance de cette estimation à un niveau de confiance de 95%, le nombre de personnes dans l’échantillon appartenant à la modalité (n_sample), l’estimation du nombre de personnes dans la population appartenant à la modalité (n_weighted), et les bornes inférieure (n_weighted_low) et supérieure (n_weighted_upp) de l’intervalle de confiance de cette estimation à un niveau de confiance de 95% : La liste contient pour finir le résultat du test statistique dans l’objet test.stat. Dans ce cas, il s’agit du khi2 d’adéquation. Ce test est réalisé avec comme hypothèse nulle la répartition de la population selon le vecteur mentionné dans l’argument probs = c(.2, .15, .1, .1, .25, .1, .1), c’est-à-dire 20% de travailleurs à temps plein, 15% de travailleurs à temps partiel, 10% de chômeurs, 10% d’étudiants, 25% de pensionnés, 10% de personnes en incapacité permanente de travail et 10% de personnes au foyer. Si aucun vecteur n’avait été mentionné dans probs, aucun test n’aurait été effectué. Si le vecteur n’pas une somme de 1, il est ajusté pour avoir une telle somme. Notons que la p-valeur du test est mentionnée sur le graphique.","code":"library(fonctionr) library(patchwork)  # Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\" # Computation, taking sample design into account eusilc_dist_d <- distrib_d(   data = eusilc,   quali_var = pl030_rec,   weights = rb050,   probs = c(.2, .15, .1, .1, .25, .1, .1),   title = \"Distribution of socio-economic status\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_d$graph eusilc_dist_d$tab #> # A tibble: 7 × 8 #>   pl030_rec            prop prop_low prop_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domest… 0.0948   0.0897   0.100      1207    640311.        605407. #> 2 Permanently disab… 0.0155   0.0133   0.0180      178    104930.         89217. #> 3 Retired            0.267    0.259    0.276      3146   1806954.       1750021. #> 4 Student            0.0586   0.0545   0.0629      736    395829.        367611. #> 5 Unemployed         0.0449   0.0411   0.0489      518    303252.        277166. #> 6 Working full time  0.425    0.416    0.434      5162   2869868.       2805298. #> 7 Working part time  0.0941   0.0890   0.0995     1160    636121.        600495. #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_dist_d$test.stat #>  #>  Design-based chi-squared test for given probabilities #>  #> data:  ~pl030_rec #> X-squared = 11462652, scale = 1300.5577, df = 2.9068, p-value < 2.2e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_group_discrete-distribution-dune-variable-catégorielle-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_group_discrete() : distribution d’une variable catégorielle par groupe","title":"Manuel d'utilisation","text":"distrib_group_discrete(), avec distrib_group_d() comme alias, calcule la distribution (en pourcentages) des différentes modalités d’une variables qualitative selon les modalités d’une autre variable qualitative, que l’peut considérer comme des groupes. Par rapport aux autres fonctions, faute de représentation adéquate, les intervalles de confiance ne sont pas indiqués sur le graphique. Le graphique et le tableau contiennent aussi une modalité Total qui reprend l’estimation de la distribution des différentes modalités pour l’ensemble de la population de référence. Le test statistique repris est celui du khi2 de Pearson avec l’ajustement de Rao & Scott. Ce test est réalisé avec comme hypothèse nulle le fait que les deux variables qualitatives (d’intérêt et de groupe) soient statistiquement indépendantes. L’exemple ci-dessous montre la distribution des fréquences des différents statuts socio-économiques (pl030_rec) selon la nationalité (pb220a).","code":"eusilc_dist_group_d <- distrib_group_d(   eusilc,   weights = rb050,   group = pb220a,   quali_var = pl030_rec,   title = \"Distribution of socio-economic status according to nationality\",   subtitle = \"Example with austrian SILC data from 'laeken' package\"   ) eusilc_dist_group_d$graph eusilc_dist_group_d$tab #> # A tibble: 28 × 9 #>    pb220a pl030_rec    prop prop_low prop_upp n_sample n_weighted n_weighted_low #>    <fct>  <fct>       <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #>  1 AT     Fulfillin… 0.0890  0.0838    0.0944     1036    548489.        516023. #>  2 AT     Permanent… 0.0119  0.00986   0.0142      125     73270.         60135. #>  3 AT     Retired    0.285   0.276     0.293      3055   1754654.       1698342. #>  4 AT     Student    0.0602  0.0559    0.0648      693    371222.        343916. #>  5 AT     Unemployed 0.0388  0.0351    0.0427      411    238841.        215672. #>  6 AT     Working f… 0.421   0.412     0.431      4689   2595137.       2532480. #>  7 AT     Working p… 0.0942  0.0888    0.0998     1064    580514.        546451. #>  8 EU     Fulfillin… 0.124   0.0887    0.166        38     20343.         13851. #>  9 EU     Permanent… 0.0498  0.0280    0.0811       15      8186.          4019. #> 10 EU     Retired    0.155   0.115     0.202        45     25429.         17928. #> # ℹ 18 more rows #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_dist_group_d$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 32.8, ndf = 11.957, ddf = 144750.034, p-value < 2.2e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"prop_group-proportion-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"prop_group() : proportion par groupe","title":"Manuel d'utilisation","text":"prop_group() calcule des proportions pour les différentes modalités d’une variable qualitative, que l’peut considérer comme des groupes. Pour indiquer la proportion à calculer, l’utilisateur peut indiquer soit une variable dichotomique, soit directement une expression (sans mentionner le dataframe et sans guillemet, à la manière du tidyverse) à partir de laquelle la proportion est calculée. L’exemple ci-dessous compare la proportion d’individus qui bénéficient d’une allocation de chômage (calculé avec l’expression py090n > 0) selon les différents statuts socio-économiques (pl030_rec).  Le graphique et le tableau contiennent aussi une modalité Total qui reprend l’estimation de la proportion pour l’ensemble de la population de référence. Dans le dataframe tab produit, trouve : l’estimation du nombre de personnes dans la population pour lesquelles le critère de proportion est vérifié (n_true_weighted) accompagné de ses bornes inférieure (n_true_weighted_low) et supérieure (n_true_weighted_upp) de l’intervalle de confiance à un niveau de confiance de 95% ; le nombre total de personnes dans la population pour lesquelles les données sont valides2 (n_tot_weighted) accompagné de ses bornes inférieure (n_tot_weighted_low) et supérieure (n_tot_weighted_upp) de l’intervalle de confiance. Le test statistique réalisé est celui du khi2 de Pearson avec l’ajustement de Rao & Scott. Ce test est réalisé avec comme hypothèse nulle le fait que les deux variables qualitatives (la variable dichotomique proportion vraie-fausse et la variable de groupe) soient statistiquement indépendantes . La fonction prop_group() permet également de différencier le calcul de proportions en différents sous-groupes au sein des groupes. Par exemple, l’opération ci-dessous procède au même calcul de la proportion des individus qui bénéficient d’une allocation de chômage par statut socio-économique, mais en différenciant les hommes et les femmes au sein de chacun de ces statuts. La variable de sous-groupe doit être indiquée dans l’argument group.fill. Pour des raisons de lisibilité, il n’y pas de calcul de test statistique lorsque des sous-groupes sont définis.","code":"eusilc_prop <- prop_group(   eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   weights = rb050,   title = \"% of ind. receiving unemployment benefits in their hh by soc.-eco. stat.\",   subtitle = \"Example with austrian SILC data from 'laeken' package\"   ) eusilc_prop$graph eusilc_prop$tab #> # A tibble: 8 × 11 #>   pl030_rec                   prop prop_low prop_upp n_sample n_true_weighted #>   <fct>                      <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 Fulfilling domestic tasks 0.0485   0.0369   0.0625     1207          31048. #> 2 Permanently disabled      0.209    0.152    0.278       178          21975. #> 3 Retired                   0.0177   0.0134   0.0229     3146          31988. #> 4 Student                   0.0194   0.0106   0.0324      736           7666. #> 5 Unemployed                0.732    0.691    0.770       518         221878. #> 6 Working full time         0.0818   0.0743   0.0897     5162         234629. #> 7 Working part time         0.110    0.0921   0.130      1160          69869. #> 8 Total                     0.0916   0.0864   0.0970    12107         619054. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl> eusilc_prop$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 485.82, ndf = 5.9943, ddf = 72567.0400, p-value < 2.2e-16 eusilc_prop_sex <- prop_group(   eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   group.fill = rb090,   weights = rb050,   title = \"% of ind. receiving unemp. benefits in their hh by soc.-eco. stat. & sex\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" )  eusilc_prop_sex$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"central_group-valeur-centrale-moyennemédiane-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"central_group() : valeur centrale (moyenne/médiane) par groupe","title":"Manuel d'utilisation","text":"central_group() compare la valeur centrale d’une variable quantitative selon les modalités d’une variable qualitative, que l’peut considérer comme des groupes. Deux valeurs centrales sont possibles : la moyenne, quand l’argument type = \"mean\" ou pour l’alias mean_group() ; la médiane, quand l’argument type = \"median\" ou pour l’alias median_group(). L’argument type est prédéfini pour les fonctions “alias”. Il ne doit pas être utilisé par l’utilisateur s’il utilise les fonctions “alias”. Pour indiquer la tendance centrale à calculer, l’utilisateur peut indiquer soit une variable quantitative, soit directement une expression (sans mentionner le dataframe et sans guillemet, à la manière du tidyverse) à partir de laquelle une nouvelle variable quantitative est calculée. L’exemple ci-dessous compare le revenu équivalent mensuel moyen (calculé avec l’expression eqIncome / 12) selon les différents statuts socio-économiques des personnes (pl030_rec). Le graphique et le tableau contiennent une modalité “Total” qui reprend l’estimation de tendance centrale pour l’ensemble de la population de référence. Pour mean_group(), le test statistique effectué est un test de Wald, qui est un test équivalent à une analyse de variance (ANOVA) mais pour des données issues d’un sondage complex3. Ce test est réalisé avec comme hypothèse nulle le fait que les coefficients d’une régression linéaire pour les modalités de la variable qualitative (les groupes) sur la variable quantitative soient nuls. Pour median_group(), le test statistique effectué est celui de Kruskal Wallis.","code":"eusilc_mean <- mean_group(   eusilc,   group = pl030_rec,   quanti_exp = eqIncome / 12,   weights = rb050,   title = \"Mean of monthly equivalised income in household by socio-economic status\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_mean$graph eusilc_mean$tab #> # A tibble: 8 × 8 #>   pl030_rec            mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domesti… 1296.    1255.    1337.     1207    640311.        605407. #> 2 Permanently disabl… 1330.    1206.    1454.      178    104930.         89217. #> 3 Retired             1720.    1688.    1751.     3146   1806954.       1750021. #> 4 Student             1355.    1296.    1414.      736    395829.        367611. #> 5 Unemployed          1456.    1382.    1531.      518    303252.        277166. #> 6 Working full time   1895.    1870.    1920.     5162   2869868.       2805298. #> 7 Working part time   1591.    1545.    1637.     1160    636121.        600495. #> 8 Total               1703.    1686.    1719.    12107   6757264.       6702060. #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_mean$test.stat #> Wald test for pl030_rec #>  in svyglm(formula = fmla, design = data_W) #> F =  137.4607  on  6  and  12100  df: p= < 2.22e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"many_val-calculer-plusieurs-indicateurs","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"many_val() : calculer plusieurs indicateurs","title":"Manuel d'utilisation","text":"many_val() réalise des calculs de proportion ou de tendance centrale simultanément pour plusieurs variables différentes. La fonction permet de calculer trois résultats différents : Le calcul de proportions quand l’argument type = \"prop\" ou pour l’alias many_prop() ; Le calcul de moyennes quand l’argument type = \"mean\" ou pour l’alias many_mean() ; Le calcul de médianes quand l’argument type = \"median\" ou pour l’alias many_median(). L’argument type est prédéfini pour les fonctions “alias”. Il ne doit pas être utilisé par l’utilisateur s’il utilise les fonctions “alias”. Les variables pour lesquelles veut réaliser ce calcul sont indiquées sans guillemets dans un vecteur passé à l’argument list_vars. Contrairement à prop_group() ou central_group(), ne peut pas indiquer d’expression : ce doit être des variables dichotomisées (pour les proportions) ou quantitatives (pour les moyennes ou médianes). Le dataframe tab produit, contenant les indicateurs, est analogue à celui produit par prop_group() pour les proportions et central_group() pour les moyennes/médianes. Pour des raisons de lisibilité, ces fonctions ne calculent aucun test statistique. L’exemple ci-dessous compare les revenus mensuels moyens de l’emploi salarié, d’une activité d’indépendant et d’une allocation de chômage dans la totalité de la population.","code":"# Computation, taking sample design into account eusilc_many_mean <- many_mean(   eusilc,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   unit = \"€\",   title = \"Income from wage, independant worker and unemployement benefits\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_many_mean$graph eusilc_many_mean$tab #> # A tibble: 3 × 8 #>   list_col             mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 salaires            9159.    8945.    9373.    12107   6757264.       6702061. #> 2 revenus d'une acti… 1096.    1002.    1191.    12107   6757264.       6702061. #> 3 allocation de chôm…  426.     393.     459.    12107   6757264.       6702061. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"many_val_group-calculer-plusieurs-indicateurs-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"many_val_group() : calculer plusieurs indicateurs par groupe","title":"Manuel d'utilisation","text":"many_val_group() fonctionne comme many_val(), mais permet d’indiquer une variable qualitative de groupes : les résultats sont alors différenciés selon les différentes modalités de cette variable (= les groupes). Ici aussi, aucun test statistique n’est effectué. Trois calculs sont possibles : La comparaison de proportions quand l’argument type = \"prop\" ou pour l’alias many_prop_group() ; La comparaison de moyennes quand l’argument type = \"mean\" ou pour l’alias many_mean_group() ; La comparaison de médianes quand l’argument type = \"median\" ou pour l’alias many_median_group(). L’argument type est prédéfini pour les fonctions “alias”. Il ne doit pas être utilisé par l’utilisateur s’il utilise les fonctions “alias”. L’exemple ci-dessous compare les revenus mensuels moyens de l’emploi salarié, d’une activité d’indépendant et d’une allocation de chômage des femmes et des hommes.","code":"# Computation, taking sample design into account eusilc_many_mean_group <- many_mean_group(   eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   unit = \"€\",   title = \"Income from wage, independant worker and unemployement benefits by sex\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_many_mean_group$graph eusilc_many_mean_group$tab #> # A tibble: 9 × 9 #>   rb090  list_col      mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>  <fct>        <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 male   salaires    12445.   12098.   12791.     5844   3237897.       3171916. #> 2 female salaires     6136.    5900.    6372.     6263   3519368.       3451545. #> 3 Total  salaires     9159.    8945.    9373.    12107   6757264.       6702061. #> 4 male   revenus d'…  1539.    1368.    1711.     5844   3237897.       3171916. #> 5 female revenus d'…   689.     600.     778.     6263   3519368.       3451545. #> 6 Total  revenus d'…  1096.    1002.    1191.    12107   6757264.       6702061. #> 7 male   allocation…   420.     371.     468.     5844   3237897.       3171916. #> 8 female allocation…   431.     386.     476.     6263   3519368.       3451545. #> 9 Total  allocation…   426.     393.     459.    12107   6757264.       6702061. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_continuous-distribution-dune-variable-continue","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_continuous() : distribution d’une variable continue","title":"Manuel d'utilisation","text":"distrib_continuous(), avec distrib_c() comme alias, calcule la distribution d’une variable continue. L’argument type permet d’indiquer quel type de valeur centrale doit être calculée et indiquée sur le graphique : \"mean\" pour la moyenne et \"median\" pour la médiane. Par défaut, c’est la médiane qui est calculée et affichée. bw indique le degré de “lissage” de la densité. Une valeur plus élevée conduira à davantage lisser la densité et masquera davantage les variations locales. resolution indique la “finesse” du calcul de la densité. Avec une résolution plus faible, il y aura moins de points et verra graphiquement les petites droites reliant les points de densité. Une grande résolution implique cependant des calculs plus longs. L’exemple ci-dessous décrit la distribution de l’âge. L’objet produit est une liste qui comprend quatre éléments. trouve graph et tab, comme dans les autres fonction.  L’objet dens reprend la densité calculée, et l’objet quant reprend les différents quantiles retenus. Dans cette fonction, il n’y , pour le moment, pas de test statistique calculé .","code":"distrib_age <- distrib_c(eusilc, age, type = \"mean\", bw = .7) distrib_age$graph distrib_age$tab #> # A tibble: 1 × 7 #>    mean mean_low mean_upp n_sample n_weighted n_weighted_low n_weighted_upp #>   <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl>          <dbl> #> 1  39.2     38.8     39.6    14827      14827          14827          14827 head(distrib_age$dens) #>           x            y quantFct central #> 1 -7.182919 1.471091e-05        1    <NA> #> 2 -7.075034 1.736570e-05        1    <NA> #> 3 -6.967150 2.043762e-05        1    <NA> #> 4 -6.859265 2.398120e-05        1    <NA> #> 5 -6.751381 2.808797e-05        1    <NA> #> 6 -6.643496 3.289015e-05        1    <NA> distrib_age$quant #>   probs quantile ci.2.5 ci.97.5 #> 1   0.1        9      9      10 #> 2   0.2       17     17      18 #> 3   0.3       25     25      26 #> 4   0.4       33     33      34 #> 5   0.5       39     39      40 #> 6   0.6       45     45      46 #> 7   0.7       52     52      53 #> 8   0.8       60     60      61 #> 9   0.9       70     70      71"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_group_continuous-distribution-dune-variable-continue-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_group_continuous() : distribution d’une variable continue par groupe","title":"Manuel d'utilisation","text":"distrib_group_continuous(), avec distrib_group_c() comme alias, calcule la distribution d’une variables continue selon les modalités d’une variable qualitative, que l’peut considérer comme des groupes. Comme pour distrib_continous(), la fonction produit une liste contenant un graphique (graph), une densité (dens), une table (tab), les quantiles retenus (quant). trouve aussi une boite à moustache (moustache) qui indique les bornes dans lesquelles trouve différentes proportions de la population autour de la médiane (par défaut : 50%, 75% et 95% - les proportions peuvent être paramétrées dans l’argument moustache_probs). Un test statistique est aussi implémenté. Comme pour central_group(), si l’utilisateur choisi de calculer la médiane (le choix par défaut), le test statistique effectué est celui de Kruskal Wallis ; s’il ou elle choisi de calculer la moyenne, test statistique effectué est un test de Wald. Les test effectués sont les mêmes que pour central_group(). L’exemple ci-dessous compare la distribution des revenus équivalents selon le statut socio-économique. Comme pour central_group(), il est possible d’utiliser une expression quantitative au lieu d’une variable. Ici, c’est le revenu équivalent annuel divisé par 12 qui est retenu pour qu’il soit exprimé en montant mensuel.","code":"distrib_income <- distrib_group_c(   eusilc,   pl030_rec,   eqIncome / 12,   type = \"mean\",   limits = c(0, 4100),   bw = .7 ) distrib_income$graph distrib_income$tab #> # A tibble: 7 × 8 #>   pl030_rec            mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <chr>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domesti… 1304.    1264.    1344.     1207       1207          1142. #> 2 Permanently disabl… 1349.    1222.    1476.      178        178           152. #> 3 Retired             1735.    1703.    1767.     3146       3146          3048. #> 4 Student             1371.    1314.    1429.      736        736           684. #> 5 Unemployed          1476.    1401.    1551.      518        518           474. #> 6 Working full time   1888.    1864.    1912.     5162       5162          5048. #> 7 Working part time   1604.    1558.    1650.     1160       1160          1096. #> # ℹ 1 more variable: n_weighted_upp <dbl> head(distrib_income$dens) #>               group         x            y quantFct     y_ridges central #> 1 Working part time -283.5941 6.994595e-08        1 6.614026e-05    <NA> #> 2 Working part time -266.6236 1.182238e-07        1 1.117914e-04    <NA> #> 3 Working part time -249.6530 1.942940e-07        1 1.837227e-04    <NA> #> 4 Working part time -232.6824 3.107223e-07        1 2.938162e-04    <NA> #> 5 Working part time -215.7118 4.839372e-07        1 4.576066e-04    <NA> #> 6 Working part time -198.7413 7.454306e-07        1 7.048725e-04    <NA> head(distrib_income$quant) #>               group probs quantile    ci.2.5   ci.97.5 #> 1 Working part time   0.1  774.170  729.3306  823.6833 #> 2 Working part time   0.2 1016.212  978.0693 1057.4755 #> 3 Working part time   0.3 1186.148 1148.6437 1235.4963 #> 4 Working part time   0.4 1339.096 1292.6704 1375.1817 #> 5 Working part time   0.5 1476.866 1435.1671 1534.5294 #> 6 Working part time   0.6 1642.664 1595.5897 1686.8407 head(distrib_income$moustache) #> # A tibble: 6 × 4 #>   group             moustache_prob xbegin  xend #>   <chr>             <chr>           <dbl> <dbl> #> 1 Working part time 0.95             436. 3496. #> 2 Working part time 0.8              774. 2517. #> 3 Working part time 0.5             1113. 1974. #> 4 Working full time 0.95             734. 4019. #> 5 Working full time 0.8             1008. 2909. #> 6 Working full time 0.5             1315. 2241."},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"tableau-récapitulatif-des-arguments","dir":"Articles","previous_headings":"Arguments des différentes fonctions","what":"Tableau récapitulatif des arguments","title":"Manuel d'utilisation","text":"Comme nous l’avons vu, la majorité des fonctions de fonctionr se ressemblent. La plupart des arguments se retrouvent dans plusieurs fonctions. Le tableau ci-dessous reprend la totalité des arguments en indiquant chaque fois pour quelle(s) fonction(s) il est utilisé. L’ordre repris est celui des fonctions et les couleurs regroupent les arguments selon leur “catégorie”. Cette dernière une visée pédagogique et regroupe ensemble des arguments dont le rôle est similaire. Dans la suite, nous aborderons successivement les arguments liés à la base de donnée utilisée, les arguments indispensables qui doivent obligatoirement être mentionnés, les arguments clés – c’est-à-dire pas obligatoires mais ayant une influence sur les résultats – et les arguments esthétiques – c’est-à-dire qui n’influencent que le graphique.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-liés-à-la-base-de-données-utilisée","dir":"Articles","previous_headings":"Arguments des différentes fonctions","what":"Les arguments liés à la base de données utilisée","title":"Manuel d'utilisation","text":"data est bien entendu un argument fondamental car il indique la base de donnée à utiliser. Comme l’objectif du package est de permettre une analyse des sondages complexes, il peut s’agir d’un objet survey ou d’un objet srvyr, qui contiennent les différentes informations sur le plan de sondage (poids, strates, PSU…). Il est possible que l’objet survey ou srvyr soit un objet avec avec des replicate weights pour utiliser les méthodes de rééchantillonnage pour estimer la variance d’échantillonnage. Il est également possible que data soit un dataframe. Dans ce cas, si aucune autre précision n’est apportée, les fonctions font l’hypothèse d’un sondage aléatoire simple. Ainsi, fonctionr peut être utilisé pour l’analyse des sondages complexes mais aussi des sondages aléatoires simples. Mais fonctionr peut aussi créer un objet de sondage complexe à partir d’un dataframe. Les arguments définissant le design de l’enquête (poids, strates, etc.) doivent alors être indiqués dans l’argument … (dot-dot-dot). Cette manière de procéder fonctionne pour les sondages complexes classiques mais pas pour les sondages complexes intégrant des replicate weights. Si l’ont veut intégrer des replicates weights, il est nécessaire de créer d’abord un objet survey ou srvyr et d’utiliser cet objet dans fonctionr. Les exemples ci-dessous montrent trois manière différentes de prendre en compte un même plan de sondage : en l’indiquant directement dans la fonction de fonctionr, en créant au préalable un objet survey et en créant au préalable un objet srvyr.","code":"library(survey) library(srvyr)  # Un exemple où on indique directement dans la fonction de fonctionr les différents éléments du plan de sondage eusilc_prop_1 <- prop_group(   eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   strata = db040,   ids = db030,   weights = rb050,   title = \"dataframe\" )  # Un exemple où utilise un objet survey eusilc_survey <- svydesign(id = ~db030, strat = ~db040, weight = ~rb050, data = eusilc) eusilc_prop_2 <- prop_group(   eusilc_survey,   group = pl030_rec,   prop_exp = py090n > 0,   title = \"survey object\",   ylab = \"\",   wrap_width_y = 15 )  # Un exemple où utilise un objet srvyr eusilc_srvyr <- as_survey_design(eusilc, ids = db030, strata = db040, weights = rb050) eusilc_prop_3 <- prop_group(   eusilc_srvyr,   group = pl030_rec,   prop_exp = py090n > 0,   title = \"srvyr object\",   ylab = \"\",   wrap_width_y = 15 ) eusilc_prop_1$graph | eusilc_prop_2$graph | eusilc_prop_3$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-indispensables","dir":"Articles","previous_headings":"Arguments des différentes fonctions","what":"Les arguments indispensables","title":"Manuel d'utilisation","text":"Les arguments indispensable sont des arguments qui sont nécessaires au bon fonctionnement des fonctions et qui ne peuvent prendre aucune valeur par défaut. Ces arguments sont principalement de différents types : variables qualitatives, expressions ou listes de variables. Les variables/colonnes sont toujours indiquées sans mentionner le dataframe et sans guillemet, à la manière du tidyverse. group et quali_var sont des variables qualitatives qui indiquent les groupes ou variables qualitative dont veut calculer la distribution. Les variables indiquées pour ces arguments sont transformées en facteurs pour leur usage dans la fonction. prop_exp et quanti_exp sont des expressions qui permettent de calculer les proportions ou tendances centrales. Dans fonctionr, tous les arguments pouvant contenir une expression terminent par _exp. Ces arguments peuvent être des variables (une variable binaire 0-1 pour prop_exp et une variable numérique pour quanti_exp) ou une expression qui produit une variable (binaire pour prop_exp et quantitative pour quanti_exp). Ainsi, il n’est pas nécessaire de préparer à l’avance les variables binaire ou la quantitative, elles peuvent être calculées “à la volée”. Précisons que seuls les variables de la base de données, les opérateurs et les valeurs numérique sont autorisés dans les expressions ; les objets extérieurs (par exemple un seuil contenu dans un vecteur stocké dans l’environnement global) ne sont pas autorisés. list_vars doit être un vecteur reprenant l’ensemble des variables reprises dans les fonctions many_val() et many_val_group() ainsi que leurs alias. Pour many_prop() et many_prop_group(), les variables doivent être binaires (il aurait été trop compliqué d’introduire ici des expressions) et pour many_mean(), many_mean_group(), many_median() et many_median_group(), les variables doivent être numériques. L’argument list_vars_lab permet d’indiquer le label pour les variables à l’aide d’un vecteur. Bien qu’il ne s’agisse pas d’un argument indispensable, nous l’avons placé juste après list_vars pour faciliter l’utilisation des fonctions. Pour list_vars_lab, les guillemets doivent être utilisé pour indiquer les labels des variables. Dans l’exemple ci-dessous, calcule selon le sexe la proportion des répondants qui travaillent et dont le salaire net annuel était inférieur à 12000€. peut ainsi introduire des expressions complexes dans les fonctions.","code":"eusilc_prop_NA_excl <- prop_group(   eusilc,   group = rb090,   prop_exp = (pl030 == \"1\" | pl030 == \"2\") & py010n < 12000,   weights = rb050,   title = \"% of the population that works and whose wage is less than 12000€ net\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop_NA_excl$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-clés-pas-obligatoires-mais-influençant-les-résultats","dir":"Articles","previous_headings":"Arguments des différentes fonctions","what":"Les arguments clés : pas obligatoires mais influençant les résultats","title":"Manuel d'utilisation","text":"Les arguments clés sont des arguments qui ne sont pas indispensables mais qui influencent les résultats. y retrouve plusieurs types d’arguments. group.fill permet d’indiquer une variable de sous-groupes pour différencier les résultats plus finement. Cet argument n’est que disponible dans prop_group() et central_group(). Comme group et quali_var, la variable indiquée pour group.fill est transformée en facteur pour son usage dans la fonction. Dans l’exemple ci-dessous, compare les revenus moyens par statut socio-économique et sexe.  facet permet d’indiquer une variable qualitative pour différencier les résultats selon les différentes modalités de cette variable, dans le graphique ggplot2 et le dataframe de résultat tab. Dans le graphique, elle produit des “facettes”, d’où le nom de l’argument. Comme group, group.fill et quali_var, la variable indiquée pour cet argument est transformée en facteur pour leur usage dans la fonction. Par défaut, les facettes ne sont pas produites. Ci-dessous, calcule la distribution des différents statuts socio-économiques par région (indiquée comme variable de facettes) :  filter_exp est une expression qui permet de filtrer les données de manière à produire les résultats sur une partie de l’échantillon. Comme il s’agit d’une expression, il est possible de mettre en oeuvre des conditions de filtres complexe et multiple, par exemple sélectionner uniquement les personnes âgées de moins de 60 ans, dont le revenu mensuel est inférieur à 3000€ et qui sont célibataires. Si une possibilité de filtrage est inclue dans les fonctions, c’est pour que le filtrage des données soit réalisé après la définition du plan de sondage, afin que le filtrage ne modifie pas celui-ci comme le recommande Thomas Lumley, l’auteur de survey4. Ici aussi, seules les variables de la base de données, les opérateurs et les valeurs numérique sont autorisés dans les expressions. total est un argument qui permet de calculer l’indicateur ou la distribution de la variable pour le total, et pas uniquement pour les groupes. Cela permet de comparer non seulement les groupes entre-eux, mais aussi à l’ensemble de la population. Cet argument n’est disponible que pour prop_group(), central_group(), distrib_group_d() et many_val_group(), et leurs alias. Par défaut le total s’affiche (total = TRUE). Il s’agit d’un argument clé et pas uniquement d’un argument esthétique, car la présence du total dans tab et dans l’export Excell dépend de la valeur prise par cet argument. prop_method est un argument qui permet de choisir le type de correction pour l’estimation des intervalles de confiance d’une proportion, notamment pour éviter d’avoir des bornes inférieures à 0 ou supérieures à 1. Les valeurs peuvent prendre celles mentionnées dans l’argument method de svyciprop() du package survey5. Par défaut, c’est la méthode \"beta\" qui est utilisée. Précisons que cette correction ne s’applique qu’aux intervalles de confiance des proportions et pas aux intervalles de confiance des estimations du nombre de personnes dans la population, qui se retrouvent dans tab. quantiles est un argument qui permet de choisir, sous forme d’un vecteur, les quantiles à calculer et à indiquer sur le graphique dans distrib_continuous() et distrib_group_continuous(). Par défaut, ce sont des déciles qui sont calculés.","code":"eusilc_income_status_sex <- mean_group(   eusilc,   group = pl030_rec,   group.fill = rb090,   quanti_exp = eqIncome/12,   weights = rb050,   title = \"Mean mensual equivalent income according to status and sex\",   subtitle = \"Example with austrian SILC data from 'laeken' package\",   unit = \"€\" )  eusilc_income_status_sex$graph # Computation, taking sample design into account eusilc_dist_d <- distrib_d(   data = eusilc,   quali_var = pl030_rec,   facet = db040,   weights = rb050,   probs = c(.2, .15, .1, .1, .25, .1, .1),   title = \"Distribution of socio-economic status\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_d$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"le-traitement-des-na","dir":"Articles","previous_headings":"Arguments des différentes fonctions > Les arguments clés : pas obligatoires mais influençant les résultats","what":"Le traitement des NA","title":"Manuel d'utilisation","text":"Nous expliquons ici plus précisément le traitement des NA dans les fonctions, car cette question est complexe. Nous avons décidé de laisser des possibilités différentes selon les variables dans lesquelles se trouvent les NA : groupes, variables d’intérêts, expressions, etc. na.rm.group, na.rm.facet, na.rm.var indiquent respectivement la manière dont les éventuels NA dans les variables group, facet et dans quali_var sont traités. Si l’argument est TRUE, les NA sont retirés dans les calculs. Si l’argument est FALSE, une modalité spécifique est créée pour les NA. Dans ce cas, ils prennent toujours la couleur gris clair sur le graphique, pour pointer leur spécificité. Dans le cas où ils sont retirés, ils ne sont pas pris en compte pour calculer le total, le cas échéant. Par défaut, l’argument prend la valeur FALSE, c’est-à-dire que les NA sont supprimés des analyses. Actuellement, na.rm.group influence le traitement des NA, tant pour la variable group que la variable group.fill, si cette dernière est présente. Dans l’exemple ci-dessous, compare la distribution des statuts socio-professionnels entre régions, en y ajoutant une modalité NA pour le statut (il s’agit des personnes de moins de 16 ans qui ne sont pas interrogées), en filtrant les données pour ne conserver que les personnes de plus de 11 ans et introduisant la variable sexe comme facette. Comme nous le verrons, la couleur des NA est toujours grise et ne dépend pas de la palette de couleur, de manière à les identifier spécifiquement.  na.prop indique la manière dont les éventuels NA sont traités dans les variables introduites dans prop_exp. Si l’argument prend la valeur \"rm\", tous les NA présents dans au moins une des variable faisant partie de prop_exp sont exclus avant de procéder aux calculs. De cette manière, la proportion est calculée uniquement sur les observations “valides”. Dans ce cas, pour des raisons évidentes, il n’est pas possible d’utiliser la fonction .na() dans prop_exp (ne peut pas calculer la proportion de personnes dont le statut professionnel est NA si supprimé les NA). Si l’argument prend la valeur \"include\", les NA ne sont pas retirés avant de procéder aux calculs et la proportion est calculée sur l’ensemble des observations, NA compris. Cela peut être utile quand les NA n’indiquent pas une valeur manquante mais une situation spécifique. Par exemple, dans une variable mesurant les points obtenu par des étudiants à un examen, le NA peut indiquer que l’étudiant était absent ; peut donc vouloir calculer la proportion d’étudiants ayant au moins 12/20 en conservant les absents au dénominateur, ce qui est possible avec na.prop = \"include\". Par défaut, na.prop prend la valeur \"rm\". Précisons que pour central_group() et ses alias mean_group() et median_group(), il n’y pas d’argument permettant de choisir le traitement des NA dans quanti_exp. Les observations comprenant au moins un NA dans une variable indiquée dans quanti_exp sont automatiquement exclues des calculs, car il n’y pas d’autre possibilité qui soit pertinente. Les deux graphiques ci-dessous comparent la part de travailleurs selon le sexe en excluant ou en incluant les NA. Les taux du second graphique sont plus faible, car dans celui-ci les personnes n’ayant pas de statut socio-professionnel (c’est-à-dire les enfants) sont comptabilisées dans le dénominateur.  na.vars indique la manière dont les NA doivent être traités dans les différentes variables de many_val() et many_val_group(). Si l’argument prend la valeur \"rm\", les NA sont exclus séparément pour chaque variable. Il en résulte que l’échantillon ne sera pas toujours le même pour chacune des variables calculées, mais conserve un maximum d’observations. Si l’argument prend la valeur \"rm.\", les observations qui comprennent au moins un NA dans n’importe quelle des variables de list_vars sont exclues. Cette manière de procéder exclut plus d’observations mais permet d’avoir un échantillon identique pour toutes les variables. Par défaut, na.vars prend la valeur \"rm\".","code":"eusilc_dist_group_d <- distrib_group_d(   eusilc,   group = db040,   quali_var = pl030_rec,   na.rm.var = FALSE,   facet = rb090,   filter_exp = age > 11,   weights = rb050,   title = \"Distribution of socio-economic status according to region and gender\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_group_d$graph eusilc_prop_NA_excl <- prop_group(   eusilc,   group = rb090,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   na.prop = \"rm\",   title = \"% workers (NA excluded)\" )  eusilc_prop_NA_incl <- prop_group(   eusilc,   group = rb090,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   na.prop = \"include\",   title = \"% workers (NA included)\" ) eusilc_prop_NA_excl$graph | eusilc_prop_NA_incl$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-esthétiques","dir":"Articles","previous_headings":"Arguments des différentes fonctions","what":"Les arguments esthétiques","title":"Manuel d'utilisation","text":"Les arguments esthétiques sont des arguments qui affectent uniquement le graphique produit et pas la table, ni le test statistique. Pour des raisons pédagogiques, nous aborderons successivement les arguments d’esthétique de base, d’esthétique graphique, d’esthétique des chiffres, d’esthétique des lettres et les labels. Aucun de ces arguments n’est obligatoire.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-de-base","dir":"Articles","previous_headings":"Arguments des différentes fonctions > Les arguments esthétiques","what":"L’esthétique de base","title":"Manuel d'utilisation","text":"reorder est un argument qui, en prenant la valeur TRUE, permet de réordonner les catégories selon leur valeur décroissante. Si reorder = FALSE, les catégories ne sont pas réordonnées et c’est l’ordre des levels de la variable qui est utilisé si c’est un facteur, ou l’ordre alphabétique si c’est une variable string. La catégorie NA – quand elle existe (par exemple avec na.rm.group = FALSE) – et la catégorie “Total” ne sont jamais réordonnées et sont toujours positionnées dans le bas du graphique. En cas de facettes, les catégories sont réordonnées sur base de chaque catégorie médiane. Par exemple, si l’utilise des facettes dans prop_group(), la fonction identifie, pour chaque groupe, quelle est la proportion médiane par groupe et puis elle va ordonner les groupes sur bases de ces médianes. Par défaut, reorder prend la valeur de FALSE. reorder n’est pas disponible dans distrib_group_discrete() et many_val_group() ainsi que ses alias (many_prop_group(), many_mean_group() et many_median_group()), car il y plusieurs proportions ou indicateurs et il est difficile de choisir sur laquelle ou lequel réordonner. Dans l’exemple ci-dessous, les revenus moyens des statuts socio-économiques sont réordonnés. Comme il y des facettes, c’est le médian de chaque catégorie (ici statut) qui est utilisée pour construire l’ordre. Par exemple, la catégorie “Permanently disabled” se situe en troisième position, car sa valeur médiane (15199€) se situe entre le médian de la catégorie “Student” (15097€) et de la catégorie “Working part time” (16511€).  position est un argument qui ne se trouve uniquement dans many_val_group() et qui peut prendre les valeurs de \"dodge\" et de \"stack\". Avec \"dodge\", les barres ne sont pas empilées. Avec \"stack\", les barres sont empilées dans chaque groupe. Cette option peut avoir un intérêt quand les variables ont vocation à être additionnées, par exemple avec des revenus selon différentes sources qui peuvent former un revenu total. \"dodge\" est la valeur par défaut. Dans l’exemple ci-dessous, il est pertinent d’empiler les barres indiquant les différents revenus pour visualiser le revenu total. Cependant, dans ce cas, peut plus indiquer les intervalles de confiance sur le graphique.  show_ci, show_n, show_value et show_lab permettent de montrer ou cacher différents éléments sur le graphique avec les valeurs TRUE et FALSE : l’intervalle de confiance (show_ci), le nombre de personnes dans l’échantillon (show_n), l’estimation de l’indicateur (show_value) les titres et sous-titres du graphiques, des axes et de la légende (show_lab). Faute de représentation graphique adéquate, show_ci n’est pas un argument de la fonction distrib_group_discrete(). Pour cette fonction, il est pas possible de représenter les intervalles de confiance sur le graphique, mais ils sont bien calculé dans le dataframe tab. C’est aussi le cas pour many_val_group() et ses alias quand position = \"stack\". Précisons aussi que dans distrib_group_discrete(), seules les valeurs supérieures à 2% sont indiquées sur le graphique pour des raisons de lisibilité. Pour distrib_continuous() l’argument show_n indique les effectifs de l’échantillon pour chaque quantile. total_name indique le nom qui doit être mentionné à côté du résultat du total dans le graphique. Par défaut, quand lang = \"fr\" (voir ci-dessous), il s’agit de “Total”, mais l’utilisateur peut indiquer autre chose de plus spécifique, par exemple “Belgique”, “Population active totale”, etc. Dans l’exemple ci-dessous, ne montre plus les intervalles de confiances, les valeurs de l’indicateur et les labels des titres, par contre montre le nombre de personnes dans l’échantillon et changé le nom du “Total”.  Certains arguments sont spécifiques aux fonctions distrib_continous() et distrib_group_continous() : height indique la hauteur des courbes de densité dans distrib_group_continuous(). Une valeur plus élevée mènent à des courbes plus hautes qui peuvent éventuellement se chevaucher. La valeur par défaut est 0.8. limits indique les limites de l’axe des abscisses du graphique . Par défaut, il n’y pas de limites, ce qui revient à montrer sur le graphique la totalité de la distribution. Cependant, cela peut poser problème pour des distributions asymétriques avec quelques valeurs extrêmes, par exemple pour les variables de revenu. limits permet de zoomer sur la partie du graphique la plus intéressante qui reprend la majorité des observations. Précisons qu’il ne s’agit pas d’un filtre, mais d’un zoom : les déciles, valeurs centrales et moustaches sont toujours calculées sur l’ensemble de la distribution. En cas d’utilisation de zoom important, il est conseillé d’utiliser une résolution plus élevée. noter que lorsque show_n = TRUE pour distrib_continous(), n’indique pas les effectifs pour les quantiles qui ne sont pas complètement représentés quand utilise l’argument limits. D’autres arguments de type show_* sont spécifiques à ces deux fonctions. C’est le cas de show_mid_line, show_ci_lines, show_ci_area, show_quant_lines qui se retrouvent dans les deux fonctions de distribution continue et show_mid_point, show_ci_errorbar et show_moustache qui sont spécifiques à distrib_group_continuous(). show_mid_point et show_mid_line permettent de montrer la valeur centrale, médiane ou moyenne, sous la forme d’un point ou d’une ligne. show_ci_errorbar, show_ci_lines et show_ci_area permettent de montrer l’intervalle de confiance de la valeur centrale sous la forme d’une barre d’erreur, de lignes en pointillé, ou d’une aire colorée. show_quant_lines permet de tracer des lignes pour les valeurs des quantiles sur le graphique. show_moustache permet de montrer la boite à moustache. Par défaut, distrib_continuous() indique la la valeur centrale par une ligne et ses intervalles de confiance par des lignes pointillées et ne trace pas de ligne pour les quantiles. Par défaut, distrib_group_continuous() indique les valeurs centrales par des points et leurs intervalles de confiance par des barres d’erreurs, et ne dessine pas d’autres éléments que la moustache sur le graphique . Dans l’exemple ci-dessous, nous comparons les revenus du travail des travailleurs à temps partiel selon la région, en modifiant de nombreuses options graphiques. bw étant plus faible, la distribution est moins lissée et peut y observer des variations de densités plus locales. resolution étant plus faible, peut déceler les droites qui composent les courbes de densité. limits permet de se concentrer sur la plage de valeur (de -500€ à 3000€) qui contient la grande majorité des observations. height été défini pour que les aires de densité se chevauchent. Pour que ce chevauchement soit esthétique, alpha été réglé à .3 pour des aires transparentes et une bordure été ajoutée avec color = black – ces deux arguments seront détaillés plus bas. indiqué la médiane sous la forme d’une ligne. Ses intervalles de confiance sont indiqués par deux lignes en pointillées et une aire colorées. Les déciles sont indiqués par des lignes verticales grises et masqué la moustache. Notez que le revenu du travail mensuel est directement calculé dans l’expression en additionnant le salaire avec le revenu d’une activité indépendante avant de diviser le tout par 12.","code":"eusilc_mean_reorder <- mean_group(   eusilc,   group = pl030_rec,   quanti_exp = eqIncome,   facet = pb220a,   weights = rb050,   reorder = TRUE,   unit = \"€\",   title = \"Mean of eq. income by status and nationality\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_mean_reorder$graph #Exemple avec Stack  eusilc_many_mean_group_2a <- many_mean_group(   eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   position = \"stack\",   title = \"position = 'stack'\",   legend_ncol = 2 ) #Exemple avec dodge  eusilc_many_mean_group_2b <- many_mean_group(   eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   position = \"dodge\",   title = \"position = 'dodge'\",   legend_ncol = 2 ) eusilc_many_mean_group_2a$graph | eusilc_many_mean_group_2b$graph eusilc_prop <- prop_group(   eusilc,   group = db040,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   show_ci = FALSE,   show_n = TRUE,   show_value = FALSE,   show_lab = FALSE,   total_name = \"Total Austria\" ) eusilc_prop$graph distrib_income_2 <- distrib_group_c(   eusilc,   db040,   (py010n + py050n) / 12,   filter_exp = pl030 == 2,   bw = .7,   resolution = 50,   height = 1.5,   limits = c(-500, 3000),   show_mid_point = F,   show_value = F,   show_mid_line = T,   show_ci_errorbar = F,   show_ci_lines = T,   show_ci_area = T,   show_quant_lines = T,   show_moustache = F,   color = \"black\",   pal = \"purple\",   alpha = .4 ) distrib_income_2$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-graphique","dir":"Articles","previous_headings":"Arguments des différentes fonctions > Les arguments esthétiques","what":"L’esthétique graphique","title":"Manuel d'utilisation","text":"dodge indique l’épaisseur des barres et peut aller de 0 (barre invisible car d’épaisseur nulle) à 1 (barre se touchant car ne laissant aucun espace entre elles). La valeur par défaut est de 0.9. Les couleurs des barres sont indiquées dans l’argument pal. Dans les graphiques monochrome, pal peut prendre la valeur d’une couleur de base de R ou d’un code couleur hexadécimal. C’est le cas pour distrib_discrete(), prop_group() et central_group() quand il n’y pas de group.fill. Dans les graphiques avec une palette de couleurs différentes, pal doit prendre le nom d’une palette des packages MetBrewer, MoMAColors ou PrettyCols (sauf pour la distribution d’une variable quantitative, voir ci-dessous). L’argument direction permet d’inverser le sens de la palette, en remplaçant le 1, par défaut, par -1 pour avoir le sens opposé. C’est le cas de distrib_group_discrete(), many_val_group(), et de prop_group() et central_group() quand il y un group.fill. Dans many_val() et ses alias, peut indiquer dans pal soit une couleur unique, soit une palette des packages MetBrewer, MoMAColors ou PrettyCols. Cela permet de choisir de produire un graphique monochrome, ou un graphique qui différencie chromatiquement chaque variable. Les couleurs des NA et des totaux, quand ils sont présents, ne sont pas modifiables directement par l’utilisateur. La modalité NA est toujours grise (grey). Le total est coloré de deux manière selon qu’il existe un seul total (dans les graphiques monochromes comme prop_group() et central_group() quand il n’y pas d’argument group.fill) ou qu’il existe des totaux différents pour chaque modalité ou variable (dans les graphiques avec palette de couleur, comme distrib_group_d(), many_val_group(), de prop_group() et central_group() quand il y un argument group.fill). Dans le premier cas, la couleur est gris foncé (grey40). Dans le second cas, chaque total une bordure de la couleur de sa modalité ou variable et une couleur de remplissage identique mais plus claire. Par défaut, des couleurs ou des palettes de couleurs différentes ont été choisies pour chacune des fonctions, y compris les alias, pour éviter une confusion entre graphiques différents. Dans l’exemple ci-dessous, compare deux graphiques issus de prop_group() : l’un avec l’argument group.fill, et l’autre sans. calcule la proportion de travailleurs à temps partiel selon la nationalité. Dans le premier graphique, différencie les proportions selon le sexe; pal prend alors le nom d’une palette (ici \"Neon\" de PrettyCols été indiquée). En outre, dans ce premier graphique, les barres sont plus fines (dodge prend une valeur de 0.7). Dans le deuxième, il n’y pas de sous-groupes. pal n’alors besoin que d’une unique couleur, et indiqué la couleur de base de R \"gold\". remarque aussi les deux manières différentes dont les totaux sont représentés.  Dans distrib_continuous() et distrib_group_continuous(), pal peut soit prendre la valeur d’une couleur, soit un vecteur reprenant plusieurs couleurs. Dans le cas d’une seule couleur, les graphiques seront monochrome, dans le cas de plusieurs couleurs, une palette de couleur est créée en passant par les différentes couleurs indiquées pour colorer les différents quantiles, la première couleur indiquant la coloration des premiers et derniers quantiles, et la dernière couleur indiquant la coloration du quantile central6. Précisons que le vecteur de pal doit être un vecteur de couleur de R ou de codes hexadécimaux, mais pas une des palettes des packages MetBrewer, MoMAColors ou PrettyCols utilisées dans pal pour les autres fonctions. Par défaut distrib_continuous() utilise un dégradé de bleu pour les quantiles et distrib_group_continuous() colorie les courbes de densité en gris, de manière à ne pas surcharger le graphique avec les quantiles. Ces deux fonction ont aussi l’argument color qui permet de définir la couleur de la ligne supérieure de la courbe de densité. Par défaut cette ligne n’est pas affichée. distrib_group_continuous() comprend aussi l’argument pal_moustache qui détermine les couleurs de la moustache et alpha qui détermine la transparence de la couleur de la densité. pal_moustache fonctionne comme pal et peut comprendre une couleur unie ou un vecteur de couleur. Mais logiquement, il n’est pas pertinent de représenter une moustache monochrome. Comme pour pour pal, il n’est pas nécessaire de définir chaque teinte de couleur individuellement, puisque la fonction produit une palette de couleur comprenant tous les dégradés nécessaires. alpha peut prendre une valeur allant de 0 (couleur totalement transparente et donc invisible) à 1 (couleur sans transparence). Avoir un certain degré de transparence est particulièrement utile si les différentes courbes se superposent (quand height est élevé). Dans l’exemple ci-dessous, utilise trois couleurs pour construire la palette qui va colorier l’aire de la densité et trace la courbe de densité en rouge.","code":"# Avec sous-groupes eusilc_prop_sub_group <- prop_group(   eusilc,   group =pb220a ,   prop_exp = pl030_rec == \"Working part time\",   group.fill = rb090,   weights = rb050,   title = \"% of ind. working part time by nationality & sex\",   subtitle = \"(with sub-groups)\",   pal = \"Neon\",   dodge = .7 ) # Sans sous-groupes eusilc_prop_no_sub_group <- prop_group(   eusilc,   group = pb220a,   prop_exp = pl030_rec == \"Working part time\",   weights = rb050,   title = \"% of ind. working part time by nationality\",   subtitle = \"(no sub-groups)\",   pal = \"gold\" ) eusilc_prop_sub_group$graph | eusilc_prop_no_sub_group$graph distrib_age_2 <- distrib_c(   eusilc,   age,   type = \"mean\",   quantiles = seq(.05, .95, .05),   limits = c(10, 100),   color = \"red\",   pal = c(\"purple\", \"green3\", \"orange\"),   show_n = T ) distrib_age_2$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-des-chiffres","dir":"Articles","previous_headings":"Arguments des différentes fonctions > Les arguments esthétiques","what":"L’esthétique des chiffres","title":"Manuel d'utilisation","text":"L’esthétique des chiffres concernent la manière dont l’estimation de l’indicateur est affichée sur le graphique. Ainsi, ces arguments n’ont une utilité que si show_value = TRUE. scale est un argument qui n’est utilisé que dans les graphique exprimant des proportion. Il indique le dénominateur par lequel il faut interpréter le chiffre. Par défaut, scale = 100 pour interpréter les chiffres mentionnés en pourcentage. peut donner par exemple une valeur de 1000 pour interpréter les chiffres en pour mille ou une valeur de 1 pour interpréter les chiffres comme de simple proportions. digits indique le nombre de décimales qui doivent être affichées pour les valeurs sur le graphique. Par défaut, digit = 0, ce qui conduit à ne pas afficher de décimales. unit indique l’unité à indiquer sur le graphique. Pour distrib_discrete(), prop_group(), many_prop() et many_prop_group(), par défaut unit = \"%\". Pour les autres fonction, par défaut unit = NULL, c’est-à-dire une absence d’unité indiquée sur le graphique. N’importe quel caractère ou chaîne de caractère peut être utilisée : \"€\", \"m²\", etc. dec indique le caractère qui doit être utilisé pour marquer la décimale dans les chiffes. Cet argument n’est utile que quand digits est supérieur à 0. Par défaut, dec = \",\", parce que la virgule est le caractère le plus utilisé pour marquer la décimale dans le monde francophone. Dans l’exemple ci-dessous, compare la proportion de travailleurs par région, mais en l’exprimant en pour mille et non en pour cent, en adaptant l’unité (\"‰\"), en conservant un chiffre après la virgule et en utilisant le point comme caractère pour la décimale et non la virgule.","code":"eusilc_prop <- prop_group(   eusilc,   group = db040,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   scale = 1000,   digits = 1,   unit = \"‰\",   dec = \".\",   title = \"Proportion of workers by region, in ‰\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-des-lettres","dir":"Articles","previous_headings":"Arguments des différentes fonctions > Les arguments esthétiques","what":"L’esthétique des lettres","title":"Manuel d'utilisation","text":"font indique la police qui est utilisée pour l’ensemble du texte dans le graphique. Plusieurs polices sont directement incluses dans fonctionr afin qu’elles soient utilisables sur tous les systèmes. Pour prendre connaissance des polices disponibles, voir load_and_active_fonts(). wrap_width_y et wrap_width_leg indiquent le nombre de caractères avant d’aller à la ligne, pour respectivement les différent labels de l’axe des ordonnées et les différents labels de la légende. Ces valeurs sont par défaut de 25 caractères. wrap_width_leg n’est présent que pour les graphiques ayant une légende : distrib_group_discrete(), many_val_group() et ses alias et prop_group() et central_group() quand il y un argument group.fill). Précisons aussi que le _y renvoie à l’axe des y tel qu’il est situé sur le graphique, après la transformation coord_flip() qui lieu dans les fonctions. Ainsi, il s’agit souvent des groupes, de la variable qualitative pour distrib_discrete() ou de la liste des variables pour many_val() et many_val_group() et leurs alias. legend_ncol indique le nombre maximum de colonnes dans la légende. Par défaut, il y quatre colonnes maximum. Le nombre de lignes dans la légende s’ajuste au nombre maximum de colonnes. Comme wrap_width_leg , legend_ncol n’est présent que pour les graphiques ayant une légende : distrib_group_discrete() et many_val_group() et ses alias et prop_group() et central_group() quand il y un argument group.fill.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-labels","dir":"Articles","previous_headings":"Arguments des différentes fonctions > Les arguments esthétiques","what":"Les labels","title":"Manuel d'utilisation","text":"Les arguments de label ne sont utilisés que si show_lab = TRUE, qui est la valeur par défaut. Si show_lab = FALSE, aucun des labels ci-dessous n’est indiqué. title, subtitle, xlab, ylab, legend_lab et caption indiquent les textes à reprendre comme titre du graphique, sous-titre du graphique, titre de l’axe des abscisses, titre de l’axe des ordonnées, titre de la légende et de caption (la petite légende en bas à droite du graphique). Précisons que xlab et ylab font référence aux axes tels qu’ils sont situés sur le graphique, c’est-à-dire après la transformation coord_flip() qui lieu dans les fonctions. legend_lab n’est présent que pour les graphiques ayant une légende : distrib_group_discrete() et many_val_group() ainsi que ses alias et prop_group() et central_group() quand il y un argument group.fill. Le caption étant souvent déjà utilisé pour indiquer la p valeur du test statistique, l’argument caption ajoute un texte en dessous de la mention de la p valeur du test statistique. Dans le cas où les arguments de label ne sont pas renseignés par l’utilisateur, il n’y pas de titre, pas de sous-titre et pas de caption (autre que la p valeur du test statistique). Par contre, xlab, ylab et, pour les graphiques avec légende, legend_lab indiquent par défaut les noms de la variable ou de l’expression qui est, pour xlab, précédé d’une précision sur la nature du calcul : “Moyenne : …”, “Distribution : …” Il est possible d’indiquer certains label et d’autres non, par exemple si l’souhaite un titre mais pas de sous-titre. Il suffit de ne compléter que les arguments de labels que l’souhaite voir écrits sur le graphique. Cependant, pour xlab, ylab et legend_lab, le label par défaut, basé sur le nom des variables, est alors écrit sur le graphique. Si l’souhaite avoir un label vide, il faut indiquer, respectivement, xlab = \"\", ylab =\"\" ou legend_lab = \"\". L’utilisation de xlab = NULL, ylab = NULL ou legend_lab = NULL conduira à l’écriture du label par défaut. peut aussi mentionner l’argument lists_vars_lab que l’déjà expliqué plus haut et qui peut être aussi considéré comme un label. L’argument lang permet de déterminer la langue des textes automatiques. Trois valeurs sont possibles : lang = \"fr\" pour le français, lang = \"nl\" pour le néerlandais et lang = \"en\" pour l’anglais. Par défaut, c’est le français qui est utilisé. L’argument theme, qui est un argument d’esthétique graphique plutôt que de label, permet de modifier le thème du graphique. Le thème de base (theme = NULL) est celui qu’retrouve dans tous les graphiques dans ce document, mais le thème IWEPS (theme = \"IWEPS\") permet d’ajouter un axe gradué pour les ordonnées. Dans l’exemple ci-dessous, changé la police (Montserrat), mis à la ligne les labels de l’ordonnée à partir de 10 caractères et ceux de la légende à partir de 15 caractères et limité à trois colonnes pour la légende. également introduit manuellement les titres, sous-titres, caption et titre de légende, en conservant le label par défaut pour le titre de l’axe des abscisses et en n’ayant pas de titre pour l’axe des ordonnées. La langue des textes automatiques est le néerlandais et l’tracé l’axe des ordonnées (theme = \"IWEPS\").","code":"eusilc_dist_group_d <- distrib_group_d(   eusilc,   group = db040,   quali_var = pl030_rec,   weights = rb050,   font = \"Montserrat\",   wrap_width_y = 10,   wrap_width_leg = 15,   legend_ncol = 3,   title = \"Distribution of socio-economic status according to region\",   subtitle = \"Example with austrian SILC data from 'laeken' package\",   ylab = \"\",   legend_lab = \"Status\",   caption = \"Bron : EU-SILC\",   lang = \"nl\",   theme = \"IWEPS\" ) eusilc_dist_group_d$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"programmer-avec-fonctionr","dir":"Articles","previous_headings":"","what":"Programmer avec fonctionr","title":"Manuel d'utilisation","text":"Pour le moment, il n’est pas possible de programmer avec fonctionr ; il n’est par exemple pas possible d’utiliser les fonctions de fonctionr dans une boucle. Nos fonctions ont initialement été écrites dans la visée d’un usage interactif, c’est-à-dire d’un maniement direct pas l’utilisateur et non via une boucle ou d’autres fonctions. Il s’agit d’une limite provoquée par le fait que les variables et expressions s’écrivent en utilisant le data masking, à la manière du tidyverse, impliquant l’utilisation de la non-standard evaluation dans le code des fonctions. Si cette possibilité rend l’utilisation courante plus simple (raison pour laquelle cette écriture été choisie), elle complexifie largement l’écriture du code des fonctions pour nous. terme, nous avons la volonté de modifier ce comportement pour rendre possible l’utilisation non-interactive de nos fonctions. Néanmoins, cela va nous demander un travail certain, n’étant pas programmeurs de profession. Si vous êtes intéressé-e par le concept de fonctionr et connaissez ces questions - notamment la programmation avec rlang -, ou êtes intéressé-es d’y réfléchir, nous accueillerons votre aide avec grand plaisir !","code":""},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"utilisation","dir":"Articles","previous_headings":"","what":"Utilisation","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"Pour utiliser ces palettes dans les différentes fonctions de fonctionr, il suffit d’indiquer celle de votre préférence (les noms des palettes de couleur sont listés plus loin sur cette page) dans l’argument pal :  Les codes hexadécimaux des différentes palettes peuvent aussi être appelés avec la fonction official_pal(), pour les utiliser à l’extérieur de fonctionr. L’argument n permet d’indiquer combien de couleurs sont nécessaires, et la fonction s’occupe de créer automatiquement un dégradé comprenant ce nombre de couleurs. L’argument show_pal = T permet quant à lui d’afficher graphiquement les palettes.  Il est également possible de connaître toutes les palettes disponibles en exécutant la fonction official_pal() avec comme argument list_pal_names = T :","code":"test_palette_OBSS <- distrib_group_d(   eusilc,   group = db040,   quali_var = pl030_rec,   weights = rb050,   font = \"Gotham Narrow\",   pal = \"OBSS\",   title = \"Distribution of socio-economic status according to region\",   ylab = \"\",   legend_lab = \"Status\",   caption = \"Bron : EU-SILC\", ) test_palette_OBSS$graph official_pal(inst = \"OBSS\", n = 8) #> [1] \"#E65362\" \"#EF7C3B\" \"#F8A514\" \"#BEB135\" \"#63AE7A\" \"#2A9FA0\" \"#367689\" #> [8] \"#434E73\" official_pal(inst = \"OBSS\", n = 8, show_pal = T) official_pal(list_pal_names = T) #>  [1] \"Vivalis\"         \"OBSS\"            \"OBSS_alt1\"       \"OBSS_alt2\"       #>  [5] \"OBSS_alt3\"       \"OBSS_Relax\"      \"OBSS_Autumn\"     \"OBSS_Sweet\"      #>  [9] \"OBSS_Spring\"     \"OBSS_Candy\"      \"OBSS_Greens\"     \"OBSS_Sea\"        #> [13] \"OBSS_Sunset\"     \"OBSS_Purples\"    \"OBSS_Blues\"      \"OBSS_Brown\"      #> [17] \"OBSS_div_mid1\"   \"OBSS_div_mid2\"   \"OBSS_div_mid3\"   \"OBSS_div_mid4\"   #> [21] \"OBSS_div_bi1\"    \"OBSS_div_bi2\"    \"OBSS_div_bi3\"    \"OBSS_div_bi4\"    #> [25] \"OBSS_highlight1\" \"OBSS_highlight2\" \"OBSS_highlight3\" \"IBSA\"            #> [29] \"ULB\""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"palettes-qualitatives","dir":"Articles","previous_headings":"Les palettes","what":"Palettes qualitatives","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"","code":"official_pal(\"OBSS\", 8, show_pal = T) official_pal(\"OBSS_alt1\", 8, show_pal = T) official_pal(\"OBSS_alt2\", 7, show_pal = T) official_pal(\"OBSS_alt3\", 8, show_pal = T) official_pal(\"OBSS_Autumn\", 8, show_pal = T) official_pal(\"OBSS_Relax\", 7, show_pal = T) official_pal(\"OBSS_Spring\", 7, show_pal = T) official_pal(\"OBSS_Sweet\", 7, show_pal = T)"},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"palettes-continues","dir":"Articles","previous_headings":"Les palettes","what":"Palettes continues","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"","code":"official_pal(\"OBSS_Greens\", 8, show_pal = T) official_pal(\"OBSS_Sunset\", 8, show_pal = T) official_pal(\"OBSS_Sea\", 8, show_pal = T) official_pal(\"OBSS_Candy\", 8, show_pal = T) official_pal(\"OBSS_Purples\", 8, show_pal = T) official_pal(\"OBSS_Blues\", 8, show_pal = T) official_pal(\"OBSS_Brown\", 8, show_pal = T)"},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"avec-un-point-central","dir":"Articles","previous_headings":"Les palettes > Palettes divergentes","what":"Avec un point central","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"Attention, ces palettes n’affichent le point central que si le nombre de couleur est impair !","code":"official_pal(\"OBSS_div_mid1\", 7, show_pal = T) official_pal(\"OBSS_div_mid2\", 7, show_pal = T) official_pal(\"OBSS_div_mid3\", 7, show_pal = T) official_pal(\"OBSS_div_mid4\", 7, show_pal = T)"},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"sans-point-central","dir":"Articles","previous_headings":"Les palettes > Palettes divergentes","what":"Sans point central","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"Attention, ces palettes ne sont symétriques que si le nombre de couleur est pair !","code":"official_pal(\"OBSS_div_bi1\", 8, show_pal = T) official_pal(\"OBSS_div_bi2\", 8, show_pal = T) official_pal(\"OBSS_div_bi3\", 8, show_pal = T) official_pal(\"OBSS_div_bi4\", 8, show_pal = T)"},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"palettes-avec-emphase","dir":"Articles","previous_headings":"Les palettes","what":"Palettes avec emphase","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"Il s’agit de palettes de couleur mettant en opposition la première, ou les deux premières catégories, avec toutes les autres :","code":"official_pal(\"OBSS_highlight1\", 8, show_pal = T) official_pal(\"OBSS_highlight2\", 8, show_pal = T) official_pal(\"OBSS_highlight3\", 8, show_pal = T)"},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"palettes-dautres-institutions","dir":"Articles","previous_headings":"Les palettes","what":"Palettes d’autres institutions","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"","code":"official_pal(\"IBSA\", 4, show_pal = T) official_pal(\"ULB\", 6, show_pal = T)"},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"altération-des-palettes","dir":"Articles","previous_headings":"","what":"Altération des palettes","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"Il est possible de désaturer, éclaircir ou foncer les palettes, avec les arguments desaturate, lighten et darken, à la fois dans les fonctions de description de données de fonctionr et dans la fonction official_pal().","code":"official_pal(\"OBSS\", 8, show_pal = T) official_pal(\"OBSS\", 8, desaturate = .4, show_pal = T) official_pal(\"OBSS\", 8, lighten = .4, show_pal = T) official_pal(\"OBSS\", 8, darken = .4, show_pal = T)"},{"path":"https://jgires.github.io/fonctionr/articles/Obss_colors.html","id":"exemples-de-graphiques","dir":"Articles","previous_headings":"","what":"Exemples de graphiques","title":"Couleurs pour l'Observatoire de la Santé et du Social","text":"","code":"distrib_income_2 <- distrib_group_c(   eusilc,   db040,   (py010n + py050n) / 12,   filter_exp = pl030 == 2,   limits = c(-500, 3000),   show_mid_point = F,   show_value = F,   show_ci_errorbar = F,   show_moustache = F,   pal = official_pal(inst = \"OBSS_Purples\", n = 2, direction = -1),   alpha = .8,   font = \"Gotham Narrow\",   title = \"Income from wage, part time workers by region\" )  distrib_income_2$graph eusilc_dist_group_d <- distrib_group_d(   eusilc,   group = db040,   quali_var = pl030_rec,   filter_exp = age > 12,   pal = \"OBSS_alt1\",   font = \"Gotham Narrow\",   title = \"Distribution of socio-economic status according to region\"   )  eusilc_dist_group_d$graph eusilc_many_mean_group <- many_mean_group(   eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   pal = \"OBSS_Greens\",   unit = \"€\",   font = \"Gotham Narrow\",   title = \"Income from wage, independant worker and unemployement benefits by sex\"   )  eusilc_many_mean_group$graph eusilc_dist_group_d2 <- distrib_group_d(   eusilc,   weights = rb050,   group = pb220a,   quali_var = pl030_rec,   pal = \"OBSS_Autumn\",   font = \"Gotham Narrow\",   title = \"Distribution of socio-economic status according to nationality\"   )  eusilc_dist_group_d2$graph eusilc_prop_group <- prop_group(   eusilc,   group = rb090,   prop_exp = pl030_rec == \"Working part time\",   group.fill = db040,   show_value = F,   pal = \"OBSS_alt2\",   font = \"Gotham Narrow\",   title = \"Proportion of individuals working part time by region and sex\" )  eusilc_prop_group$graph"},{"path":"https://jgires.github.io/fonctionr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joel Gires. Author, maintainer. Francois Ghesquiere. Author.","code":""},{"path":"https://jgires.github.io/fonctionr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gires J, Ghesquiere F (2025). fonctionr: Package easy manipulation data complex design. R package version 0.3.11, https://github.com/jgires/fonctionr, https://jgires.github.io/fonctionr.","code":"@Manual{,   title = {fonctionr: Package for easy manipulation of data with complex design},   author = {Joel Gires and Francois Ghesquiere},   year = {2025},   note = {R package version 0.3.11, https://github.com/jgires/fonctionr},   url = {https://jgires.github.io/fonctionr}, }"},{"path":"https://jgires.github.io/fonctionr/index.html","id":"fonctionr-","dir":"","previous_headings":"","what":"Package for easy manipulation of data with complex design","title":"Package for easy manipulation of data with complex design","text":"fonctionr est un package R qui pour de produire facilement des statistiques descriptives complètes à partir de données individuelles issues de sondages avec un design complexe. Le package inclut des fonctions permettant de produire les résultats les plus usuels (comparaison de proportions, de moyennes, de médianes, de distributions), en tenant compte du plan d’échantillonnage réel grâce au package survey. fonctionr l’objectif de faciliter l’inférence statistique : outre des résultats descriptifs, le package produit des intervalles de confiance et des tests statistiques qui prennent en compte de design réel de l’enquête. fonctionr produit également des graphiques des résultats à l’aide de ggplot2, dans le de pouvoir intégrer directement et rapidement les résultats produits dans un rapport/une publication. Vous trouverez sur cette page une rapide introduction à fonctionr ; pour plus de détails, voir le manuel. Documentation : Pour comprendre plus en profondeur notre package et ses différentes possibilités, nous renvoyons l’utilisateur au Manuel d’utilisation qui constitue un guide décrivant dans le détail les différentes fonctions de fonctionr. Note de développement : Cette version de fonctionr est encore une version de développement. Elle est néanmoins pleinement fonctionnelle et passé l’épreuve de nombreux tests, au cours desquels des solutions ont été apportées aux problèmes posés par des structures de données diverses. La mise à disposition publique du package nous permettra de bénéficier de retours plus larges concernant des problèmes que nous n’aurions pas anticipés. Néanmoins, dans un de continuité d’utilisation, la logique d’utilisation de fonctionr restera globalement la même. Seuls quelques éléments seront encore possiblement modifiés ou harmonisés dans un avenir proche (nom d’arguments, arguments supplémentaires…), sans que cela impacte l’utilisation du programme.","code":""},{"path":"https://jgires.github.io/fonctionr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Package for easy manipulation of data with complex design","text":"Vous pouvez installer le package fonctionr depuis GitHub. Pour cela, il vous faut d’abord installer et charger le package devtools :","code":"# Installer devtools si celui-ci n'est pas installé et charger le package install.packages(\"devtools\") library(devtools)  # Installer fonctionr devtools::install_github(\"jgires/fonctionr\")"},{"path":"https://jgires.github.io/fonctionr/index.html","id":"utilisation","dir":"","previous_headings":"","what":"Utilisation","title":"Package for easy manipulation of data with complex design","text":"Avant toute utilisation, il faut bien entendu charger le package : L’utilisation de fonctionr pour d’être simple. Pour nos exemples, nous utilisons les données de l’enquête SILC pour l’Autriche contenues dans le package laeken. Nous recodons d’abord la variable de statut économique pour la lisibilité des résultats : fonctionr comprend plusieurs fonctions pour réaliser facilement des opérations descriptives courantes. mean_group() permet par exemple de calculer des moyennes de revenu par groupe. Les groupes, ici de statut économique, sont indiqués dans l’argument group. C’est la moyenne du revenu mensuel qui est calculée, car peut indiquer soit une variable quantitative, soit une expression pour calculer celle-ci, directement dans l’argument quanti_exp (dans ce cas la variable eqIncome est divisée par 12 à la volée). Le design de l’enquête SILC est pris en considération, puisque l’peut indiquer les clusters (ids), les strates (strata) et les poids (weight) dans la fonction. Les intervalles de confiance et un test de différence des moyennes sont calculés en conséquence. La fonction produit une liste encapsulant plusieurs résultats dans des objets différents. L’objet tab comprend un data.frame avec les résultats au format tidy : L’objet test.stat comprend les résultats d’un test d’hypothèse prenant en compte le design de l’enquête. Le test pratiqué est dépendant de la statistique calculée. Dans le cas de mean_group(), il s’agit d’une ANOVA avec comme hypothèse nulle l’égalité entre les moyennes de tous les groupes : L’objet graph comprend un graphique ggplot présentant les résultats et prêt à être inséré dans une publication :  fonctionr comprend plusieurs autres fonctions pour réaliser des opérations similaires, par exemple pour calculer des proportions par groupe avec la fonction prop_group(). peut à nouveau indiquer directement une expression à partir de laquelle calculer les proportions dans l’argument prop_exp : dans ce cas la proportion à recevoir des revenus du chômage (py090n supérieurs à 0). Le résultat contient à nouveau un tableau, le résultat d’un test d’hypothèse et un graphique ggplot. Dans le cas de prop_test(), le test d’hypothèse est un khi2 avec comme hypothèse nulle l’égalité de toutes les proportions.","code":"library(fonctionr) # Loading of data data(eusilc, package = \"laeken\")  # Creation of categories of economic status eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\" eusilc_mean <- mean_group(   eusilc,   group = pl030_rec,   quanti_exp = eqIncome / 12,   strata = db040,   ids = db030,   weight = rb050,   reorder = T,   title = \"Mean of equivalised income in household by status of individuals\",   subtitle = \"Example with austrian SILC data from 'laeken' package\",   ) eusilc_mean$tab #> # A tibble: 8 × 8 #>   pl030_rec            mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domesti… 1296.    1253.    1338.     1207    640311.        605978. #> 2 Permanently disabl… 1330.    1202.    1458.      178    104930.         85796. #> 3 Retired             1720.    1681.    1758.     3146   1806954.       1746273. #> 4 Student             1355.    1291.    1419.      736    395829.        365532. #> 5 Unemployed          1456.    1380.    1532.      518    303252.        276953. #> 6 Working full time   1895.    1864.    1926.     5162   2869868.       2797833. #> 7 Working part time   1591.    1542.    1639.     1160    636121.        600709. #> 8 Total               1703.    1679.    1726.    12107   6757264.       6683738. #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_mean$test.stat #> Wald test for pl030_rec #>  in svyglm(formula = fmla, design = data_W) #> F =  141.5453  on  6  and  5985  df: p= < 2.22e-16 eusilc_mean$graph #> Warning: Removed 7 rows containing missing values or values outside the scale range #> (`geom_text()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_text()`). eusilc_prop <- prop_group(   eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   strata = db040,   ids = db030,   weight = rb050,   reorder = T,   title = \"Proportion of individuals receiving income from unemployment in their household\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop$tab #> # A tibble: 8 × 11 #>   pl030_rec                   prop prop_low prop_upp n_sample n_true_weighted #>   <fct>                      <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 Fulfilling domestic tasks 0.0485   0.0369   0.0624     1207          31048. #> 2 Permanently disabled      0.209    0.148    0.282       178          21975. #> 3 Retired                   0.0177   0.0134   0.0229     3146          31988. #> 4 Student                   0.0194   0.0106   0.0323      736           7666. #> 5 Unemployed                0.732    0.690    0.770       518         221878. #> 6 Working full time         0.0818   0.0741   0.0899     5162         234629. #> 7 Working part time         0.110    0.0921   0.130      1160          69869. #> 8 Total                     0.0916   0.0863   0.0971    12107         619054. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl> eusilc_prop$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 475.2, ndf = 5.9608, ddf = 35711.0201, p-value < 2.2e-16 eusilc_prop$graph #> Warning: Removed 7 rows containing missing values or values outside the scale range #> (`geom_text()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_text()`)."},{"path":"https://jgires.github.io/fonctionr/index.html","id":"auteurs","dir":"","previous_headings":"","what":"Auteurs","title":"Package for easy manipulation of data with complex design","text":"Joël Girès est sociologue et travaille à l’Observatoire de la Santé et du Social de la Région de Bruxelles-Capitale. François Ghesquière est sociologue et travaille à l’Institut wallon de l’évaluation, de la prospective et de la statistique. Nous sommes ouverts à toute remarque afin d’améliorer notre package.","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":null,"dir":"Reference","previous_headings":"","what":"central_group — central_group","title":"central_group — central_group","text":"Function compare means medians different groups complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"central_group — central_group","text":"","code":"central_group(   data,   group,   quanti_exp,   type,   group.fill = NULL,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   total = TRUE,   reorder = F,   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   total_name = NULL,   digits = 0,   unit = \"\",   dec = \",\",   pal = NULL,   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   wrap_width_leg = 25,   legend_ncol = 4,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   legend_lab = NULL,   caption = NULL,   lang = \"fr\",   theme = NULL,   export_path = NULL )  median_group(..., type = \"median\")  mean_group(..., type = \"mean\")"},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"central_group — central_group","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. quanti_exp expression define variable mean/median computed. type \"mean\" compute mean group ; \"median\" compute median group. group.fill variable defining second variable groups compared. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable NA facet variable, applicable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included quanti_exp affected argument. observation NA variables included quanti_exp always excluded. Default TRUE. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. total TRUE want calculate total, FALSE . default TRUE reorder TRUE want reorder groups according mean/median. NA value, case na.rm.group = FALSE, included reorder. show_ci TRUE want show error bars graphic. FALSE want show error bars. Default TRUE. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show mean/median group graphic. FALSE want show mean/median. Default TRUE. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. total_name Name total bar graphic. Default Total. digits Numbers digits showed value labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal group.fill empty, pal must vector containing single color define color bars. variable specified group.fill, pal color palette used graph differentiate different modalities. Palettes MetBrewer, MoMAColors PrettyCols packages available. NA bar, na.rm.group = FALSE, total bar always gray. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. dodge Width bar, 0 1.Default 0.9. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line labels groups. Default 25. wrap_width_leg Number characters going line labels categories group.fill. Default 25. legend_ncol Number colomns legend. Default 4. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Moyenne : \" + quanti_exp \"Medianne : \" + quanti_exp. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". legend_lab Legend (fill) label graphic. legend_lab = NULL, legend label graphic group.fill. show legend label, use legend_lab = \"\". caption Caption graphic. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"central_group — central_group","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"central_group — central_group","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Creation of age categories eusilc$age_cat <- cut(eusilc$age, breaks = 6, include.lowest = TRUE)  # Calculation of income means by age category with fonctionr, taking sample design into account eusilc_mean <- mean_group(   eusilc,   group = age_cat,   quanti_exp = eqIncome / 12,   strata = db040,   ids = db030,   weight = rb050,   title = \"Mean of equivalised income in household by age of individuals\",   subtitle = \"Example with austrian SILC data from 'laeken' package\"   ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 #> Variable(s) detectee(s) dans quanti_exp : eqIncome #> 0 lignes supprimees avec valeur(s) manquante(s) pour le(s) variable(s) de quanti_exp  # Results in graph form eusilc_mean$graph #> Warning: Removed 6 rows containing missing values or values outside the scale range #> (`geom_text()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_text()`).   # Results in table format eusilc_mean$tab #> # A tibble: 7 × 8 #>   age_cat      mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>       <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 [-1.1,15.3] 1444.    1409.    1479.     2720   1424958.       1358818. #> 2 (15.3,31.7] 1607.    1571.    1643.     2944   1612502.       1549489. #> 3 (31.7,48]   1703.    1669.    1737.     4025   2230581.       2163723. #> 4 (48,64.3]   1889.    1843.    1935.     2817   1578046.       1517273. #> 5 (64.3,80.7] 1611.    1561.    1662.     1847   1053098.       1001605. #> 6 (80.7,97.1] 1545.    1467.    1622.      474    283037.        256754. #> 7 Total       1658.    1635.    1681.    14827   8182222        8079226. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_continuous — distrib_continuous","title":"distrib_continuous — distrib_continuous","text":"Function describe continuous variable complex survey data","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_continuous — distrib_continuous","text":"","code":"distrib_continuous(   data,   quanti_exp,   type = \"median\",   facet = NULL,   filter_exp = NULL,   ...,   na.rm.facet = TRUE,   quantiles = seq(0.1, 0.9, 0.1),   bw = 1,   resolution = 1024,   limits = NULL,   show_mid_line = TRUE,   show_ci_lines = TRUE,   show_ci_area = FALSE,   show_quant_lines = FALSE,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   digits = 0,   unit = \"\",   dec = \",\",   pal = c(\"#00708C\", \"mediumturquoise\"),   color = NA,   font = \"Roboto\",   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   lang = \"fr\",   theme = NULL,   export_path = NULL )  distrib_c(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_continuous — distrib_continuous","text":"data dataframe object survey package object srvyr package. quanti_exp expression define variable described. type \"mean\" compute mean central value ; \"median\" compute median central value. facet supprimer? filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.facet supprimer? quantiles quantiles computed distribution. Default deciles. bw smoothing bandwidth used. kernels scaled standard deviation smoothing kernel. Default 1. resolution Resolution density curve. Default 1024. limits Limits x axe graphic. apply computation. Default NULL show entire distribution graphic. show_mid_line TRUE want show mean median (depending type) line graphic. FALSE want show . Default TRUE. show_ci_lines TRUE want show confidence interval mean median (depending type) lines graphic. FALSE want show lines. Default TRUE. show_ci_area TRUE want show confidence interval mean median (depending type) coloured area graphic. FALSE want show area. Default FALSE. show_quant_lines TRUE want show quantiles lines graphic. FALSE want show lines. Default FALSE. show_n TRUE want show graphic number individuals sample quantile FALSE want show numbers. Default FALSE. show_value TRUE want show mean/median (depending type) graphic. FALSE want show mean/median. Default TRUE. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. digits Numbers digits showed value labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal color density area. maybe one color vector several colors. color color density line. font Font used graphic. See load_and_active_fonts() available fonts. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Moyenne : \" + quanti_exp \"Medianne : \" + quanti_exp. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". caption Caption graphic. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_continuous — distrib_continuous","text":"list contains table (tab), graphic (garph) density table (dens) quantile table (quant)","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"distrib_continuous — distrib_continuous","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Computation, taking sample design into account eusilc_dist_c <- distrib_c(   eusilc,   quanti_exp = eqIncome,   strata = db040,   ids = db030,   weight = rb050,   limits = c(0, 50000),   title = \"Distribution of eq. income\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 #> Variable(s) detectee(s) dans quanti_exp : eqIncome #> 0 lignes supprimees avec valeur(s) manquante(s) pour le(s) variable(s) de quanti_exp  # Results in graph form eusilc_dist_c$graph #> Warning: Removed 1042 rows containing missing values or values outside the scale range #> (`geom_line()`).   # Results in table format eusilc_dist_c$tab #> # A tibble: 1 × 7 #>   median median_low median_upp n_sample n_weighted n_weighted_low n_weighted_upp #>    <dbl>      <dbl>      <dbl>    <int>      <dbl>          <dbl>          <dbl> #> 1 18099.     17842.     18431.    14827    8182222       8079226.       8285218."},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_discrete — distrib_discrete","title":"distrib_discrete — distrib_discrete","text":"Function describe distribution discrete variable complex survey data. produces table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_discrete — distrib_discrete","text":"","code":"distrib_discrete(   data,   quali_var,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.facet = TRUE,   na.rm.var = TRUE,   probs = NULL,   prop_method = \"beta\",   reorder = FALSE,   show_ci = TRUE,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   scale = 100,   digits = 0,   unit = \"%\",   dec = \",\",   pal = \"sienna2\",   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   lang = \"fr\",   caption = NULL,   theme = NULL,   export_path = NULL )  distrib_d(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_discrete — distrib_discrete","text":"data dataframe object survey package object srvyr package. quali_var discrete variable described. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.facet TRUE want remove observations NA facet variable. FALSE want create facet NA value facet variable. Default TRUE. na.rm.var TRUE want remove observations NA discrete variable. FALSE want create modality NA value discrete variable. Default TRUE. probs Vector probabilities H0 statistical test, correct order (rescaled sum 1). probs = NULL, statistical test performed. Default NULL. prop_method Type proportion method use compute confidence intervals. See svyciprop survey package details. Default beta method. reorder TRUE want reorder categories according proportion. NA value, case na.rm.group = FALSE, included reorder. Default FALSE. show_ci TRUE want show error bars graphic. FALSE want show error bars. Default TRUE. show_n TRUE want show graphic number individuals sample modality quali_var. FALSE want show number. Default FALSE. show_value TRUE want show proportion category graphic. FALSE want show proportion. Default TRUE. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\". pal Colour bars. NA bar, case na.rm.group = FALSE, total bar always grey. dodge Width bar, 0 1. Default 0.9. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line labels categories. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Distribution (total : 100 percent)\". show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), Y variable data. ylab = NULL, Y label graphic quali_var. show Y label, use ylab = \"\". lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". caption Caption graphic. theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test (probs NULL).","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_discrete — distrib_discrete","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"distrib_discrete — distrib_discrete","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_dist_group_d <- distrib_d( eusilc, pl030_rec, strata = db040, ids = db030, weight = rb050, title = \"Distribution of socio-economic status\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050  # Results in graph form eusilc_dist_group_d$graph   # Results in table format eusilc_dist_group_d$tab #> # A tibble: 7 × 8 #>   pl030_rec            prop prop_low prop_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domest… 0.0948   0.0899   0.0998     1207    640311.        605978. #> 2 Permanently disab… 0.0155   0.0129   0.0186      178    104930.         85796. #> 3 Retired            0.267    0.258    0.277      3146   1806954.       1746273. #> 4 Student            0.0586   0.0544   0.0630      736    395829.        365532. #> 5 Unemployed         0.0449   0.0411   0.0489      518    303252.        276953. #> 6 Working full time  0.425    0.416    0.434      5162   2869868.       2797833. #> 7 Working part time  0.0941   0.0890   0.0995     1160    636121.        600709. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_group_continuous — distrib_group_continuous","title":"distrib_group_continuous — distrib_group_continuous","text":"Function compare means medians different groups complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_group_continuous — distrib_group_continuous","text":"","code":"distrib_group_continuous(   data,   group,   quanti_exp,   type = \"median\",   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = TRUE,   na.rm.facet = TRUE,   quantiles = seq(0.1, 0.9, 0.1),   moustache_probs = c(0.95, 0.8, 0.5),   bw = 1,   resolution = 512,   height = 0.8,   limits = NULL,   reorder = FALSE,   show_mid_point = TRUE,   show_mid_line = FALSE,   show_ci_errorbar = TRUE,   show_ci_lines = FALSE,   show_ci_area = FALSE,   show_quant_lines = FALSE,   show_moustache = TRUE,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   digits = 0,   unit = \"\",   dec = \",\",   pal = \"#e0dfe0\",   pal_moustache = c(\"#EB9BA0\", \"#FAD7B1\"),   color = NA,   alpha = 1,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   lang = \"fr\",   theme = NULL,   export_path = NULL )  distrib_group_c(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_group_continuous — distrib_group_continuous","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. quanti_exp expression define variable variable described. type Type central value : \"mean\" compute mean central value group ; \"median\" compute median central value group.. facet supprimer? filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable. FALSE want create group NA value group variable. NA variables included quanti_exp affected argument. observation NA variables included quanti_exp excluded. na.rm.facet Argument supprimer? quantiles Quantiles computed distributions. Default deciles. moustache_probs vector defining proportions population used draw moustache. Default 0.95, 0.8, 0.5 draw moustache three groups containing respectively 50 percent, 80 percent 95 percent population closest median. bw smoothing bandwidth used. kernels scaled standard deviation smoothing kernel. Default 1. resolution Resolution density curve. Default 512 height Height curves. Default 0.8 limits Limits x axe graphic. apply computation. Default NULL show entire distribution graphic. reorder TRUE want reorder groups according mean/median (depending type). NA value, case na.rm.group = FALSE, included reorder (VERIFIER). show_mid_point TRUE want show mean median (depending type) point graphic. FALSE want show . Default TRUE. show_mid_line TRUE want show mean median (depending type) line graphic. FALSE want show . Default FALSE show_ci_errorbar TRUE want show confidence interval mean median (depending type) error bar graphic. FALSE want show lines. Default TRUE. show_ci_lines TRUE want show confidence interval mean median (depending type) lines graphic. FALSE want show lines. Default FALSE show_ci_area TRUE want show confidence interval mean median (depending type) coloured area graphic. FALSE want show area. Default FALSE. show_quant_lines TRUE want show quantiles lines graphic. FALSE want show lines. Default FALSE. show_moustache TRUE want show moustache graphic. FALSE want show . Default TRUE. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show mean/median group graphic. FALSE want show mean/median. Default TRUE. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. digits Numbers digits showed value labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal Color density areas. Can one sereval colors create palette. pal_moustache Color moustache. Can one sereval colors create palette. color Color density curve. one color. alpha Transparence density curve. Default 1. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line labels groups. Default 25 title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Moyenne : \" + quanti_exp \"Medianne : \" + quanti_exp. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". caption Caption graphic. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_group_continuous — distrib_group_continuous","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"distrib_group_continuous — distrib_group_continuous","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_dist_g_c <- distrib_group_c(   eusilc,   group = pl030_rec,   quanti_exp = eqIncome,   strata = db040,   ids = db030,   weight = rb050,   limits = c(0, 50000),   title = \"Distribution of eq. income\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 #> Variable(s) detectee(s) dans quanti_exp : eqIncome #> 0 lignes supprimees avec valeur(s) manquante(s) pour le(s) variable(s) de quanti_exp  # Results in graph form eusilc_dist_g_c$graph #> Warning: Removed 3710 rows containing missing values or values outside the scale range #> (`geom_line()`).   # Results in table format eusilc_dist_g_c$tab #> # A tibble: 7 × 8 #>   pl030_rec      median median_low median_upp n_sample n_weighted n_weighted_low #>   <chr>           <dbl>      <dbl>      <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling do… 14367.     13918.     14774.     1207    640311.        605978. #> 2 Permanently d… 15967.     13753.     16797.      178    104930.         85796. #> 3 Retired        18401.     17956.     18887.     3146   1806954.       1746273. #> 4 Student        14435.     13780.     15133.      736    395829.        365532. #> 5 Unemployed     15872.     14725.     16900.      518    303252.        276953. #> 6 Working full … 21032.     20644.     21406.     5162   2869868.       2797833. #> 7 Working part … 17580.     17043.     18270.     1160    636121.        600709. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_group_discrete — distrib_group_discrete","title":"distrib_group_discrete — distrib_group_discrete","text":"Function describe distribution discrete variable different groups. can use complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_group_discrete — distrib_group_discrete","text":"","code":"distrib_group_discrete(   data,   group,   quali_var,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   na.rm.var = T,   total = TRUE,   prop_method = \"beta\",   show_value = TRUE,   show_labs = TRUE,   total_name = NULL,   scale = 100,   digits = 0,   unit = \"\",   dec = \",\",   pal = \"Hokusai1\",   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   wrap_width_leg = 25,   legend_ncol = 4,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   legend_lab = NULL,   caption = NULL,   lang = \"fr\",   theme = NULL,   export_path = NULL )  distrib_group_d(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_group_discrete — distrib_group_discrete","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. quali_var discrete variable described different groups. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove NAs quali_var, group facet. FALSE want create NA categories quali_var, group facet. Default TRUE. na.rm.facet TRUE want remove observations NA facet variable. FALSE want create facet NA value facet variable. Default TRUE. na.rm.var TRUE want remove observations NA discrete variable. FALSE want create modality NA value discrete variable. Default TRUE. total TRUE want calculate total, FALSE . default TRUE prop_method Type proportion method used compute confidence intervals. See svyciprop survey package details. Default beta method. show_value TRUE want show proportion category group graphic. FALSE want show proportions. Proportions 2 percent less never showed graphic. Default TRUE. show_labs TRUE want show axes, titles, caption legend labels. FALSE want show label axes, titles, caption legend. Default TRUE. total_name Name total shown graphic. Default \"Total\". scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. dodge Width bar, 0 1. Default 0.9. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line labels groups. Default 25. wrap_width_leg Number characters going line labels categories quali_var. Default 25. legend_ncol Number colomns legend. Default 4. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic wil Distribution : \" + quali_var. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". legend_lab Legend (fill) label graphic. legend_lab = NULL, legend label graphic quali_var. show legend label, use legend_lab = \"\". caption Caption graphic. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_group_discrete — distrib_group_discrete","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"distrib_group_discrete — distrib_group_discrete","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_dist_d <- distrib_group_d( eusilc, group = pb220a, quali_var = pl030_rec, strata = db040, ids = db030, weight = rb050, title = \"Distribution of socio-economic status according to nationality\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050  # Results in graph form eusilc_dist_d$graph #> Warning: Removed 21 rows containing missing values or values outside the scale range #> (`geom_bar()`). #> Warning: Removed 22 rows containing missing values or values outside the scale range #> (`geom_text()`). #> Warning: Removed 8 rows containing missing values or values outside the scale range #> (`geom_text()`).   # Results in table format eusilc_dist_d$tab #> # A tibble: 28 × 9 #>    pb220a pl030_rec    prop prop_low prop_upp n_sample n_weighted n_weighted_low #>    <fct>  <fct>       <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #>  1 AT     Fulfillin… 0.0890  0.0840    0.0942     1036    548489.        516433. #>  2 AT     Permanent… 0.0119  0.00931   0.0150      125     73270.         56226. #>  3 AT     Retired    0.285   0.275     0.295      3055   1754654.       1694827. #>  4 AT     Student    0.0602  0.0558    0.0650      693    371222.        341944. #>  5 AT     Unemployed 0.0388  0.0351    0.0427      411    238841.        215788. #>  6 AT     Working f… 0.421   0.412     0.431      4689   2595137.       2526927. #>  7 AT     Working p… 0.0942  0.0889    0.0998     1064    580514.        546750. #>  8 EU     Fulfillin… 0.124   0.0886    0.167        38     20343.         13863. #>  9 EU     Permanent… 0.0498  0.0280    0.0810       15      8186.          4024. #> 10 EU     Retired    0.155   0.115     0.202        45     25429.         17953. #> # ℹ 18 more rows #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"esth_graph — esth_graph","title":"esth_graph — esth_graph","text":"Function construct graphic following aestetics function function package table","code":""},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"esth_graph — esth_graph","text":"","code":"esth_graph(   tab,   var,   value,   error_low = NULL,   error_upp = NULL,   facet = NULL,   n_var = NULL,   pvalue = NULL,   reorder = F,   show_value = TRUE,   name_total = NULL,   scale = 1,   digits = 2,   unit = \"\",   dec = \",\",   pal = \"indianred4\",   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   theme = NULL )"},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"esth_graph — esth_graph","text":"tab dataframe variables ploted. var variable tab labels indicators ploted. value variable tab values indicator ploted. error_low variable tab lower bound confidence interval. either error_low error_upp NULL error bars shown graphic. error_upp variable tab upper bound confidence interval. either error_low error_upp NULL error bars shown graphic. facet variable tab defining faceting group, applicable. Default NULL. n_var variable tab containing number observation per indicator. Default NULL, showing number observation plot. pvalue p-value show caption. can numeric value pvalue object statsistical test. reorder TRUE want reorder var according value. FALSE want reorder. Default FALSE. show_value TRUE want show values value graphic. FALSE want show proportion. Default TRUE. name_total Name var label may contain total. indicated, displayed separately graph. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit unit showd plot. Default percent. dec Decimal mark shown graphic. Default \",\" pal Colour bars. dodge Width bar, 0 1. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line. Applies labels var. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), var tab. ylab Y label graphic. coord_flip() used graphic, ylab refers y label graphic, coord_flip(), value tab. caption Caption graphic. theme Theme od te graphic. IWEPS adds y axis lines ticks.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"esth_graph — esth_graph","text":"ggplot graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/load_and_active_fonts.html","id":null,"dir":"Reference","previous_headings":"","what":"load_and_active_fonts — load_and_active_fonts","title":"load_and_active_fonts — load_and_active_fonts","text":"Function load activate fonctionr's built-fonts. Available fonts, included package , \"Roboto\", \"Montserrat\", \"Gotham Narrow\", \"Helvetica Neue\", \"League Gothic\" \"Amatic\". Default \"Roboto\".","code":""},{"path":"https://jgires.github.io/fonctionr/reference/load_and_active_fonts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"load_and_active_fonts — load_and_active_fonts","text":"","code":"load_and_active_fonts()"},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":null,"dir":"Reference","previous_headings":"","what":"make_surface — make_surface","title":"make_surface — make_surface","text":"make_surface","code":""},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make_surface — make_surface","text":"","code":"make_surface(   tab,   var,   value,   error_low = NULL,   error_upp = NULL,   facet = NULL,   pvalue = NULL,   reorder = F,   compare = F,   space = NULL,   position = \"mid\",   show_ci = TRUE,   name_total = \"Total\",   digits = 0,   unit = NULL,   pal = \"Kandinsky\",   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   size_text = 3.88,   bg = \"snow2\",   ratio = 3/2,   font = \"Roboto\",   wrap_width_lab = 20,   title = NULL,   hjust.title = 0,   subtitle = NULL,   caption = NULL )"},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make_surface — make_surface","text":"tab dataframe variables ploted. var variable tab labels indicators ploted. value variable tab values indicator ploted. error_low variable tab lower bound confidence interval. either error_low error_upp NULL error bars shown graphic. error_upp variable tab upper bound confidence interval. either error_low error_upp NULL error bars shown graphic. facet variable tab defining faceting group, applicable. Default NULL. pvalue p-value show caption. can numeric value pvalue object statsistical test. reorder TRUE want reorder values. NA value included reorder. compare TRUE display square representing smallest value. facets enabled, smallest value per facet category. space space squares. unit indicator. position position squares: \"mid\" center alignment, \"bottom\" bottom alignment. show_ci TRUE want show CI graphic. bounds confidence intervals displayed dotted squares around result. FALSE want show . Default TRUE. name_total Name var label may contain total. indicated, displayed graph. digits Numbers digits showed values labels graphic. Default 0. unit unit showd plot. Default percent. pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. size_text Text size displayed surfaces. Default 3.88 (ggplot2). bg Color background. ratio Aspect ratio surfaces. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_lab Number characters going line labels categories var. Default 20. title Title graphic. hjust.title Horizontal alignment title & subtitle. subtitle Subtitle graphic. caption Caption graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make_surface — make_surface","text":"ggplot graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"make_surface — make_surface","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Calculation of income means by age category with fonctionr, taking sample design into account eusilc_mean <- mean_group(   eusilc,   group = pl030_rec,   quanti_exp = py010n + py050n + py090n + py100n + py110n + py120n + py130n + py140n,   filter_exp = !pl030_rec %in% c(\"Student\", \"Fulfilling domestic tasks\") & db040 == \"Tyrol\",   weights = rb050 ) #> Input: data.frame #> Sampling design -> ids:  `1`, weights:  rb050 #> Variable(s) detectee(s) dans quanti_exp : py010n, py050n, py090n, py100n, py110n, py120n, py130n, py140n #> 0 lignes supprimees avec valeur(s) manquante(s) pour le(s) variable(s) de quanti_exp  # Displaying results with make_surface() eusilc_mean$tab |>   make_surface(     var = pl030_rec,     value = mean,     error_low = mean_low,     error_upp = mean_upp,     reorder = TRUE,     wrap_width_lab = 15,     unit = \"€\",     title = \"Equivalised income in household by socio-economic status\",     subtitle = \"Example with austrian SILC data from 'laeken' package\" )"},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":null,"dir":"Reference","previous_headings":"","what":"many_val — many_val","title":"many_val — many_val","text":"Function compute de proportions set several binary variables. can use complex survey data. produces table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"many_val — many_val","text":"","code":"many_val(   data,   list_vars,   type,   list_vars_lab = NULL,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.facet = T,   na.vars = \"rm\",   prop_method = \"beta\",   reorder = FALSE,   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   scale = NULL,   digits = 0,   unit = NULL,   dec = \",\",   pal = \"Egypt\",   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   lang = \"fr\",   caption = NULL,   theme = NULL,   export_path = NULL )  many_prop(..., type = \"prop\")  many_median(..., type = \"median\")  many_mean(..., type = \"mean\")"},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"many_val — many_val","text":"data dataframe object survey package object srvyr package. list_vars vector containing names dummy variables compute proportions type \"mean\" compute means ; \"median\" compute medians ; \"prop\" compute proportions. list_vars_lab Names variables facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.vars treatment NA values variables. \"rm\" removes NA individual variable, \"rm.\" removes every individual least one NA one variable. prop_method Type proportion method use. See svyciprop survey package details. Default beta method. reorder TRUE want reorder variables according proportion. show_ci TRUE want show error bars graphic. FALSE want show error bars. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show proportion group graphic. FALSE want show proportion. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\" pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. dodge Width bar, 0 1. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line. Applies labels groups. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. ylab Y label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". caption Caption graphic. theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes two sheets : table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"many_val — many_val","text":"list contains table graphic","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"many_val — many_val","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding variables eusilc$worker <- 0 eusilc$worker[eusilc$pl030 == \"1\"]<-1 eusilc$worker[eusilc$pl030 == \"2\"]<-1 eusilc$austrian<-0 eusilc$austrian[eusilc$pb220a == \"AT\"]<-1  # Computation, taking sample design into account eusilc_many_prop <- many_prop( eusilc, list_vars = c(worker,austrian), list_vars_lab = c(\"% of workers\",\"% of Austrian\"), facet = rb090, strata = db040, ids = db030, weight = rb050, title = \"Proportion of workers and Autrian according to gender\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Variable(s) entrees : worker, austrian #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050  # Results in graph form eusilc_many_prop$graph   # Results in table format eusilc_many_prop$tab #> # A tibble: 4 × 12 #>   rb090  list_col       prop prop_low prop_upp n_sample n_true_weighted #>   <fct>  <fct>         <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 male   % of workers  0.495    0.484    0.506     7267        1969092. #> 2 female % of workers  0.366    0.355    0.376     7560        1536897. #> 3 male   % of Austrian 0.739    0.728    0.750     7267        2942211. #> 4 female % of Austrian 0.766    0.756    0.777     7560        3219916. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":null,"dir":"Reference","previous_headings":"","what":"many_val_group — many_val_group","title":"many_val_group — many_val_group","text":"Function compare de proportions/means/medians set several binary/continuous variables different groups. can use complex survey data. produces table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"many_val_group — many_val_group","text":"","code":"many_val_group(   data,   group,   list_vars,   type,   list_vars_lab = NULL,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   na.vars = \"rm\",   total = TRUE,   prop_method = \"beta\",   position = \"dodge\",   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   total_name = NULL,   scale = NULL,   digits = 0,   unit = NULL,   dec = \",\",   pal = \"Egypt\",   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   wrap_width_leg = 25,   legend_ncol = 4,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   legend_lab = NULL,   lang = \"fr\",   caption = NULL,   theme = NULL,   export_path = NULL )  many_prop_group(..., type = \"prop\")  many_median_group(..., type = \"median\")  many_mean_group(..., type = \"mean\")"},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"many_val_group — many_val_group","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. list_vars vector containing names dummy variables compute proportions type \"mean\" compute means group ; \"median\" compute medians group ; \"prop\" compute proportions group. list_vars_lab Names variables facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.vars treatment NA values variables. \"rm\" removes NA individual variable, \"rm.\" removes every individual least one NA one variable. total TRUE want calculate total, FALSE . default TRUE prop_method Type proportion method use. See svyciprop survey package details. Default beta method. position Position adjustment geom_bar. show_ci TRUE want show error bars graphic. FALSE want show error bars. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show proportion group graphic. FALSE want show proportion. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. total_name Name total bar graphic. Default Total. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\" pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. dodge Width bar, 0 1. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line. Applies labels groups. Default 25. wrap_width_leg Number characters going line. Applies labels legend. Default 25. legend_ncol Number maximum colomn legend. Default 4. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. ylab Y label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. legend_lab Legend (fill) label graphic. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". caption Caption graphic. theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes two sheets : table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"many_val_group — many_val_group","text":"list contains table graphic","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"many_val_group — many_val_group","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding variables eusilc$worker <- 0 eusilc$worker[eusilc$pl030 == \"1\"]<-1 eusilc$worker[eusilc$pl030 == \"2\"]<-1 eusilc$austrian<-0 eusilc$austrian[eusilc$pb220a == \"AT\"]<-1  # Computation, taking sample design into account eusilc_many_mean_group <- many_mean_group( eusilc, group = rb090, list_vars = c(py010n,py050n,py090n,py100n), list_vars_lab = c(\"Wage\",\"Self-employement income\",\"unemployement benefit\",\"pension\"), strata = db040, ids = db030, weight = rb050, title = \"Average incomes according to gender\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Variable(s) entrees : py010n, py050n, py090n, py100n #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050  # Results in graph form eusilc_many_mean_group$graph #> Warning: Removed 8 rows containing missing values or values outside the scale range #> (`geom_bar()`). #> Warning: Removed 8 rows containing missing values or values outside the scale range #> (`geom_text()`). #> Warning: Removed 4 rows containing missing values or values outside the scale range #> (`geom_text()`).   # Results in table format eusilc_many_mean_group$tab #> # A tibble: 12 × 9 #>    rb090  list_col     mean mean_low mean_upp n_sample n_weighted n_weighted_low #>    <fct>  <fct>       <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #>  1 male   Wage       12445.   12102.   12787.     5844   3237897.       3178503. #>  2 female Wage        6136.    5902.    6370.     6263   3519368.       3470221. #>  3 Total  Wage        9159.    8946.    9372.    12107   6757264.       6683738. #>  4 male   Self-empl…  1539.    1369.    1710.     5844   3237897.       3178503. #>  5 female Self-empl…   689.     600.     778.     6263   3519368.       3470221. #>  6 Total  Self-empl…  1096.    1002.    1191.    12107   6757264.       6683738. #>  7 male   unemploye…   420.     371.     469.     5844   3237897.       3178503. #>  8 female unemploye…   431.     387.     475.     6263   3519368.       3470221. #>  9 Total  unemploye…   426.     393.     458.    12107   6757264.       6683738. #> 10 male   pension     4123.    3894.    4353.     5844   3237897.       3178503. #> 11 female pension     3438.    3254.    3623.     6263   3519368.       3470221. #> 12 Total  pension     3767.    3606.    3927.    12107   6757264.       6683738. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/official_pal.html","id":null,"dir":"Reference","previous_headings":"","what":"official_pal — official_pal","title":"official_pal — official_pal","text":"Function produce color palettes different institutions","code":""},{"path":"https://jgires.github.io/fonctionr/reference/official_pal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"official_pal — official_pal","text":"","code":"official_pal(   inst,   n,   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   show_pal = F,   font = \"Gotham Narrow\",   list_pal_names = F )"},{"path":"https://jgires.github.io/fonctionr/reference/official_pal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"official_pal — official_pal","text":"inst Name palette. n Number colors. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. show_pal TRUE display graph representing specified color palette. font Font used graphic. See load_and_active_fonts() available fonts. list_pal_names TRUE generate vector palette names.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/official_pal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"official_pal — official_pal","text":"","code":"official_pal(\"OBSS\", 8, show_pal = TRUE)  official_pal(\"OBSS_Greens\", 8, show_pal = TRUE)  official_pal(\"OBSS_div_mid4\", 7, show_pal = TRUE)  official_pal(\"OBSS_div_bi3\", 8, show_pal = TRUE)  official_pal(\"IBSA\", 4, show_pal = TRUE)  official_pal(\"ULB\", 6, show_pal = TRUE)"},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"pivot_longer_survey — pivot_longer_survey","title":"pivot_longer_survey — pivot_longer_survey","text":"Function pivot wide long agregated data group produced srvyr::summarise","code":""},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"pivot_longer_survey — pivot_longer_survey","text":"","code":"pivot_longer_survey(data, n_groups)"},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"pivot_longer_survey — pivot_longer_survey","text":"data dataframe Agregated data pivot n_groups Number groups data agregated","code":""},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"pivot_longer_survey — pivot_longer_survey","text":"dataframe","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":null,"dir":"Reference","previous_headings":"","what":"prop_group — prop_group","title":"prop_group — prop_group","text":"Function compare proportions different groups complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prop_group — prop_group","text":"","code":"prop_group(   data,   group,   prop_exp,   group.fill = NULL,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   na.prop = \"rm\",   total = TRUE,   prop_method = \"beta\",   reorder = F,   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_labs = TRUE,   total_name = NULL,   scale = 100,   digits = 0,   unit = \"%\",   dec = \",\",   pal = NULL,   direction = 1,   desaturate = 0,   lighten = 0,   darken = 0,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   wrap_width_leg = 25,   legend_ncol = 4,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   legend_lab = NULL,   caption = NULL,   lang = \"fr\",   theme = NULL,   export_path = NULL )"},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prop_group — prop_group","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. prop_exp expression define proportion computed. group.fill variable defining second variable groups compared. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.prop \"rm\" remove NA variables used prop_exp computing proportions, \"include\" compute proportions NA's denominators. Default \"rm\". \"rm\" NA allowed prop_exp. total TRUE want calculate total, FALSE . default TRUE prop_method Type proportion method use. See svyciprop survey package details. Default beta method. reorder TRUE want reorder groups according proportion. NA value, case na.rm.group = FALSE, included reorder. show_ci TRUE want show error bars graphic. FALSE want show error bars. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show proportion group graphic. FALSE want show proportion. show_labs TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. total_name Name total shown graphic. Default \"Total\". scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\" pal group.fill empty, pal must vector containing single color define color bars. variable specified group.fill, pal color palette used graph differentiate different modalities. Palettes MetBrewer, MoMAColors PrettyCols packages available. NA bar, na.rm.group = FALSE, total bar always gray. direction Direction palette color. Default 1. opposite direction -1. desaturate Numeric specifying amount desaturation 1 corresponds complete desaturation, 0 desaturation, values partial desaturation. lighten Numeric specifying amount lightening. Negative numbers cause darkening. darken Numeric specifying amount lightening. Negative numbers cause lightening. dodge Width bar, 0 1. font Font used graphic. See load_and_active_fonts() available fonts. wrap_width_y Number characters going line. Applies labels groups. Default 25. wrap_width_leg Number characters going line labels categories group.fill. Default 25. legend_ncol Number colomns legend. Default 4. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. ylab Y label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. legend_lab Legend (fill) label graphic. legend_lab = NULL, legend label graphic group.fill. show legend label, use legend_lab = \"\". caption Caption graphic. lang language indications chart. Possibilities: \"fr\", \"nl\", \"en\". Default \"fr\". theme Theme od te graphic. IWEPS adds y axis lines ticks. export_path Path export results xlsx file. file includes two sheets : table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"prop_group — prop_group","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"prop_group — prop_group","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_prop <- prop_group( eusilc, group = pl030_rec, prop_exp = py090n > 0, strata = db040, ids = db030, weight = rb050, title = \"% of ind. receiving unemployment benefits in their hh\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 #> Variable(s) detectee(s) dans l'expression : py090n #> 0 lignes supprimees avec valeur(s) manquante(s) pour le(s) variable(s) de l'expression  # Results in graph form eusilc_prop$graph #> Warning: Removed 7 rows containing missing values or values outside the scale range #> (`geom_text()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_text()`).   # Results in table format eusilc_prop$tab #> # A tibble: 8 × 11 #>   pl030_rec                   prop prop_low prop_upp n_sample n_true_weighted #>   <fct>                      <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 Fulfilling domestic tasks 0.0485   0.0369   0.0624     1207          31048. #> 2 Permanently disabled      0.209    0.148    0.282       178          21975. #> 3 Retired                   0.0177   0.0134   0.0229     3146          31988. #> 4 Student                   0.0194   0.0106   0.0323      736           7666. #> 5 Unemployed                0.732    0.690    0.770       518         221878. #> 6 Working full time         0.0818   0.0741   0.0899     5162         234629. #> 7 Working part time         0.110    0.0921   0.130      1160          69869. #> 8 Total                     0.0916   0.0863   0.0971    12107         619054. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/theme_fonctionr.html","id":null,"dir":"Reference","previous_headings":"","what":"theme_fonctionr — theme_fonctionr","title":"theme_fonctionr — theme_fonctionr","text":"theme_fonctionr","code":""},{"path":"https://jgires.github.io/fonctionr/reference/theme_fonctionr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"theme_fonctionr — theme_fonctionr","text":"","code":"theme_fonctionr(font = \"Roboto\", theme = NULL, display = \"ggplot\")"},{"path":"https://jgires.github.io/fonctionr/reference/theme_fonctionr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"theme_fonctionr — theme_fonctionr","text":"font Font used graphic. See load_and_active_fonts() available fonts. theme theme want graphic. Available themes: default theme “IWEPS”. display way theme_fonctionr() works axis texts: like ggplot2 ggtext.","code":""}]
