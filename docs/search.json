[{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-3-0","dir":"Articles","previous_headings":"","what":"fonctionr 0.3.0","title":"Changelog","text":"Date : 2024-04-26 La documentation été complétée pour que le package puisse être utilisé par des personnes tierces. Le package commence à être diffusable. Le bug avec la ligne du geom_line qui est coupée pour distrib_group_continuous() est réglé. bug d’ordonnancement des facteurs réglé dans esth_graph().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-13","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.13","title":"Changelog","text":"Date : 2024-04-20 Création de make_surface() comme fonction indépendante utilisable sur n’importe quel tableau de résultats. Ajout de la possibilité d’afficher le résultat d’un test statistique dans esth_graph().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-12","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.12","title":"Changelog","text":"Date : 2024-04-04 Création de distrib_continuous() et distrib_group_continuous(). Modification du thème theme_fonctionr() pour qu’il soit plus adapté aux nouvelles fonctions.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-11","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.11","title":"Changelog","text":"Date : 2024-03-17 Réécriture du code de toutes les fonctions (sauf esth_graph() et pivot_longer_survey()) : simplification + structuration. Nouvelle logique des na.rm finalisée pour toutes les fonctions (différenciation de na.rm.group et na.rm.facet, introduction de na.rm.var pour distrib_group_d() et distrib_d()). Ajout de checks pour vérifier si la couleur/palette est valide : couleur/palette par défaut si la couleur introduite est invalide. Création d’une fonction interne de création de palettes, permettant de produire les palettes de différentes institutions (pour l’instant Vivalis et Perspective, pour tester).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-10","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.10","title":"Changelog","text":"Date : 2024-03-15 Ajout des argument na.rm.facet dans prop_group() et central_group(). Possibilité de mettre une couleur unie pour many_val(). Création de l’argument na.vars pour many_val() et many_val_group().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-9","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.9","title":"Changelog","text":"Date : 2024-03-05 Ajout des palettes dans many_val().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-8","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.8","title":"Changelog","text":"Date : 2024-03-03 Modification des checks pour voir si les variables indispensables existent bien dans data : simplification du code et message plus clair et utile pour l’utilisateur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-7","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.7","title":"Changelog","text":"Date : 2024-03-01 Ajout de many_val() comme fonction plus générale qui englobe many_prop(). Il y désormais la possibilité de calculer des moyennes et des médianes avec les alias many_mean() et many_median(). Plus de parcimonie pour l’import des packages extérieurs dans le namespace. Changement de nom des arguments : na.var devient na.prop et facet.var devient facet. Début de simplification du code dans un de facilité pour la maintenance et les modifs futures.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-6","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.6","title":"Changelog","text":"Date : 2024-02-22 Ajout d’un check de l’expression dans prop_group(), évitant de produire des résultats incohérents.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-5","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.5","title":"Changelog","text":"Date : 2024-02-19 Implémentation du trycatch() sur le test statistique dans prop_group() : le test statistique est désormais bypassé si les conditions ne sont pas remplies et ne stoppe donc plus prop_group() en cas d’erreur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-4","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.4","title":"Changelog","text":"Date : 2024-02-17 Implémentation de checks pour vérifier que les variables de many_prop_group() soient bien binaires, et pour éviter les variables à une modalité pour quali_var dans distrib_group_discrete(). Correction d’un bug dans esth_graph().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-3","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.3","title":"Changelog","text":"Date : 2024-02-17 Implémentation de l’export excel pour many_prop() et many_val_group().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-2","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.2","title":"Changelog","text":"Date : 2024-02-14 Implémentation du test statistique pour distrib_discrete(). Correction d’un bug découvert à cette occasion, qui empêchait de faire fonctionner distrib_discrete() avec na.rm.group = FALSE.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-1","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.1","title":"Changelog","text":"Date : 2024-02-14 Amélioration des fonctions internes de vérification de la validité des arguments. Celles-ci renvoient désormais un message plus clair pour l’utilisateur.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"fonctionr-0-2-0","dir":"Articles","previous_headings":"","what":"fonctionr 0.2.0","title":"Changelog","text":"prop_group() : ajout de la possibilité de calculer des proportions en comptant les NA au dénominateur avec l’argument na.var = \"include\". Dans ce cas, l’expression prop_exp peut contenir la fonction .na() pour calculer la proportion de valeurs manquantes. many_val_group() : changement de l’ordre des labels pour que l’ordre des couleurs corresponde à l’ordre sur le graphique. Ajout d’exemples dans la documentation à partir des données SILC inclues dans le package laeken. Correction de bugs mineurs.","code":""},{"path":[]},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"en-général","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"En général","title":"Changelog","text":"Tableau à mettre dans la doc. Changer tous les %>% en |>. Les couleurs des palettes sont attachées au groupe (many_val_group()) ou à l’indicateur (many_val()), mais pas à la position. De ce fait, lorsque reorder = T, l’ordre des couleurs de la palette n’est pas respecté => changer le comportement ? Bug à l’import de fonctionr du fait de collision entre MetBrewer, MoMAColors, PrettyCols et les fonctions de base ? Je ne comprends pas le message. Documenter tous les arguments des différentes fonctions + vérifier que les explications sont bien correctes (quelques erreurs, par ex. à cause de copier-coller ou de l’ajout de nouveaux argument avec la nouvelle logique des na.rm). Il y également des champs manquants (voir warnings de roxygenise()). Voir ici pour savoir les différentes options possibles dans la doc : https://r-pkgs.org/man.html. Vérifier que les scripts sont bien commentés pour qu’se rappelle ce qu’fait (il manque des notes et quelques explications d’opérations dont je ne rappelle plus le ). Passer le code de chaque fonction en revue pour cleaner / harmoniser / simplifier.=> En cours : il faut encore checker le code du graphique ggplot. Ajouter des exemples pour chaque fonction (pour le site) : manque pivot_longer_survey(), esth_graph(). Fichiers *.R pas compatibles ASCII => tout écrire en anglais. Vérifier les messages à l’utilisateur : voir quoi garder, corriger, traduire, ajouter des guillemets pour les arguments dans les checks, mieux écrire les résultats des tests stat (ne sait pas quelle est l’hypothèse nulle). Mettre des conditions pour réaliser les tests (n min, distribution, variances égales…). Changer la fonction scales::pvalue, qui n’est plus valide (superseded) => Faire une fonction maison en interne. Ajouter des checks pour les inputs : Pas mettre les mêmes colonnes dans les différents arguments ? (group, var_distrib, facet_var, etc.). Les cluster / strates / weights n’apparaissent pas dans le message de la console avec les replicates => pourquoi ? distrib_c Ajouter le test stat univarié avec comme H0 mu dans la population. Apparemment la fonction n’est pas pré-programmée dans survey, il faut la faire soi-même. Ajouter la possibilité de facets. distrib_group_c Le groupe NA est transfomé en level du facteur de groupe. De ce fait, il n’apparaît pas toujours en dernier, notamment lorsque reorder = T. Régler ça (pas cohérent avec les autres fonctions). Ajouter l’export excel. Faire en sorte que le nom du groupe soit toujours le même dans les sorties de la liste (pour le moment, parfois “group”, parfois le nom de la variable) => implique de changer l’argument = des left_join() dans le script, et donc le nommage des colonnes. Ajouter la possibilité de facets. La colonne central dans l’objet dens produit n’pas de valeur y_ridges. Un peu cleaner le script : il y des étapes inutiles qui pourraient être simplifiées, notamment dans la création des valeurs centrales.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"central_group","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"central_group","title":"Changelog","text":"Bypasser l’erreur du test stat avec tryCatch().","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"distrib_group_d","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"distrib_group_d","title":"Changelog","text":"Implémenter un test stat lorsqu’il y des facets => via modélisation loglinéaire, mais j’ai un peu de mal à comprendre les erreurs de survey (erreurs fréquentes).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"many_val_group","dir":"Articles","previous_headings":"To do list > Prioritaire (nécessités ou bugs)","what":"many_val_group","title":"Changelog","text":"Améliorer l’alignement des effectifs avec show_n = T lorsque position == \"stack\"","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"make_surface","dir":"Articles","previous_headings":"To do list","what":"make_surface","title":"Changelog","text":"Ajouter les checks (penser le cas spécifique de pvalue). Ajouter la possibilité de facets. esth_graph Changer le nom. Ajouter le check pour l’argument pvalue. Régler le pb si multiples NA + voir si un pb se pose avec multiples totaux.","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"en-général-1","dir":"Articles","previous_headings":"To do list > Améliorations","what":"En général","title":"Changelog","text":"Faire une fonction commune pour la création de palettes + checks => redondance inutile entre les fonctions. Réécrire le code du test pour avoir la formule originale => possible avec eval(), voir code de central_group(). Voir si peut créer une fonction commune à toutes les fonctions du package pour créer le ggplot => ce serait une large simplification. Pour l’instant, il y déjà un thème commun theme_fonctionr. Créer une fonction de check des inputs indispensables (car redondance entre les 4 fonctions)=> Pour l’instant c’est fait “en dur” : difficultés de créer une fonction du fait de l’usage du tidyverse : il faut sans doute utiliser les fonctions de rlang. L’import des packages peut être optimisé : il n’est pas utile d’importer des packages extérieurs entiers dans le NAMESPACE, cela augmente le risque de collisions de noms de fonctions => un bon résumé ici : https://mdneuzerling.com/post/-ive-learnt--making--r-package/ et pour plus de détails : https://r-pkgs.org/dependencies--practice.html.=> faire : importer seulement les fonctions utiles (mutate, select, etc.).","code":""},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"distrib_group_d-1","dir":"Articles","previous_headings":"To do list > Améliorations","what":"distrib_group_d","title":"Changelog","text":"Ajouter les n par “cellule” ? Ajouter les effectifs totaux par groupe ? (dans le nom du groupe ?) Ajouter un total ? Il faudrait une autre couleur, sinon pas clair => comment faire vu qu’il y la palette de couleur des modalités ?=> Tentative en cours d’utiliser des hachures. Réordonner les levels sur la variable group ? Mais selon quelle valeur (vu qu’il y en plusieurs) ? Celle du premier level de la variable var_distrib ? Possibilité d’indiquer un vecteur avec une palette de couleur ?","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"filtrage","dir":"Articles","previous_headings":"Notes","what":"Filtrage","title":"Changelog","text":"Il semble qu’il faille filtrer après la déclaration du design. Si ne le fait pas, considère le design sur l’objet filtré (avec moins de PSU / strates qu’il y en en réalité), ce qui sous-estime potentiellement la distribution d’échantillonnage. Voir : https://stats.stackexchange.com/questions/411026/---important--make-survey-design-object-svydesign-function--r--https://notstatschat.rbind.io/2021/07/22/subsets--subpopulations--survey-inference/ => De ce fait, j’ai inclus une option de filtre (filter_exp) dans les fonctions (qui filtre après la déclaration du design), qui évite de filtrer l’objet avant en dégradant le design. => Vérifier que c’est bien OK ! FAIRE : expliquer dans la doc !","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/articles/changelog.html","id":"bivarié-ou-3-variables","dir":"Articles","previous_headings":"Fonctions à créer","what":"Bivarié ou 3 variables+","title":"Changelog","text":"Superposition de 2 statistiques (bar + lines) avec échelles différentes. Tableau croisé avec résidus ou couleur par proportion (proportions par c, l, ou total)","code":""},{"path":"https://jgires.github.io/fonctionr/articles/esthetic_functions.html","id":"theme_fonctionr-load_and_active_fonts","dir":"Articles","previous_headings":"","what":"theme_fonctionr() & load_and_active_fonts()","title":"Fonctions esthétiques","text":"theme_fonctionr() est une fonction qui permet d’appliquer le thème de fonctionr à un objet ggplot2. Cette fonction un intérêt si l’veut uniformiser l’esthétique de tous les graphiques - ceux qui sont produits avec fonctionr et ceux qui ne le sont pas - pour une publication. Elle nécessite d’indiquer la police à utiliser dans l’argument font. La fonction load_and_active_fonts() est ainsi complémentaire, puisqu’elle permet de charger facilement des polices de caractères et de les rendre disponibles pour ggplot2. Actuellement trois polices sont directement incluses dans fonctionr : \"Roboto\", \"Montserrat\" et \"Gotham Narrow\".","code":"# Loading of data data(eusilc, package = \"laeken\")  tab1 <- eusilc |>   as_survey_design(ids = db030, strata = db040, weights = rb050) |>   group_by(pb220a) |>   summarise(     prop = survey_mean(eqIncome > 10000, proportion = T, vartype = \"ci\", na.rm = T)   )  ggtab1 <- tab1 |>   ggplot(aes(x = pb220a, y = prop)) +   geom_col() +   labs(title = \"I'm a graphic\") +   coord_flip()  fonctionr::load_and_active_fonts()  ggtab2 <- ggtab1 +   theme_fonctionr(font = \"Montserrat\")  ggtab1 | ggtab2"},{"path":"https://jgires.github.io/fonctionr/articles/esthetic_functions.html","id":"esth_graph","dir":"Articles","previous_headings":"","what":"esth_graph()","title":"Fonctions esthétiques","text":"esth_graph() est une fonction qui permet de construire facilement une graphique similaire à ceux produit par les autres fonction mais directement à partir d’une tableau de résultats calculé antérieurement. Cette fonction un intérêt si l’veut appliquer l’esthétique graphique de fonctionr mais à des indicateurs qui ne sont pas calculés par une fonction de fonctionr. esth_graph() permet aisément d’intégrer plusieurs éléments que l’retrouve dans d’autres graphiques produits par fonctionr : valeurs de l’indicateur, bornes d’intervalle de confiance, nombres d’individus dans l’échantillon. La logique d’esth_graph() est différente de celle de theme_fonctionr() : la première fonction produit un graphique à partir d’une table, alors que la seconde applique un thème à un graphique existant. En comparaison des autres fonctions, esth_graph() n’pas d’argument data, mais un argument tab qui doit correspondre à la table avec les indicateurs (il s’appelle tab car il est similaire à l’objet tab produit par la plupart des fonctions de fonctionr). Les arguments var et value sont obligatoires et ils indiquent respectivement les colonnes dans tab avec nom de l’indicateur et sa valeur. reorder et show_value. error_low, error_upp et n_var permettent d’indiquer les colonnes dans tab où se trouvent les bornes inférieures et supérieures des barres d’erreurs et le nombre de personnes dans l’échantillon. Par défaut, ces arguments ont une valeur NULL, ce qui conduit à ne pas montrer ces éléments dans le graphique. name_total permet d’indiquer le nom du total dans tab de manière à ce que cette valeur soit mise en évidence (couleur et position) dans le graphique.","code":"tab2 <- eusilc |>   as_survey_design(ids = db030, strata = db040, weights = rb050) |>   group_by(db040) |>   cascade(     mean = survey_mean(eqIncome, vartype = \"ci\"),     n = unweighted(n()),     .fill = \"Total\"   )  esth_graph(tab2,   value = mean,   var = db040,   error_low = mean_low,   error_upp = mean_upp,   n_var = n,   name_total = \"Total\",   reorder = T,   digits = 1,   unit = \"€\" )"},{"path":"https://jgires.github.io/fonctionr/articles/esthetic_functions.html","id":"make_surface","dir":"Articles","previous_headings":"","what":"make_surface()","title":"Fonctions esthétiques","text":"make_surface() permet de créer la représentation de différentes valeurs déja calculées en tant que surfaces - sous la forme de carrés. Il s’agit d’un graphique potentiellement intéressant si l’veut représenter la taille des logements en m², par exemple. La fonction est purement graphique ; elle s’applique sur un dataframe de plusieurs lignes comprenant les modalités/groupes à comparer (argument var) et la valeur pour chacun d’eux (value). La fonction est donc idéalement applicable au dataframe tab produit par central_group(). Notre package fonctionr étant destiné à l’analyse inférentielle, les bornes supérieures et inférieures des intervalles de confiance peuvent être indiquées (error_low et error_upp) ; elles sont alors affichées sur le graphique d’une manière originale, comme carrés en pointillés autour de la valeur dans l’échantillon.","code":"eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  eusilc_mean <- mean_group(eusilc,   group = pl030_rec,   quanti_exp = py010n + py050n + py090n + py100n + py110n + py120n + py130n + py140n,   filter_exp = !pl030_rec %in% c(\"Student\", \"Fulfilling domestic tasks\"),   weights = rb050 ) eusilc_mean$tab %>%   filter(pl030_rec != \"Total\") %>%   make_surface(     var = pl030_rec,     value = mean,     error_low = mean_low,     error_upp = mean_upp,     reorder = T,     show_ci = T,     wrap_width_lab = 15,     unit = \"€\",     title = \"Mean of monthly equivalised income in household by socio-economic status\",     subtitle = \"Example with austrian SILC data from 'laeken' package\"   )"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"présentation-des-différentes-fonctions","dir":"Articles","previous_headings":"","what":"Présentation des différentes fonctions","title":"Manuel d'utilisation","text":"La plupart des fonctions de fonctionr permettent, à partir de données issues d’un sondage (complexe mais aussi simple), de produire une liste qui contient la plupart du temps ces trois éléments : Un graphique qui permet la visualisation des indicateurs calculés avec leurs intervalles de confiance. Il s’agit d’un objet ggplot2 qui peut donc aussi être modifié par la suite. Le graphique se veut suffisamment finalisé pour être directement utilisable dans une publication ; Un ou plusieurs dataframe qui reprennent les chiffres sur base desquels le graphique est construit. Ceux-ci reprennent généralement le nom de l’indicateur, sa valeur, les bornes d’intervalle de confiance, le nombre de personnes dans l’échantillon dans chaque catégorie, l’estimation du nombre de personnes dans la population dans chaque catégorie et les bornes de l’intervalle de confiance de cette estimation ; Les différents résultats d’un test statistique lorsqu’il y en un qui est pertinent. La plupart des fonctions permettent aussi d’exporter directement ces trois résultats dans un format Excel, dans l’idée de pouvoir facilement communiquer les résultats à une tierce personne, ou à un graphiste dans le cas du travail de mise en page d’un rapport. Dans la suite de cette partie, nous passons les fonctions en revue en indiquant quels sont leurs objectifs et spécificités.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_discrete-distribution-dune-variable-catégorielle","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_discrete() : distribution d’une variable catégorielle","title":"Manuel d'utilisation","text":"distrib_discrete(), avec distrib_d() comme alias, calcule la distribution (en proportions relatives) des différentes modalités d’une variables qualitative. Pour l’exemple, nous utilisons la base de données de l’enquête SILC menée en Autriche en 2006, contenue dans le package laeken. Nous chargeons d’abord les données et recodons le statut socio-économiques (pl030) pour lui donner des labels intelligibles, utilisés dans la suite des exemples : Ci-dessous, la fonction distrib_d() décrit la distribution des différents statuts socio-économiques dans le dataframe eusilc, avec une le poids rb0501. Comme le voit, les variables sont indiquées sans guillemets, à la manière de la syntaxe du tidyverse. Nous affichons ensuite le graphique contenu dans la liste produite :  La liste contient également un dataframe tab qui reprend les chiffres sur base desquels le graphique est construit. Il comprend les colonnes suivantes : le nom de la modalité (pl030_rec), l’estimation de la proportion de la population appartenant à la modalité (prop), les bornes inférieure (prop_low) et supérieure (prop_upp) de l’intervalle de confiance de cette estimation à un niveau de confiance de 95%, le nombre de personnes dans l’échantillon appartenant à la modalité (n_sample), l’estimation du nombre de personnes dans la population appartenant à la modalité (n_weighted), et les bornes inférieure (n_weighted_low) et supérieure (n_weighted_upp) de l’intervalle de confiance de cette estimation à un niveau de confiance de 95% : La liste contient pour finir le résultat du test statistique dans l’objet test.stat. Dans ce cas, il s’agit du khi2 d’adéquation. Ce test est réalisé avec comme hypothèse nulle la répartition de la population selon le vecteur mentionné dans l’argument probs = c(.2, .15, .1, .1, .25, .1, .1), c’est-à-dire 20% de travailleurs à temps plein, 15% de travailleurs à temps partiel, 10% de chômeurs, 10% d’étudiants, 25% de pensionnés, 10% de personnes en incapacité permanente de travail et 10% de personnes au foyer. Si aucun vecteur n’avait été mentionné dans probs, aucun test n’aurait été effectué. Si le vecteur n’pas une somme de 1, il est ajusté pour avoir une telle somme. Notons que la p-valeur du test est mentionnée sur le graphique.","code":"library(fonctionr) library(patchwork)  # Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\" # Computation, taking sample design into account eusilc_dist_d <- distrib_d(   data = eusilc,   weights = rb050,   quali_var = pl030_rec,   probs = c(.2, .15, .1, .1, .25, .1, .1),   title = \"Distribution of socio-economic status\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_d$graph eusilc_dist_d$tab #> # A tibble: 7 × 8 #>   pl030_rec            prop prop_low prop_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domest… 0.0948   0.0897   0.100      1207    640311.        605407. #> 2 Permanently disab… 0.0155   0.0133   0.0180      178    104930.         89217. #> 3 Retired            0.267    0.259    0.276      3146   1806954.       1750021. #> 4 Student            0.0586   0.0545   0.0629      736    395829.        367611. #> 5 Unemployed         0.0449   0.0411   0.0489      518    303252.        277166. #> 6 Working full time  0.425    0.416    0.434      5162   2869868.       2805298. #> 7 Working part time  0.0941   0.0890   0.0995     1160    636121.        600495. #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_dist_d$test.stat #>  #>  Design-based chi-squared test for given probabilities #>  #> data:  ~pl030_rec #> X-squared = 11462652, scale = 1300.5577, df = 2.9068, p-value < 2.2e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_group_discrete-distribution-dune-variable-catégorielle-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_group_discrete() : distribution d’une variable catégorielle par groupe","title":"Manuel d'utilisation","text":"distrib_group_discrete(), avec distrib_group_d() comme alias, calcule la distribution (en pourcentages) des différentes modalités d’une variables qualitative selon les modalités d’une autre variable qualitative, que l’peut considérer comme des groupes. Par rapport aux autres fonctions, faute de représentation adéquate, les intervalles de confiance ne sont pas indiqués sur le graphique. Le test statistique repris est celui du khi2 de Pearson avec l’ajustement de Rao & Scott. Ce test est réalisé avec comme hypothèse nulle le fait que les deux variables qualitatives (d’intérêt et de groupe) soient statistiquement indépendantes. L’exemple ci-dessous montre la distribution des fréquences des différents statuts socio-économiques (pl030_rec) selon la nationalité (pb220a).","code":"eusilc_dist_group_d <- distrib_group_d(eusilc,   weights = rb050,   group = pb220a,   quali_var = pl030_rec,   title = \"Distribution of socio-economic status according to nationality\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_group_d$graph eusilc_dist_group_d$tab #> # A tibble: 21 × 9 #>    pb220a pl030_rec    prop prop_low prop_upp n_sample n_weighted n_weighted_low #>    <fct>  <fct>       <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #>  1 AT     Fulfillin… 0.0890  0.0838    0.0944     1036    548489.        516023. #>  2 AT     Permanent… 0.0119  0.00986   0.0142      125     73270.         60135. #>  3 AT     Retired    0.285   0.276     0.293      3055   1754654.       1698342. #>  4 AT     Student    0.0602  0.0559    0.0648      693    371222.        343916. #>  5 AT     Unemployed 0.0388  0.0351    0.0427      411    238841.        215672. #>  6 AT     Working f… 0.421   0.412     0.431      4689   2595137.       2532480. #>  7 AT     Working p… 0.0942  0.0888    0.0998     1064    580514.        546451. #>  8 EU     Fulfillin… 0.124   0.0887    0.166        38     20343.         13851. #>  9 EU     Permanent… 0.0498  0.0280    0.0811       15      8186.          4019. #> 10 EU     Retired    0.155   0.115     0.202        45     25429.         17928. #> # ℹ 11 more rows #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_dist_group_d$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 32.8, ndf = 11.957, ddf = 144750.034, p-value < 2.2e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"prop_group-proportion-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"prop_group() : proportion par groupe","title":"Manuel d'utilisation","text":"prop_group() calcule des proportions pour les différentes modalités d’une variable qualitative, que l’peut considérer comme des groupes. Pour indiquer la proportion à calculer, l’utilisateur peut indiquer soit une variable dichotomique, soit directement une expression (sans guillemet, à la manière du tidyverse) à partir de laquelle la proportion est calculée. L’exemple ci-dessous compare la proportion d’individus qui bénéficient d’une allocation de chômage (calculé avec l’expression py090n > 0) selon les différents statuts socio-économiques (pl030_rec).  Le graphique et le tableau contiennent une modalité Total qui reprend l’estimation de la proportion pour l’ensemble de la population de référence. Dans le dataframe tab produit, trouve : l’estimation du nombre de personnes dans la population pour lesquelles le critère de proportion est vérifié (n_true_weighted) accompagné de ses bornes inférieure (n_true_weighted_low) et supérieure (n_true_weighted_upp) de l’intervalle de confiance à un niveau de confiance de 95% ; le nombre total de personnes dans la population pour lesquelles les données sont valides2 (n_tot_weighted) accompagné de ses bornes inférieure (n_tot_weighted_low) et supérieure (n_tot_weighted_upp) de l’intervalle de confiance. Le test statistique réalisé est celui du khi2 de Pearson avec l’ajustement de Rao & Scott. Ce test est réalisé avec comme hypothèse nulle le fait que les deux variables qualitatives (les variables dichotomique proportion vraie-fausse et de groupe) soient statistiquement indépendantes .","code":"eusilc_prop <- prop_group(eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   weights = rb050,   title = \"% of ind. receiving unemployment benefits in their hh by soc.-eco. stat.\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop$graph eusilc_prop$tab #> # A tibble: 8 × 11 #>   pl030_rec                   prop prop_low prop_upp n_sample n_true_weighted #>   <fct>                      <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 Fulfilling domestic tasks 0.0485   0.0369   0.0625     1207          31048. #> 2 Permanently disabled      0.209    0.152    0.278       178          21975. #> 3 Retired                   0.0177   0.0134   0.0229     3146          31988. #> 4 Student                   0.0194   0.0106   0.0324      736           7666. #> 5 Unemployed                0.732    0.691    0.770       518         221878. #> 6 Working full time         0.0818   0.0743   0.0897     5162         234629. #> 7 Working part time         0.110    0.0921   0.130      1160          69869. #> 8 Total                     0.0916   0.0864   0.0970    12107         619054. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl> eusilc_prop$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 485.82, ndf = 5.9943, ddf = 72567.0400, p-value < 2.2e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"central_group-valeur-centrale-moyennemédiane-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"central_group() : valeur centrale (moyenne/médiane) par groupe","title":"Manuel d'utilisation","text":"central_group() compare la valeur centrale d’une variable quantitative selon les modalités d’une variable qualitative, que l’peut considérer comme des groupes. Deux valeurs centrales sont possibles : la moyenne, quand l’argument type = \"mean\" ou pour l’alias mean_group() ; la médiane, quand l’argument type = \"median\" ou pour l’alias median_group(). L’argument type est prédéfini pour les fonctions “alias”. Il ne doit pas être utilisé par l’utilisateur s’il utilise les fonctions “alias”. Pour indiquer la tendance centrale à calculer, l’utilisateur peut indiquer soit une variable quantitative, soit directement une expression (sans guillemet, à la manière du tidyverse) à partir de laquelle une nouvelle variable quantitative est calculée. L’exemple ci-dessous compare le revenu équivalent mensuel moyen (calculé avec l’expression eqIncome / 12) selon les différents statuts socio-économiques des personnes (pl030_rec). Le graphique et le tableau contiennent une modalité “Total” qui reprend l’estimation de tendance centrale pour l’ensemble de la population de référence. Pour mean_group(), le test statistique effectué est un test de Wald3. Ce test est réalisé avec comme hypothèse nulle le fait que les coefficients d’une régression linéaire pour les modalités de la variable qualitative (les groupes) sur la variable quantitative soient nuls. Pour median_group(), le test statistique effectué est celui de Kruskal Wallis.","code":"eusilc_mean <- mean_group(eusilc,   group = pl030_rec,   quanti_exp = eqIncome / 12,   weights = rb050,   title = \"Mean of monthly equivalised income in household by socio-economic status\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_mean$graph eusilc_mean$tab #> # A tibble: 8 × 8 #>   pl030_rec            mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domesti… 1296.    1255.    1337.     1207    640311.        605407. #> 2 Permanently disabl… 1330.    1206.    1454.      178    104930.         89217. #> 3 Retired             1720.    1688.    1751.     3146   1806954.       1750021. #> 4 Student             1355.    1296.    1414.      736    395829.        367611. #> 5 Unemployed          1456.    1382.    1531.      518    303252.        277166. #> 6 Working full time   1895.    1870.    1920.     5162   2869868.       2805298. #> 7 Working part time   1591.    1545.    1637.     1160    636121.        600495. #> 8 Total               1703.    1686.    1719.    12107   6757264.       6702060. #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_mean$test.stat #> Wald test for pl030_rec #>  in svyglm(formula = fmla, design = data_W) #> F =  137.4607  on  6  and  12100  df: p= < 2.22e-16"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"many_val-calculer-plusieurs-indicateurs","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"many_val() : calculer plusieurs indicateurs","title":"Manuel d'utilisation","text":"many_val() réalise des calculs de proportion ou de tendance centrale simultanément pour plusieurs variables différentes. La fonction permet de calculer trois résultats différents : Le calcul de proportions quand l’argument type = \"prop\" ou pour l’alias many_prop() ; Le calcul de moyennes quand l’argument type = \"mean\" ou pour l’alias many_mean() ; Le calcul de médianes quand l’argument type = \"median\" ou pour l’alias many_median(). L’argument type est prédéfini pour les fonctions “alias”. Il ne doit pas être utilisé par l’utilisateur s’il utilise les fonctions “alias”. Les variables pour lesquelles veut réaliser ce calcul sont indiquées sans guillemets dans un vecteur passé à l’argument list_vars. Contrairement à prop_group() ou central_group(), ne peut pas indiquer d’expression : ce doit être des variables dichotomisées (pour les proportions) ou quantitatives (pour les moyennes ou médianes). Le dataframe tab produit, contenant les indicateurs, est analogue à celui produit par prop_group() pour les proportions et central_group() pour les moyennes/médianes. Pour des raisons de lisibilité, ces fonctions ne calculent aucun test statistique. L’exemple ci-dessous compare les revenus mensuels moyens de l’emploi salarié, d’une activité d’indépendant et d’une allocation de chômage dans la totalité de la population.","code":"# Computation, taking sample design into account eusilc_many_mean <- many_mean(eusilc,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   unit = \"€\",   title = \"Income from wage, independant worker and unemployement benefits\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_many_mean$graph eusilc_many_mean$tab #> # A tibble: 3 × 8 #>   list_col             mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 salaires            9159.    8945.    9373.    12107   6757264.       6702061. #> 2 revenus d'une acti… 1096.    1002.    1191.    12107   6757264.       6702061. #> 3 allocation de chôm…  426.     393.     459.    12107   6757264.       6702061. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"many_val_group-calculer-plusieurs-indicateurs-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"many_val_group() : calculer plusieurs indicateurs par groupe","title":"Manuel d'utilisation","text":"many_val_group() fonctionne comme many_val(), mais permet d’indiquer une variable qualitative de groupes : les résultats sont alors différenciés selon les différentes modalités de cette variable (= les groupes). Trois calculs sont possibles : La comparaison de proportions quand l’argument type = \"prop\" ou pour l’alias many_prop_group() ; La comparaison de moyennes quand l’argument type = \"mean\" ou pour l’alias many_mean_group() ; La comparaison de médianes quand l’argument type = \"median\" ou pour l’alias many_median_group(). L’argument type est prédéfini pour les fonctions “alias”. Il ne doit pas être utilisé par l’utilisateur s’il utilise les fonctions “alias”. L’exemple ci-dessous compare les revenus mensuels moyens de l’emploi salarié, d’une activité d’indépendant et d’une allocation de chômage des femmes et des hommes.","code":"# Computation, taking sample design into account eusilc_many_mean_group <- many_mean_group(eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   unit = \"€\",   title = \"Income from wage, independant worker and unemployement benefits by sex\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_many_mean_group$graph eusilc_many_mean_group$tab #> # A tibble: 6 × 9 #>   rb090  list_col      mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>  <fct>        <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 male   salaires    12445.   12098.   12791.     5844   3237897.       3171916. #> 2 female salaires     6136.    5900.    6372.     6263   3519368.       3451545. #> 3 male   revenus d'…  1539.    1368.    1711.     5844   3237897.       3171916. #> 4 female revenus d'…   689.     600.     778.     6263   3519368.       3451545. #> 5 male   allocation…   420.     371.     468.     5844   3237897.       3171916. #> 6 female allocation…   431.     386.     476.     6263   3519368.       3451545. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_continuous-distribution-dune-variable-continue","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_continuous() : distribution d’une variable continue","title":"Manuel d'utilisation","text":"distrib_continuous(), avec distrib_c() comme alias, calcule la distribution d’une variable continue. L’argument type permet d’indiquer quel type de valeur centrale doit être calculée et indiquée sur le graphique : \"mean\" pour la moyenne et \"median\" pour la médiane. Par défaut, c’est la médiane qui est calculée et affichée. bw indique le degré de “lissage” de la densité. Une valeur plus élevée conduira à davantage lisser la densité et masquera davantage les variations locales. resolution indique la “finesse” du calcul de la densité. Avec une résolution plus faible, il y aura moins de points et verra graphiquement les petites droites reliant les points de densité. Une grande résolution implique cependant des calculs plus longs. L’exemple ci-dessous décrit la distribution de l’âge. L’objet produit est une liste qui comprend quatre éléments. trouve graph et tab, comme dans les autres fonction.  L’objet dens reprend la densité calculée, et l’objet quant reprend les différents quantiles retenus. Dans cette fonction, il n’y pas de test statistique calculé .","code":"distrib_age <- distrib_c(eusilc, age, type = \"mean\", bw = .7) distrib_age$graph distrib_age$tab #> # A tibble: 1 × 7 #>    mean mean_low mean_upp n_sample n_weighted n_weighted_low n_weighted_upp #>   <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl>          <dbl> #> 1  39.2     38.8     39.6    14827      14827          14827          14827 head(distrib_age$dens) #>           x            y quantFct central #> 1 -7.182919 1.478527e-05        1    <NA> #> 2 -7.075034 1.745094e-05        1    <NA> #> 3 -6.967150 2.053500e-05        1    <NA> #> 4 -6.859265 2.409212e-05        1    <NA> #> 5 -6.751381 2.821400e-05        1    <NA> #> 6 -6.643496 3.303312e-05        1    <NA> distrib_age$quant #>   probs quantile ci.2.5 ci.97.5        se #> 1   0.1        9      9      10 0.2550859 #> 2   0.2       17     17      18 0.2550859 #> 3   0.3       25     25      26 0.2550859 #> 4   0.4       33     33      34 0.2550859 #> 5   0.5       39     39      40 0.2550859 #> 6   0.6       45     45      46 0.2550859 #> 7   0.7       52     52      53 0.2550859 #> 8   0.8       60     60      61 0.2550859 #> 9   0.9       70     70      71 0.2550859"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"distrib_group_continuous-distribution-dune-variable-continue-par-groupe","dir":"Articles","previous_headings":"Présentation des différentes fonctions","what":"distrib_group_continuous() : distribution d’une variable continue par groupe","title":"Manuel d'utilisation","text":"distrib_group_continuous(), avec distrib_group_c() comme alias, calcule la distribution d’une variables continue selon les modalités d’une variable qualitative, que l’peut considérer comme des groupes. Comme pour distrib_continous(), la fonction produit une liste contenant un graphique (graph), une densité (dens), une table (tab), les quantiles retenus (quant). trouve aussi une boite à moustache (moustache) qui indique les bornes dans lesquelles trouve différentes proportions de la population autour de la médiane (par défaut : 50%, 75% et 95% - les proportions peuvent être paramétrées dans l’argument moustache_probs). Un test statistique est aussi implémenté. Comme pour central_group(), si l’utilisateur choisi de calculer la médiane (le choix par défaut), le test statistique effectué est celui de Kruskal Wallis ; s’il ou elle choisi de calculer la moyenne, test statistique effectué est un test de Wald. L’exemple ci-dessous compare la distribution des revenus équivalents selon le statut socio-économique. Comme pour central_group(), il est possible d’utiliser une expression quantitative au lieu d’une variable. Ici, c’est le revenu équivalent annuel divisé par 12 qui est retenu pour qu’il soit exprimé en montant mensuel.","code":"distrib_income <- distrib_group_c(eusilc,   pl030_rec,   eqIncome / 12,   type = \"mean\",   limits = c(0, 4100),   bw = .7 ) distrib_income$graph distrib_income$tab #> # A tibble: 7 × 8 #>   pl030_rec            mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <chr>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domesti… 1304.    1264.    1344.     1207       1207          1142. #> 2 Permanently disabl… 1349.    1222.    1476.      178        178           152. #> 3 Retired             1735.    1703.    1767.     3146       3146          3048. #> 4 Student             1371.    1314.    1429.      736        736           684. #> 5 Unemployed          1476.    1401.    1551.      518        518           474. #> 6 Working full time   1888.    1864.    1912.     5162       5162          5048. #> 7 Working part time   1604.    1558.    1650.     1160       1160          1096. #> # ℹ 1 more variable: n_weighted_upp <dbl> head(distrib_income$dens) #>               group         x            y quantFct     y_ridges central #> 1 Working part time -283.5941 7.063720e-08        1 6.673599e-05    <NA> #> 2 Working part time -266.6236 1.192821e-07        1 1.126943e-04    <NA> #> 3 Working part time -249.6530 1.958639e-07        1 1.850466e-04    <NA> #> 4 Working part time -232.6824 3.129800e-07        1 2.956944e-04    <NA> #> 5 Working part time -215.7118 4.870855e-07        1 4.601843e-04    <NA> #> 6 Working part time -198.7413 7.497099e-07        1 7.083042e-04    <NA> head(distrib_income$quant) #>   probs quantile    ci.2.5   ci.97.5             group #> 1   0.1  774.170  729.3306  823.6833 Working part time #> 2   0.2 1016.212  978.0693 1057.4755 Working part time #> 3   0.3 1186.148 1148.6437 1235.4963 Working part time #> 4   0.4 1339.096 1292.6704 1375.1817 Working part time #> 5   0.5 1476.866 1435.1671 1534.5294 Working part time #> 6   0.6 1642.664 1595.5897 1686.8407 Working part time head(distrib_income$moustache) #> # A tibble: 6 × 4 #>   group             moustache_prob xbegin  xend #>   <chr>             <chr>           <dbl> <dbl> #> 1 Working part time 0.95             436. 3496. #> 2 Working part time 0.8              774. 2517. #> 3 Working part time 0.5             1113. 1974. #> 4 Working full time 0.95             734. 4019. #> 5 Working full time 0.8             1008. 2909. #> 6 Working full time 0.5             1315. 2241."},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"tableau-récapitulatif-des-arguments","dir":"Articles","previous_headings":"","what":"Tableau récapitulatif des arguments","title":"Manuel d'utilisation","text":"Comme nous l’avons vu, la majorité des fonctions de fonctionr se ressemblent. La plupart des arguments se retrouvent dans plusieurs fonctions. Le tableau ci-dessous reprend la totalité des argument en indiquant chaque fois pour quelle(s) fonction(s) il est utilisé. L’ordre repris est celui des fonctions et les couleurs regroupent les arguments selon leur “catégorie”. Cette dernière une visée pédagogique et regroupe ensemble des arguments dont le rôle est similaire. Dans la suite, nous aborderons successivement les arguments liés à la base de donnée utilisée, les arguments indispensables qui doivent obligatoirement être mentionnés, les arguments clés (c’est-à-dire pas obligatoire mais ayant une influence sur les résultats) et les arguments esthétiques - qui influencent le graphique.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-liés-à-la-base-de-données-utilisée","dir":"Articles","previous_headings":"","what":"Les arguments liés à la base de données utilisée","title":"Manuel d'utilisation","text":"data est bien entendu un argument fondamental car il indique la base de donnée à utiliser. Comme l’objectif du package est de permettre une analyse des sondages complexes, il peut s’agir d’un objet survey ou d’un objet srvyr, qui contiennent les différentes informations sur le plan de sondage (poids, strates, PSU…). Il est possible que l’objet survey ou srvyr soit un objet avec avec des replicate weights pour utiliser les méthodes de rééchantillonnage pour estimer la variance d’échantillonnage. Il est également possible que data soit un dataframe. Dans ce cas, si aucune autre précision n’est apportée, les fonctions font l’hypothèse d’un sondage aléatoire simple. Ainsi, fonctionr peut être utilisé pour l’analyse des sondages complexes mais aussi des sondages aléatoires simple. Mais fonctionr peut créer un objet de sondage complexe à partir d’un dataframe. Les arguments définissant le design de l’enquête (poids, strates, etc.) doivent alors être indiqués dans l’argument … (dot-dot-dot). Cette manière de procéder fonctionne pour les sondages complexes classiques mais pas pour les sondages complexes intégrant des replicate weights. Si l’ont veut intégrer des replicates weights, il est nécessaire de créer d’abord un objet survey ou srvyr et d’utiliser cet objet dans fonctionr. Les exemples ci-dessous montrent trois manière différentes de prendre en compte un même plan de sondage : en l’indiquant directement dans la fonction de fonctionr, en créant d’abord un objet survey et en créant d’abord un objet srvyr.","code":"library(survey) library(srvyr)  # Un exemple où on indique directement dans la fonction de fonctionr les différents éléments du plan de sondage eusilc_prop_1 <- prop_group(eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   strata = db040,   ids = db030,   weights = rb050,   title = \"dataframe\" )  # Un exemple où utilise un objet survey eusilc_survey <- svydesign(id = ~db030, strat = ~db040, weight = ~rb050, data = eusilc) eusilc_prop_2 <- prop_group(eusilc_survey,   group = pl030_rec,   prop_exp = py090n > 0,   title = \"survey object\",   ylab = \"\",   wrap_width_y = 15 )  # Un exemple où utilise un objet srvyr eusilc_srvyr <- as_survey_design(eusilc, ids = db030, strata = db040, weights = rb050) eusilc_prop_3 <- prop_group(eusilc_srvyr,   group = pl030_rec,   prop_exp = py090n > 0,   title = \"srvyr object\",   ylab = \"\",   wrap_width_y = 15 ) eusilc_prop_1$graph | eusilc_prop_2$graph | eusilc_prop_3$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-indispensables","dir":"Articles","previous_headings":"","what":"Les arguments indispensables","title":"Manuel d'utilisation","text":"Les arguments indispensable sont des arguments qui sont nécessaire au bon fonctionnement des fonctions et qui ne peuvent prendre aucune valeur par défaut. Ces arguments sont principalement de différents types : variables qualitatives, expressions ou listes de variables. Les variables/colonnes sont toujours indiquées sans guillemets, à la manière de la syntaxe du tidyverse. group et quali_var sont des variables qualitatives qui indiquent les groupes ou variables qualitative dont veut calculer la distribution. Les variables indiquées pour ces arguments sont transformées en facteurs pour leur usage dans la fonction. prop_exp et quanti_exp sont des expressions qui permettent de calculer les proportions ou tendances centrales. Ces arguments peuvent être des variables (une variable binaire 0-1 pour prop_exp et une variable numérique pour quanti_exp) ou une expression qui produit une variable (binaire pour prop_exp et quantitative pour quanti_exp). Ainsi, il n’est pas nécessaire de préparer à l’avance les variables binaire ou la quantitative, elles peuvent être calculées “à la volée”. Précisons que seuls les variables de la base de données, les opérateurs et les valeurs numérique sont autorisés dans les expressions ; les objets extérieurs (par exemple un seuil contenu dans un vecteur stocké dans l’environnement global) ne sont pas autorisés. list_vars doit être un vecteur reprenant l’ensemble des variables reprises dans les fonctions many_val() et many_val_group() ainsi que leurs alias. Pour many_prop() et many_prop_group(), les variables doivent être binaires (il aurait été trop compliqué d’introduire ici des expressions) et pour many_mean(), many_mean_group(), many_median() et many_median_group(), les variables doivent être numériques. L’argument list_vars_lab permet d’indiquer le label pour les variables à l’aide d’un vecteur. Bien qu’il ne s’agisse pas d’un argument indispensable, nous l’avons placé juste après list_vars pour faciliter l’utilisation des fonctions. Pour cet argument, les guillemets doivent être utilisé pour indiquer les labels des variables. Dans l’exemple ci-dessous, calcule la proportion des répondant qui travaillent et dont le salaire net annuel était inférieur à 12000€. peut ainsi introduire des expressions complexe dans les fonctions.","code":"eusilc_prop_NA_excl <- prop_group(eusilc,   group = rb090,   prop_exp = (pl030 == \"1\" | pl030 == \"2\") & py010n < 12000,   weights = rb050,   title = \"% of the population that works and whose wage is less than 12000€ net\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop_NA_excl$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-clés-pas-obligatoires-mais-influençant-les-résultats","dir":"Articles","previous_headings":"","what":"Les arguments clés : pas obligatoires mais influençant les résultats","title":"Manuel d'utilisation","text":"Les arguments clés sont des arguments qui ne sont pas indispensable mais qui influencent les résultats. y retrouve plusieurs types d’arguments. facet est une variable qualitative qui produit des facettes dans le dataframe de résultats tab et dans le graphique ggplot2. Comme group et quali_var, la variable indiquée pour cet argument est transformée en facteur pour leur usage dans la fonction. Par défaut, les facettes ne sont pas produites. filter_exp est une expression qui permet de filtrer les données de manière à produire les résultats sur une partie de l’échantillon. Comme il s’agit d’une expression, il est possible de mettre en oeuvre des conditions de filtres complexe et multiples, par exemple sélectionner uniquement les personnes âgées de moins de 60 ans, dont le revenu mensuel est inférieur à 3000€ et qui sont célibataires. Si une possibilité de filtrage est inclue dans les fonctions, c’est pour que le filtrage des données soit réalisé après la définition du plan de sondage, afin que le filtrage ne modifie pas celui-ci4. Ici aussi, seules les variables de la base de données, les opérateurs et les valeurs numérique sont autorisés dans les expressions. prop_method est un argument qui permet de choisir le type de correction pour l’estimation des intervalles de confiance d’une proportion, notamment pour éviter d’avoir des bornes inférieures à 0 ou supérieures à 1. Les valeurs peuvent prendre celles mentionnées dans l’argument method de svyciprop() du package survey5. Par défaut, c’est la méthode \"beta\" qui est utilisée. quantiles est un argument qui permet de choisir, sous forme d’un vecteur, les quantiles à calculer et à indiquer sur le graphique dans distrib_continuous() et distrib_group_continuous(). Par défaut, ce sont des déciles qui sont calculés.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"le-traitement-des-na","dir":"Articles","previous_headings":"Les arguments clés : pas obligatoires mais influençant les résultats","what":"Le traitement des NA","title":"Manuel d'utilisation","text":"Nous expliquons ici plus précisément le traitement des NA dans les fonctions, car les possibilités sont multiples. Nous avons décidé de laisser des possibilités différentes selon les variables dans lesquelles se trouvent les NA : groupes, variables d’intérêts, expressions, etc. na.rm.group, na.rm.facet, na.rm.var indiquent respectivement la manière dont les éventuels NA dans les variables group, facet et dans quali_var sont traités. Si l’argument est TRUE, les NA sont retirés dans les calculs. Si l’argument est FALSE, une modalité spécifique est créée pour les NA. Dans ce cas, ils prennent toujours la couleur gris clair sur le graphique, pour pointer leur spécificité. Dans le cas où ils sont retirés, ils ne sont pas pris en compte pour calculer le total, le cas échéant. Par défaut, l’argument prend la valeur FALSE, c’est-à-dire que les NA sont supprimés des analyses. Dans l’exemple ci-dessous, compare la distribution des statuts socio-professionnels entre régions, en y ajoutant une modalité NA pour le statut (il s’agit des personnes de moins de 16 ans qui ne sont pas interrogées), en filtrant les données pour ne conserver que les personnes de plus de 11 ans et introduisant la variable sexe comme facette. Comme nous le verrons, la couleur des NA est toujours grise et ne dépend pas de la palette de couleur, de manière à les identifier spécifiquement.  na.prop indique la manière dont les éventuels NA sont traités dans les variables introduites dans prop_exp. Si l’argument prend la valeur \"rm\", tous les NA présents dans au moins une des variable faisant partie de prop_exp sont exclus avant de procéder aux calculs. De cette manière, la proportion est calculée uniquement sur les observations “valides”. Dans ce cas, pour des raisons évidentes, il n’est pas possible d’utiliser la fonction .na() dans prop_exp (ne peut pas calculer la proportion de personnes dont le statut professionnel est NA si supprimé les NA). Si l’argument prend la valeur \"include\", les NA ne sont pas retirés avant de procéder aux calculs et la proportion est calculée sur l’ensemble des observations, NA compris. Cela peut être utile quand les NA n’indiquent pas une valeur manquante mais une situation spécifique. Par exemple, dans une variable mesurant les points obtenu par des étudiants à un examen, le NA peut indiquer que l’étudiant était absent ; peut donc vouloir calculer la proportion d’étudiants ayant au moins 12/20 en conservant les absents au dénominateur, ce qui est possible avec na.prop = \"include\". Par défaut, na.prop prend la valeur \"rm\". Précisons que pour central_group() et ses alias mean_group() et median_group(), il n’y pas d’argument permettant de choisir le traitement des NA dans quanti_exp. Les observations comprenant au moins un NA dans une variable indiquée dans quanti_exp sont automatiquement exclues des calculs, car il n’y pas d’autres possibilité qui soit pertinente. Les deux graphiques ci-dessous comparent la part de travailleurs selon le sexe en excluant ou en incluant les NA. Les taux du second graphique sont plus faible, car dans celui-ci les personnes n’ayant pas de statut socio-professionnel (ex. les enfants) sont comptabilisés dans le dénominateur.  na.vars indique la manière dont les NA doivent être traités dans les différentes variables de many_val() et many_val_group(). Si l’argument prend la valeur \"rm\", les NA sont exclus séparément dans chaque variable. Il en résulte que l’échantillon ne sera pas toujours le même pour chacune des variables calculées, mais conserve un maximum d’observations. Si l’argument prend la valeur \"rm.\", les observations qui comprennent au moins un NA dans n’importe quelle des variables de list_vars sont exclues. Cette manière de procéder exclut plus d’observations mais permet d’avoir un échantillon identique pour toutes les variables. Par défaut, na.vars prend la valeur \"rm\".","code":"eusilc_dist_group_d <- distrib_group_d(eusilc,   group = db040,   quali_var = pl030_rec,   na.rm.var = FALSE,   facet = rb090,   filter_exp = age > 11,   weights = rb050,   title = \"Distribution of socio-economic status according to region and gender\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_group_d$graph eusilc_prop_NA_excl <- prop_group(eusilc,   group = rb090,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   na.prop = \"rm\",   title = \"% workers (NA excluded)\" )  eusilc_prop_NA_incl <- prop_group(eusilc,   group = rb090,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   na.prop = \"include\",   title = \"% workers (NA included)\" ) eusilc_prop_NA_excl$graph | eusilc_prop_NA_incl$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-arguments-esthétiques","dir":"Articles","previous_headings":"","what":"Les arguments esthétiques","title":"Manuel d'utilisation","text":"Les arguments esthétiques sont des arguments qui affectent uniquement le graphique produit et pas la table, ni le test statistique. Pour des raisons pédagogique, nous aborderons successivement les arguments d’esthétique de base, d’esthétique graphique, d’esthétique des chiffres, d’esthétique des lettres et les labels.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-de-base","dir":"Articles","previous_headings":"Les arguments esthétiques","what":"L’esthétique de base","title":"Manuel d'utilisation","text":"reorder est un argument qui, en prenant la valeur TRUE, permet de réordonner les catégories selon leur valeur décroissante. Si reorder = FALSE, les catégories ne sont pas réordonnées et c’est l’ordre des levels de la variable qui est utilisé si c’est un facteur, ou l’ordre alphabétique si c’est une variable string. La catégorie NA - quand elle existe (par exemple avec na.rm.group = FALSE) - et la catégorie “Total” ne sont jamais réordonnées et sont toujours positionnées dans le bas du graphique. En cas de facettes, les catégories sont réordonnées sur base de chaque catégorie médiane. Par exemple, si l’utilise des facettes dans prop_group(), la fonction identifie, pour chaque groupe, quelle est la proportion médiane par groupe et puis elle va ordonner les groupes sur bases de ces médianes. Par défaut, reorder prend la valeur de FALSE. reorder n’est pas disponible dans distrib_group_discrete() et many_val_group() ainsi que ses alias (many_prop_group(), many_mean_group() et many_median_group()), car il y plusieurs proportions ou indicateurs et il est difficile de choisir sur lequel ou laquelle réordonner. Dans l’exemple ci-dessous, les revenus moyens des statut socio-économique sont réordonnés. Comme il y des facettes, c’est le médian de chaque catégorie qui est utilisée pour construire. Par exemple, la catégorie “Permanently disabled” se situe en troisième position, car sa valeur médiane (15199€) se entre entre le médian de la catégorie “Student” (15097€) et de la catégorie “Working part time” (16511€).  position est un argument qui ne se trouve uniquement dans many_val_group() et qui peut prendre les valeurs de \"dodge\" et de \"stack\". Avec \"dodge\", les barres ne sont pas empilées. Avec \"stack\", les barres sont empilées dans chaque groupe. Cette option peut avoir un intérêt quand les variables ont vocation à être additionnées, par exemple avec des revenus selon différentes sources qui peuvent former un revenu total. \"dodge\" est la valeur par défaut. Dans l’exemple ci-dessous, il est pertinent d’empiler les barres indiquant les différents revenus pour visualiser le revenu total. Cependant, dans ce cas, peut plus indiquer les intervalles de confiance sur le graphique.  show_ci, show_n, show_value et show_lab permettent de montrer ou cacher différents éléments sur le graphique avec les valeurs TRUE et FALSE : l’intervalle de confiance (show_ci), le nombre de personnes dans l’échantillon (show_n), l’estimation de l’indicateur (show_value) les titres et sous-titres du graphiques, des axes et de la légende (show_lab). Faute de représentation graphique adéquate, show_ci n’est pas un argument de la fonction distrib_group_discrete(). Pour cette fonction, il est pas possible de représenter les intervalles de confiance sur le graphique, mais ils sont bien calculé dans le dataframe tab. C’est aussi le cas pour many_val_group() et ses alias quand position = \"stack\". Précisons aussi que dans distrib_group_discrete(), seules les valeurs supérieures à 2% sont indiquées sur le graphique pour des raisons de lisibilité. Pour distrib_continuous() l’argument show_n indique les effectifs de l’échantillon pour chaque quantile. total_name indique le nom qui doit être mentionné à côté du résulat du total dans le graphique. Par défaut, il s’agit de “Total”, mais l’utilisateur peut indiquer autre chose de plus spécifique. Dans l’exemple ci-dessous, ne montre plus les intervalles de confiances, les valeurs de l’indicateur et les labels des titres, par contre montre le nombre de personnes dans l’échantillon et changé le nom du “Total”.  Certains arguments sont spécifiques aux fonctions distrib_continous() et distrib_group_continous() : height indique la hauteur des courbes de densité dans distrib_group_continuous(). Une valeur plus élevée mènent à des courbes plus hautes qui peuvent éventuellement se chevaucher. La valeur par défaut est 0.8. limits indique les limites de l’axe des abscisses du graphique . Par défaut, il n’y pas de limites, ce qui revient à montrer sur le graphique la totalité de la distribution. Cependant, cela peut poser problème pour des distributions asymétriques avec quelques valeurs extrêmes, par exemple pour les variables de revenu. limits permet de zoomer sur la partie du graphique la plus intéressante qui reprend la majorité des observations. Précisons qu’il ne s’agit pas d’un filtre, mais d’un zoom : les déciles, valeurs centrales et moustaches sont toujours calculées sur l’ensemble de la distribution. En cas d’utilisation de zoom important, il est conseillé d’utiliser une résolution plus élevée. noter que lorsque show_n = TRUE pour distrib_continous(), n’indique pas les effectifs pour les quantiles qui ne sont pas complètement représentés quand utilise l’argument limits. D’autres arguments de type show_* sont spécifiques à ces deux fonctions. C’est le cas de show_mid_line, show_ci_lines, show_ci_area, show_quant_lines qui se retrouvent dans les deux fonctions de distribution continue et show_mid_point, show_ci_errorbar et show_moustache qui sont spécifiques à distrib_group_continuous(). show_mid_point et show_mid_line permettent de montrer la valeur centrale, médiane ou moyenne, sous la forme d’un point ou d’une ligne. show_ci_errorbar, show_ci_lines et show_ci_area permettent de montrer l’intervalle de confiance de la valeur centrale sous la forme d’une barre d’erreur de lignes en pointillée ou d’une aire colorée. show_quant_lines permet de tracer des lignes pour les valeurs des quantiles sur le graphique. show_moustache permet de montrer la boite à moustache. Par défaut, distrib_continuous() indique la la valeur centrale par une ligne et ses intervalles de confiance par des lignes pointillées et ne trace pas de ligne pour les quantiles. Par défaut, distrib_group_continuous() indique les valeurs centrales par des points et leurs intervalles de confiance par des barres d’erreurs, et ne dessine pas d’autres éléments que la moustache sur le graphique . Dans l’exemple ci-dessous, nous comparons les revenus du travail des travailleurs à temps partiel selon la région, en modifiant de nombreuses options graphiques. bw étant plus faible, la distribution est moins lissée et peut y observer des variations de densités plus locales. resolution étant plus faible, peut déceler les droites qui composent les courbes de densité. limits permet de se concentrer sur la plage de valeur (de -500€ à 3000€) qui contient la grande majorité des observations. height été défini pour que les aires de densité se chevauchent. Pour que ce chevauchement soit esthétique, alpha été réglé à .3 pour des aires transparentes et une bordure été ajoutée avec color = black. indiqué la médiane sous la forme d’une ligne. Ses intervalles de confiance sont indiqués par deux lignes en pointillées et une aire colorées. Les déciles sont indiqués par des lignes verticales grises et masqué la moustache. Notez que le revenu du travail mensuel est directement calculé dans l’expression en additionnant le salaire avec le revenu d’une activité indépendante avant de diviser le tout par 12.","code":"eusilc_mean_reorder <- mean_group(eusilc,   group = pl030_rec,   quanti_exp = eqIncome,   facet = pb220a,   weights = rb050,   reorder = TRUE,   unit = \"€\",   title = \"Mean of eq. income by status and nationality\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_mean_reorder$graph #Exemple avec Stack  eusilc_many_mean_group_2a <- many_mean_group(eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   position = \"stack\",   title = \"position = 'stack'\",   legend_ncol = 2 ) #Exemple avec dodge  eusilc_many_mean_group_2b <- many_mean_group(eusilc,   group = rb090,   list_vars = c(py010n, py050n, py090n),   list_vars_lab = c(\"salaires\", \"revenus d'une activité indépendant\", \"allocation de chômage\"),   weights = rb050,   position = \"dodge\",   title = \"position = 'dodge'\",   legend_ncol = 2 ) eusilc_many_mean_group_2a$graph | eusilc_many_mean_group_2b$graph eusilc_prop <- prop_group(eusilc,   group = db040,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   show_ci = FALSE,   show_n = TRUE,   show_value = FALSE,   show_lab = FALSE,   total_name = \"Total Austria\" ) eusilc_prop$graph distrib_income_2 <- distrib_group_c(eusilc,   db040,   (py010n + py050n) / 12,   filter_exp = pl030 == 2,   bw = .7,   resolution = 50,   height = 1.5,   limits = c(-500, 3000),   show_mid_point = F,   show_value = F,   show_mid_line = T,   show_ci_errorbar = F,   show_ci_lines = T,   show_ci_area = T,   show_quant_lines = T,   show_moustache = F,   color = \"black\",   pal = \"purple\",   alpha = .4 ) distrib_income_2$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-graphique","dir":"Articles","previous_headings":"Les arguments esthétiques","what":"L’esthétique graphique","title":"Manuel d'utilisation","text":"dodge indique l’épaisseur des barres et peut aller de 0 (barre invisible car d’épaisseur nulle) à 1 (barre se touchant car ne laissant aucun espace entre elles). La valeur par défaut est de 0.9. Les couleurs des barres peuvent être indiquées dans les arguments fill et pal. fill est utilisé pour les graphiques monochrome (prop_group(), central_group() et ses alias, distrib_discrete()). Les couleurs de base de R ou un code couleur hexadécimal peuvent être indiqués dans fill. pal est utilisé pour les graphiques avec plusieurs couleurs. pal doit reprendre le nom d’une palette des packages MetBrewer, MoMAColors ou PrettyCols. L’argument direction permet d’inverser le sens de la palette, en remplaçant le 1, par défaut, par -1 pour avoir le sens opposé. Pour many_val() et ses alias, pal peut aussi prendre une couleur unie (couleur de R ou code hexadécimal) si l’utilisateur souhaite un graphique monochrome. Les couleurs des NA et des totaux, quand ils sont présents sont toujours gris (grey) et gris foncé (grey40) et ne sont pas modifiable par les arguments fill ou pal. Par défaut, des couleurs ou des palettes de couleurs différentes ont été choisies pour chacune des fonctions, y compris les alias, pour éviter la confusion des graphiques. Dans l’exemple ci-dessous, utilise une autre palette de couleur et des barres plus fines.  Dans distrib_continuous() et distrib_group_continuous(), pal peut soit prendre la valeur d’une couleur, soit un vecteur reprenant plusieurs couleurs. Dans le cas d’une seule couleur, les graphiques seront monochrome, dans le cas de plusieurs couleurs, une palette de couleur est créée en passant par les différentes couleurs indiquées pour colorer les différents quantiles, la première couleur indiquant la coloration des premiers et derniers quantiles, et la dernière couleur indiquant la coloration du quantile central6. Précisons que le vecteur de pal doit être un vecteur de couleur de R ou de codes hexadécimaux, mais pas une des palettes des packages MetBrewer, MoMAColors ou PrettyCols utilisées dans pal pour les autres fonctions. Par défaut distrib_continuous() utilise un dégradé de bleu pour les quantiles et distrib_group_continuous() colorie les courbes de densité en gris, de manière à ne pas surcharger le graphique avec les quantiles. Ces deux fonction ont aussi l’argument color qui permet de définir la couleur de la ligne supérieure de la courbe de densité. Par défaut cette ligne n’est pas affichée. distrib_group_continuous() comprend aussi l’argument pal_moustache qui détermine les couleurs de la moustache et alpha qui détermine la transparence de la couleur de la densité. pal_moustache fonctionne comme pal et peut comprendre une couleur unie ou un vecteur de couleur. Mais logiquement, il n’est pas pertinent de représenter une moustache monochrome. Comme pour pour pal, il n’est pas nécessaire de définir chaque teinte de couleur individuellement, puisque la fonction produit une palette de couleur comprenant tous les dégradés nécessaires. alpha peut prendre une valeur allant de 0 (couleur totalement transparente et donc invisible) à 1 (couleur sans transparence). Avoir un certain degré de transparence est particulièrement utile si les différentes courbes se superposent (quand height est élevé). Dans l’exemple ci-dessous, utilise trois couleurs pour construire la palette qui va colorier l’aire de la densité et trace la courbe de densité en rouge.","code":"eusilc_dist_group_d <- distrib_group_d(eusilc,   group = db040,   quali_var = pl030_rec,   weights = rb050,   pal = \"VanGogh2\",   dodge = .5,   title = \"Distribution of socio-economic status according to region\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_dist_group_d$graph distrib_age_2 <- distrib_c(eusilc,   age,   type = \"mean\",   quantiles = seq(.05, .95, .05),   limits = c(10, 100),   color = \"red\",   pal = c(\"purple\", \"green3\", \"orange\"),   show_n = T ) distrib_age_2$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-des-chiffres","dir":"Articles","previous_headings":"Les arguments esthétiques","what":"L’esthétique des chiffres","title":"Manuel d'utilisation","text":"L’esthétique des chiffres concernent la manière dont l’estimation de l’indicateur est affichée sur le graphique. Ainsi, ces argument n’ont une utilité que si show_value = TRUE. scale est un argument qui n’est utilisé que dans les graphique exprimant des proportion. Il indique le dénominateur par lequel il faut interpréter le chiffre. Par défaut, scale = 100 pour interpréter les chiffres mentionnés en pourcentage. Par exemple peut donner une valeur de 1000 pour interpréter les chiffres en pour mille ou une valeur de 1 pour interpréter les chiffres comme de simple proportions. digits indique le nombre de décimales qui doivent être affichées pour les valeurs sur le graphique. Par défaut, digit = 0, ce qui conduit à ne pas afficher de décimales. unit indique l’unité à indiquer sur le graphique. Pour distrib_discrete(), prop_group(), many_prop() et many_prop_group(), par défaut unit = \"%\". Pour les autres fonction, par défaut unit = NULL, c’est-à-dire une absence d’unité indiquée sur le graphique. N’importe quel caractère ou chaîne de caractère peut être utilisée : \"€\", \"m²\", etc. dec indique le caractère qui doit être utilisé pour marqué la décimale dans les chiffes. Cet argument n’est utile que quand digits est supérieur à 0. Par défaut, dec = \",\", parce que la virgule est le caractère le plus utilisé pour marqué la décimale dans le monde francophone. Dans l’exemple ci-dessous, compare la proportion de travailleurs par région, mais en l’exprimant en pour mille et non en pour cent, en adaptant l’unité (\"‰\"), en conservant un chiffre après la virgule et en utilisant le point comme caractère pour la décimale et non la virgule.","code":"eusilc_prop <- prop_group(eusilc,   group = db040,   prop_exp = pl030 == \"1\" | pl030 == \"2\",   weights = rb050,   scale = 1000,   digits = 1,   unit = \"‰\",   dec = \".\",   title = \"Proportion of workers by region, in ‰\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop$graph"},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"lesthétique-des-lettres","dir":"Articles","previous_headings":"Les arguments esthétiques","what":"L’esthétique des lettres","title":"Manuel d'utilisation","text":"font indique la police qui est utilisée pour l’ensemble du texte dans le graphique. Actuellement trois polices sont directement incluses dans fonctionr : \"Roboto\", \"Montserrat\" et \"Gotham Narrow\". Par défaut, font = \"Roboto\". wrap_width_y et wrap_width_leg indiquent le nombre de caractères avant d’aller à la ligne, pour respectivement les différent labels de l’axe des ordonnées et les différents labels de la légende. Ces valeurs sont par défaut de 25 caractères. wrap_width_leg n’est présent que pour les graphiques ayant une légende : distrib_group_discrete() et many_val_group() et ses alias. Précisons aussi que le _y renvoie à l’axe des y tel qu’il est situé sur le graphique, après la transformation coord_flip() qui lieu dans les fonctions. Ainsi, il s’agit souvent des groupes, de la variable qualitative pour distrib_discrete() ou de la liste des variables pour many_val() et many_val_group() et leurs alias. legend_ncol indique le nombre maximum de colonnes dans la légende. Par défaut, il y quatre colonnes maximum. Le nombre de lignes dans la légende s’ajuste au nombre maximum de colonnes. legend_ncol n’est aussi présent que pour les graphiques ayant une légende : distrib_group_discrete() et many_val_group() et ses alias.","code":""},{"path":"https://jgires.github.io/fonctionr/articles/fonctionr_functions.html","id":"les-labels","dir":"Articles","previous_headings":"Les arguments esthétiques","what":"Les labels","title":"Manuel d'utilisation","text":"Les arguments de label ne sont utilisés que si show_lab = TRUE, qui est la valeur par défaut. Si show_lab = FALSE, aucun des labels ci-dessous n’est indiqué. title, subtitle, xlab, ylab, legend_lab et caption indiquent les textes à reprendre comme titre du graphique, sous-titre du graphique, titre de l’axe des abscisses, titre de l’axe des ordonnées, titre de la légende et de caption (la petite légende en bas à droite du graphique). Précisons que xlab et ylab font référence aux axes tels qu’ils sont situés sur le graphique, c’est-à-dire après la transformation coord_flip() qui lieu dans les fonctions. legend_lab n’est présent que pour les graphiques ayant une légende : distrib_group_discrete() et many_val_group() ainsi que ses alias. Le caption étant souvent déjà utilisé pour indiquer la p valeur du test statistique, l’utilisation de l’argument caption ajoute un texte en dessous de la mention de la p valeur du test statistique. Dans le cas où les arguments de label ne sont pas renseignés par l’utilisateur, il n’y pas de titre, pas de sous-titre et pas de caption (autre que la p valeur du test statistique). Par contre, xlab, ylab et, pour les graphiques avec légende, legend_lab indiquent par défaut les noms de la variable ou de l’expression qui est, pour xlab, précédé d’une précision sur la nature du calcul : “Moyenne : …”, “Distribution : …” Il est possible d’indiquer certains label et d’autres non, par exemple si l’souhaite un titre mais pas de sous-titre. Il suffit de ne compléter que les arguments de labels que l’souhaite voir écrits sur le graphique. Cependant, pour xlab, ylab et legend_lab, le label par défaut, basé sur le nom des variables, est alors écrit sur le graphique. Si l’souhaite avoir un label vide, il faut indiquer, respectivement, xlab = \"\", ylab =\"\" ou legend_lab = \"\". L’utilisation de xlab = NULL, ylab = NULL ou legend_lab = NULL conduira à l’écriture du label par défaut. Comme argument de label, peut aussi mentionner l’argument lists_vars_lab que l’déjà expliqué plus haut et qui peut être aussi considéré comme un label. Dans l’exemple ci-dessous, changé la police (Montserrat), mis à la ligne les labels de l’ordonnée à partir de 10 caractères et ceux de la légende à partir de 15 caractères et limité à trois colonnes pour la légende. également introduit manuellement les titres, sous-titres, caption et titre de légende, en conservant le label par défaut pour le titre de l’axe des abscisses et en n’ayant pas de titre pour l’axe des ordonnées.","code":"eusilc_dist_group_d <- distrib_group_d(eusilc,   group = db040,   quali_var = pl030_rec,   weights = rb050,   font = \"Montserrat\",   wrap_width_y = 10,   wrap_width_leg = 15,   legend_ncol = 3,   title = \"Distribution of socio-economic status according to region\",   subtitle = \"Example with austrian SILC data from 'laeken' package\",   ylab = \"\",   legend_lab = \"Status\",   caption = \"Source : EU-SILC\" ) eusilc_dist_group_d$graph"},{"path":"https://jgires.github.io/fonctionr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joel Gires. Author, maintainer. Francois Ghesquiere. Author.","code":""},{"path":"https://jgires.github.io/fonctionr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gires J, Ghesquiere F (2024). fonctionr: Package easy manipulation data complex design. https://jgires.github.io/fonctionr, https://github.com/jgires/fonctionr.","code":"@Manual{,   title = {fonctionr: Package for easy manipulation of data with complex design},   author = {Joel Gires and Francois Ghesquiere},   year = {2024},   note = {https://jgires.github.io/fonctionr, https://github.com/jgires/fonctionr}, }"},{"path":"https://jgires.github.io/fonctionr/index.html","id":"fonctionr-","dir":"","previous_headings":"","what":"Package for easy manipulation of data with complex design","title":"Package for easy manipulation of data with complex design","text":"fonctionr est un package R qui pour de produire facilement des statistiques descriptives complètes à partir de données individuelles issues de sondages avec un design complexe. Le package inclut des fonctions permettant de produire les résultats les plus usuels (comparaison de proportions, de moyennes, de médianes, de distributions), en tenant compte du plan d’échantillonnage réel grâce au package survey. fonctionr l’objectif de faciliter l’inférence statistique : outre des résultats descriptifs, le package produit des intervalles de confiance et des tests statistiques qui prennent en compte de design réel de l’enquête. fonctionr produit également des graphiques des résultats à l’aide de ggplot2, dans le de pouvoir intégrer directement et rapidement les résultats produits dans un rapport/une publication. Vous trouverez sur cette page une rapide introduction à fonctionr ; pour plus de détails, voir le manuel. Documentation : Pour comprendre plus en profondeur notre package et ses différentes possibilités, nous renvoyons l’utilisateur au Manuel d’utilisation qui constitue un manuel décrivant dans le détail les différentes fonctions de fonctionr. Note de développement : Cette version de fonctionr est encore une version de développement. Elle est néanmoins pleinement fonctionnelle et passé l’épreuve de nombreux tests, au cours desquels des solutions ont été apportées aux problèmes posés par des structures de données diverses. La mise à disposition publique du package nous permettra de bénéficier de retours plus larges concernant des problèmes que nous n’aurions pas anticipés. Néanmoins, dans un de continuité d’utilisation, la logique d’utilisation de fonctionr restera globalement la même. Seuls quelques éléments seront encore possiblement modifiés ou harmonisés dans un avenir proche (nom d’arguments, arguments supplémentaires…), sans que cela impacte l’utilisation du programme.","code":""},{"path":"https://jgires.github.io/fonctionr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Package for easy manipulation of data with complex design","text":"Vous pouvez installer le package fonctionr depuis GitHub. Pour cela, il vous faut d’abord installer et charger le package devtools :","code":"# Installer devtools si celui-ci n'est pas installé et charger le package install.packages(\"devtools\") library(devtools)  # Installer fonctionr devtools::install_github(\"jgires/fonctionr\")"},{"path":"https://jgires.github.io/fonctionr/index.html","id":"utilisation","dir":"","previous_headings":"","what":"Utilisation","title":"Package for easy manipulation of data with complex design","text":"Avant toute utilisation, il faut bien entendu charger le package : L’utilisation de fonctionr pour d’être simple. Pour nos exemples, nous utilisons les données de l’enquête SILC pour l’Autriche contenues dans le package laeken. Nous recodons d’abord la variable de statut économique pour la lisibilité des résultats : fonctionr comprend plusieurs fonctions pour réaliser facilement des opérations descriptives courantes. mean_group() permet par exemple de calculer des moyennes de revenu par groupe. Les groupes, ici de statut économique, sont indiqués dans l’argument group. C’est la moyenne du revenu mensuel qui est calculée, car peut indiquer soit une variable quantitative, soit une expression pour calculer celle-ci, directement dans l’argument quanti_exp (dans ce cas la variable eqIncome est divisée par 12 à la volée). Le design de l’enquête SILC est pris en considération, puisque l’peut indiquer les clusters (ids), les strates (strata) et les poids (weight) dans la fonction. Les intervalles de confiance et un test de différence des moyennes sont calculés en conséquence. La fonction produit une liste encapsulant plusieurs résultats dans des objets différents. L’objet tab comprend un data.frame avec les résultats au format tidy : L’objet test.stat comprend les résultats d’un test d’hypothèse prenant en compte le design de l’enquête. Le test pratiqué est dépendant de la statistique calculée. Dans le cas de mean_group(), il s’agit d’une ANOVA avec comme hypothèse nulle l’égalité entre les moyennes de tous les groupes : L’objet graph comprend un graphique ggplot présentant les résultats et prêt à être inséré dans une publication :  fonctionr comprend plusieurs autres fonctions pour réaliser des opérations similaires, par exemple pour calculer des proportions par groupe avec la fonction prop_group(). peut à nouveau indiquer directement une expression à partir de laquelle calculer les proportions dans l’argument prop_exp : dans ce cas la proportion à recevoir des revenus du chômage (py090n supérieurs à 0). Le résultat contient à nouveau un tableau, le résultat d’un test d’hypothèse et un graphique ggplot. Dans le cas de prop_test(), le test d’hypothèse est un khi2 avec comme hypothèse nulle l’égalité de toutes les proportions.","code":"library(fonctionr) # Loading of data data(eusilc, package = \"laeken\")  # Creation of categories of economic status eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\" eusilc_mean <- mean_group(   eusilc,   group = pl030_rec,   quanti_exp = eqIncome / 12,   strata = db040,   ids = db030,   weight = rb050,   reorder = T,   title = \"Mean of equivalised income in household by status of individuals\",   subtitle = \"Example with austrian SILC data from 'laeken' package\",   ) eusilc_mean$tab #> # A tibble: 8 × 8 #>   pl030_rec            mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domesti… 1296.    1253.    1338.     1207    640311.        605978. #> 2 Permanently disabl… 1330.    1202.    1458.      178    104930.         85796. #> 3 Retired             1720.    1681.    1758.     3146   1806954.       1746273. #> 4 Student             1355.    1291.    1419.      736    395829.        365532. #> 5 Unemployed          1456.    1380.    1532.      518    303252.        276953. #> 6 Working full time   1895.    1864.    1926.     5162   2869868.       2797833. #> 7 Working part time   1591.    1542.    1639.     1160    636121.        600709. #> 8 Total               1703.    1679.    1726.    12107   6757264.       6683738. #> # ℹ 1 more variable: n_weighted_upp <dbl> eusilc_mean$test.stat #> Wald test for pl030_rec #>  in svyglm(formula = fmla, design = data_W) #> F =  141.5453  on  6  and  5985  df: p= < 2.22e-16 eusilc_mean$graph eusilc_prop <- prop_group(   eusilc,   group = pl030_rec,   prop_exp = py090n > 0,   strata = db040,   ids = db030,   weight = rb050,   reorder = T,   title = \"Proportion of individuals receiving income from unemployment in their household\",   subtitle = \"Example with austrian SILC data from 'laeken' package\" ) eusilc_prop$tab #> # A tibble: 8 × 11 #>   pl030_rec                   prop prop_low prop_upp n_sample n_true_weighted #>   <fct>                      <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 Fulfilling domestic tasks 0.0485   0.0369   0.0624     1207          31048. #> 2 Permanently disabled      0.209    0.148    0.282       178          21975. #> 3 Retired                   0.0177   0.0134   0.0229     3146          31988. #> 4 Student                   0.0194   0.0106   0.0323      736           7666. #> 5 Unemployed                0.732    0.690    0.770       518         221878. #> 6 Working full time         0.0818   0.0741   0.0899     5162         234629. #> 7 Working part time         0.110    0.0921   0.130      1160          69869. #> 8 Total                     0.0916   0.0863   0.0971    12107         619054. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl> eusilc_prop$test.stat #>  #>  Pearson's X^2: Rao & Scott adjustment #>  #> data:  NextMethod() #> F = 475.2, ndf = 5.9608, ddf = 35711.0201, p-value < 2.2e-16 eusilc_prop$graph"},{"path":"https://jgires.github.io/fonctionr/index.html","id":"auteurs","dir":"","previous_headings":"","what":"Auteurs","title":"Package for easy manipulation of data with complex design","text":"Joël Girès est sociologue et travaille à l’Observatoire de la Santé et du Social de la Région de Bruxelles-Capitale. François Ghesquière est sociologue et travaille à l’Institut wallon de l’évaluation, de la prospective et de la statistique. Nous sommes ouverts à toute remarque afin d’améliorer notre package.","code":""},{"path":[]},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":null,"dir":"Reference","previous_headings":"","what":"central_group — central_group","title":"central_group — central_group","text":"Function compare means medians different groups complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"central_group — central_group","text":"","code":"central_group(   data,   group,   quanti_exp,   type,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   reorder = F,   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   total_name = \"Total\",   digits = 0,   unit = \"\",   dec = \",\",   fill = NULL,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   export_path = NULL )  median_group(..., type = \"median\")  mean_group(..., type = \"mean\")"},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"central_group — central_group","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. quanti_exp expression define variable mean/median computed. type \"mean\" compute mean group ; \"median\" compute median group. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable NA facet variable, applicable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included quanti_exp affected argument. observation NA variables included quanti_exp always excluded. Default TRUE. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. reorder TRUE want reorder groups according mean/median. NA value, case na.rm.group = FALSE, included reorder. show_ci TRUE want show error bars graphic. FALSE want show error bars. Default TRUE. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show mean/median group graphic. FALSE want show mean/median. Default TRUE. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. total_name Name total bar graphic. Default Total. digits Numbers digits showed value labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". fill Colour bars. NA bar, case na.rm.group = FALSE, total bar always grey. dodge Width bar, 0 1.Default 0.9. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line labels groups. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Moyenne : \" + quanti_exp \"Médianne : \" + quanti_exp. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". caption Caption graphic. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"central_group — central_group","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/central_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"central_group — central_group","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Creation of age categories eusilc$age_cat <- cut(eusilc$age, breaks = 6, include.lowest = TRUE)  # Calculation of income means by age category with fonctionr, taking sample design into account eusilc_mean <- mean_group(   eusilc,   group = age_cat,   quanti_exp = eqIncome / 12,   strata = db040,   ids = db030,   weight = rb050,   title = \"Mean of equivalised income in household by age of individuals\",   subtitle = \"Example with austrian SILC data from 'laeken' package\"   ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 #> Variable(s) détectée(s) dans quanti_exp : eqIncome #> 0 lignes supprimées avec valeur(s) manquante(s) pour le(s) variable(s) de quanti_exp eusilc_mean$graph"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_continuous — distrib_continuous","title":"distrib_continuous — distrib_continuous","text":"Function describe continuous variable complex survey data","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_continuous — distrib_continuous","text":"","code":"distrib_continuous(   data,   quanti_exp,   type = \"median\",   facet = NULL,   filter_exp = NULL,   ...,   na.rm.facet = TRUE,   quantiles = seq(0.1, 0.9, 0.1),   bw = 1,   resolution = 1024,   limits = NULL,   show_mid_line = TRUE,   show_ci_lines = TRUE,   show_ci_area = FALSE,   show_quant_lines = FALSE,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   digits = 0,   unit = \"\",   dec = \",\",   pal = c(\"#00708C\", \"mediumturquoise\"),   color = NA,   font = \"Roboto\",   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   export_path = NULL )  distrib_c(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_continuous — distrib_continuous","text":"data dataframe object survey package object srvyr package. quanti_exp expression define variable described. type \"mean\" compute mean central value ; \"median\" compute median central value. facet supprimer? filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.facet supprimer? quantiles quantiles computed distribution. Default deciles. bw smoothing bandwidth used. kernels scaled standard deviation smoothing kernel. Default 1. resolution Resolution density curve. Default 1024. limits Limits x axe graphic. apply computation. Default NULL show entire distribution graphic. show_mid_line TRUE want show mean median (depending type) line graphic. FALSE want show . Default TRUE. show_ci_lines TRUE want show confidence interval mean median (depending type) lines graphic. FALSE want show lines. Default TRUE. show_ci_area TRUE want show confidence interval mean median (depending type) coloured area graphic. FALSE want show area. Default FALSE. show_quant_lines TRUE want show quantiles lines graphic. FALSE want show lines. Default FALSE. show_n TRUE want show graphic number individuals sample quantile FALSE want show numbers. Default FALSE. show_value TRUE want show mean/median (depending type) graphic. FALSE want show mean/median. Default TRUE. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. digits Numbers digits showed value labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal color density area. maybe one color vector several colors. color color density line. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Moyenne : \" + quanti_exp \"Médianne : \" + quanti_exp. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". caption Caption graphic. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_continuous — distrib_continuous","text":"list contains table (tab), graphic (garph) density table (dens) quantile table (quant)","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_discrete — distrib_discrete","title":"distrib_discrete — distrib_discrete","text":"Function describe distribution discrete variable complex survey data. produces table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_discrete — distrib_discrete","text":"","code":"distrib_discrete(   data,   quali_var,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.facet = TRUE,   na.rm.var = TRUE,   probs = NULL,   prop_method = \"beta\",   reorder = FALSE,   show_ci = TRUE,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   scale = 100,   digits = 0,   unit = \"%\",   dec = \",\",   fill = \"sienna2\",   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   export_path = NULL )  distrib_d(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_discrete — distrib_discrete","text":"data dataframe object survey package object srvyr package. quali_var discrete variable described. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.facet TRUE want remove observations NA facet variable. FALSE want create facet NA value facet variable. Default TRUE. na.rm.var TRUE want remove observations NA discrete variable. FALSE want create modality NA value discrete variable. Default TRUE. probs Vector probabilities H0 statistical test, correct order (rescaled sum 1). probs = NULL, statistical test performed. Default NULL. prop_method Type proportion method use compute confidence intervals. See svyciprop survey package details. Default beta method. reorder TRUE want reorder categories according proportion. NA value, case na.rm.group = FALSE, included reorder. Default FALSE. show_ci TRUE want show error bars graphic. FALSE want show error bars. Default TRUE. show_n TRUE want show graphic number individuals sample modality quali_var. FALSE want show number. Default FALSE. show_value TRUE want show proportion category graphic. FALSE want show proportion. Default TRUE. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\". fill Colour bars. NA bar, case na.rm.group = FALSE, total bar always grey. dodge Width bar, 0 1. Default 0.9. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line labels categories. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Distribution (total : 100 percent)\". show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), Y variable data. ylab = NULL, Y label graphic quali_var. show Y label, use ylab = \"\". caption Caption graphic. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test (probs NULL).","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_discrete — distrib_discrete","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"distrib_discrete — distrib_discrete","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_dist_group_d <- distrib_d( eusilc, pl030_rec, strata = db040, ids = db030, weight = rb050, title = \"Distribution of socio-economic status\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 eusilc_dist_group_d$graph  eusilc_dist_group_d$tab #> # A tibble: 7 × 8 #>   pl030_rec            prop prop_low prop_upp n_sample n_weighted n_weighted_low #>   <fct>               <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 Fulfilling domest… 0.0948   0.0899   0.0998     1207    640311.        605978. #> 2 Permanently disab… 0.0155   0.0129   0.0186      178    104930.         85796. #> 3 Retired            0.267    0.258    0.277      3146   1806954.       1746273. #> 4 Student            0.0586   0.0544   0.0630      736    395829.        365532. #> 5 Unemployed         0.0449   0.0411   0.0489      518    303252.        276953. #> 6 Working full time  0.425    0.416    0.434      5162   2869868.       2797833. #> 7 Working part time  0.0941   0.0890   0.0995     1160    636121.        600709. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_group_continuous — distrib_group_continuous","title":"distrib_group_continuous — distrib_group_continuous","text":"Function compare means medians different groups complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_group_continuous — distrib_group_continuous","text":"","code":"distrib_group_continuous(   data,   group,   quanti_exp,   type = \"median\",   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = TRUE,   na.rm.facet = TRUE,   quantiles = seq(0.1, 0.9, 0.1),   moustache_probs = c(0.95, 0.8, 0.5),   bw = 1,   resolution = 512,   height = 0.8,   limits = NULL,   reorder = FALSE,   show_mid_point = TRUE,   show_mid_line = FALSE,   show_ci_errorbar = TRUE,   show_ci_lines = FALSE,   show_ci_area = FALSE,   show_quant_lines = FALSE,   show_moustache = TRUE,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   digits = 0,   unit = \"\",   dec = \",\",   pal = \"#e0dfe0\",   pal_moustache = c(\"#EB9BA0\", \"#FAD7B1\"),   color = NA,   alpha = 1,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   export_path = NULL )  distrib_group_c(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_group_continuous — distrib_group_continuous","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. quanti_exp expression define variable variable described. type Type central value : \"mean\" compute mean central value group ; \"median\" compute median central value group.. facet supprimer? filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable. FALSE want create group NA value group variable. NA variables included quanti_exp affected argument. observation NA variables included quanti_exp excluded. na.rm.facet Argument à supprimer? quantiles Quantiles computed distributions. Default deciles. moustache_probs vector defining proportions population used draw moustache. Default 0.95, 0.8, 0.5 draw moustache three groups containing respectively 50 percent, 80 percent 95 percent population closest median. bw smoothing bandwidth used. kernels scaled standard deviation smoothing kernel. Default 1. resolution Resolution density curve. Default 512 height Height curves. Default 0.8 limits Limits x axe graphic. apply computation. Default NULL show entire distribution graphic. reorder TRUE want reorder groups according mean/median (depending type). NA value, case na.rm.group = FALSE, included reorder (VERIFIER). show_mid_point TRUE want show mean median (depending type) point graphic. FALSE want show . Default TRUE. show_mid_line TRUE want show mean median (depending type) line graphic. FALSE want show . Default FALSE show_ci_errorbar TRUE want show confidence interval mean median (depending type) error bar graphic. FALSE want show lines. Default TRUE. show_ci_lines TRUE want show confidence interval mean median (depending type) lines graphic. FALSE want show lines. Default FALSE show_ci_area TRUE want show confidence interval mean median (depending type) coloured area graphic. FALSE want show area. Default FALSE. show_quant_lines TRUE want show quantiles lines graphic. FALSE want show lines. Default FALSE. show_moustache TRUE want show moustache graphic. FALSE want show . Default TRUE. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show mean/median group graphic. FALSE want show mean/median. Default TRUE. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. digits Numbers digits showed value labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal Color density areas. Can one sereval colors create palette. pal_moustache Color moustache. Can one sereval colors create palette. color Color density curve. one color. alpha Transparence density curve. Default 1. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line labels groups. Default 25 title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers X label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic \"Moyenne : \" + quanti_exp \"Médianne : \" + quanti_exp. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers Y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". caption Caption graphic. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_group_continuous — distrib_group_continuous","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"distrib_group_discrete — distrib_group_discrete","title":"distrib_group_discrete — distrib_group_discrete","text":"Function describe distribution discrete variable different groups. can use complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"distrib_group_discrete — distrib_group_discrete","text":"","code":"distrib_group_discrete(   data,   group,   quali_var,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   na.rm.var = T,   prop_method = \"beta\",   show_value = TRUE,   show_lab = TRUE,   scale = 100,   digits = 0,   unit = \"\",   dec = \",\",   pal = \"Hokusai1\",   direction = 1,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   wrap_width_leg = 25,   legend_ncol = 4,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   legend_lab = NULL,   caption = NULL,   export_path = NULL )  distrib_group_d(...)"},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"distrib_group_discrete — distrib_group_discrete","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. quali_var discrete variable described different groups. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove NAs quali_var, group facet. FALSE want create NA categories quali_var, group facet. Default TRUE. na.rm.facet TRUE want remove observations NA facet variable. FALSE want create facet NA value facet variable. Default TRUE. na.rm.var TRUE want remove observations NA discrete variable. FALSE want create modality NA value discrete variable. Default TRUE. prop_method Type proportion method used compute confidence intervals. See svyciprop survey package details. Default beta method. show_value TRUE want show proportion category group graphic. FALSE want show proportions. Proportions 2 percent less never showed graphic. Default TRUE. show_lab TRUE want show axes, titles, caption legend labels. FALSE want show label axes, titles, caption legend. Default TRUE. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default unit. dec Decimal mark shown graphic. Default \",\". pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. dodge Width bar, 0 1. Default 0.9. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line labels groups. Default 25. wrap_width_leg Number characters going line labels categories quali_var. Default 25. legend_ncol Number colomns legend. Default 4. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. xlab = NULL, X label graphic wil Distribution : \" + quali_var. show X label, use xlab = \"\". ylab Y label graphic. coord_flip() used graphic, ylab refers y label graphic, coord_flip(), y variable data. ylab = NULL, Y label graphic group. show Y label, use ylab = \"\". legend_lab Legend (fill) label graphic. legend_lab = NULL, legend label graphic quali_var. show legend label, use legend_lab = \"\". caption Caption graphic. export_path Path export results xlsx file. file includes three sheets : table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"distrib_group_discrete — distrib_group_discrete","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/distrib_group_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"distrib_group_discrete — distrib_group_discrete","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_dist_d <- distrib_group_d( eusilc, group = pb220a, quali_var = pl030_rec, strata = db040, ids = db030, weight = rb050, title = \"Distribution of socio-economic status according to nationality\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 eusilc_dist_d$graph #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_text()`).  eusilc_dist_d$tab #> # A tibble: 21 × 9 #>    pb220a pl030_rec    prop prop_low prop_upp n_sample n_weighted n_weighted_low #>    <fct>  <fct>       <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #>  1 AT     Fulfillin… 0.0890  0.0840    0.0942     1036    548489.        516433. #>  2 AT     Permanent… 0.0119  0.00931   0.0150      125     73270.         56226. #>  3 AT     Retired    0.285   0.275     0.295      3055   1754654.       1694827. #>  4 AT     Student    0.0602  0.0558    0.0650      693    371222.        341944. #>  5 AT     Unemployed 0.0388  0.0351    0.0427      411    238841.        215788. #>  6 AT     Working f… 0.421   0.412     0.431      4689   2595137.       2526927. #>  7 AT     Working p… 0.0942  0.0889    0.0998     1064    580514.        546750. #>  8 EU     Fulfillin… 0.124   0.0886    0.167        38     20343.         13863. #>  9 EU     Permanent… 0.0498  0.0280    0.0810       15      8186.          4024. #> 10 EU     Retired    0.155   0.115     0.202        45     25429.         17953. #> # ℹ 11 more rows #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"esth_graph — esth_graph","title":"esth_graph — esth_graph","text":"Function construct graphic following aestetics function function package table","code":""},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"esth_graph — esth_graph","text":"","code":"esth_graph(   tab,   var,   value,   facet = NULL,   reorder = F,   error_low = NULL,   error_upp = NULL,   pvalue = NULL,   n_var = NULL,   show_value = TRUE,   name_total = NULL,   scale = 1,   digits = 2,   unit = \"\",   dec = \",\",   fill = \"indianred4\",   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL )"},{"path":"https://jgires.github.io/fonctionr/reference/esth_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"esth_graph — esth_graph","text":"tab Table variables ploted. var variable tab labels indicators ploted. value variable tab indicators ploted. facet variable tab defining faceting group, applicable. Default NULL. reorder TRUE want reorder var according value. FALSE want reorder. Default FALSE. error_low variable tab lower bound confidence interval. either error_low error_upp NULL error bars shown graphic. error_upp variable tab upper bound confidence interval. either error_low error_upp NULL error bars shown graphic. pvalue p-value show caption. can numeric value pvalue object statsistical test. n_var variable tab containing number observation per indicator. Default NULL, showing number observation plot. show_value TRUE want show values value graphic. FALSE want show proportion. Default TRUE. name_total Name total bar graphic. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit unit showd plot. Default percent. dec Decimal mark shown graphic. Default \",\" fill Colour bars. dodge Width bar, 0 1. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line. Applies labels var. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), var tab. ylab Y label graphic. coord_flip() used graphic, ylab refers y label graphic, coord_flip(), value tab. caption Caption graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/load_and_active_fonts.html","id":null,"dir":"Reference","previous_headings":"","what":"load_and_active_fonts — load_and_active_fonts","title":"load_and_active_fonts — load_and_active_fonts","text":"Fonction pour charger et activer les polices de fonctionr","code":""},{"path":"https://jgires.github.io/fonctionr/reference/load_and_active_fonts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"load_and_active_fonts — load_and_active_fonts","text":"","code":"load_and_active_fonts()"},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":null,"dir":"Reference","previous_headings":"","what":"make_surface — make_surface","title":"make_surface — make_surface","text":"make_surface","code":""},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make_surface — make_surface","text":"","code":"make_surface(   tab,   var,   value,   error_low = NULL,   error_upp = NULL,   pvalue = NULL,   compare = F,   reorder = F,   show_ci = TRUE,   space = NULL,   position = \"mid\",   digits = 0,   unit = NULL,   pal = \"Kandinsky\",   bg = \"snow2\",   direction = 1,   title = NULL,   subtitle = NULL,   caption = NULL,   wrap_width_lab = 20 )"},{"path":"https://jgires.github.io/fonctionr/reference/make_surface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make_surface — make_surface","text":"wrap_width_lab","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":null,"dir":"Reference","previous_headings":"","what":"many_val — many_val","title":"many_val — many_val","text":"Function compute de proportions set several binary variables. can use complex survey data. produces table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"many_val — many_val","text":"","code":"many_val(   data,   list_vars,   type,   list_vars_lab = NULL,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.facet = T,   na.vars = \"rm\",   prop_method = \"beta\",   reorder = FALSE,   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   scale = NULL,   digits = 0,   unit = NULL,   dec = \",\",   pal = \"Egypt\",   direction = 1,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   export_path = NULL )  many_prop(..., type = \"prop\")  many_median(..., type = \"median\")  many_mean(..., type = \"mean\")"},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"many_val — many_val","text":"data dataframe object survey package object srvyr package. list_vars vector containing names dummy variables compute proportions type \"mean\" compute means ; \"median\" compute medians ; \"prop\" compute proportions. list_vars_lab Names variables facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.vars treatment NA values variables. \"rm\" removes NA individual variable, \"rm.\" removes every individual least one NA one variable. prop_method Type proportion method use. See svyciprop survey package details. Default beta method. reorder TRUE want reorder variables according proportion. show_ci TRUE want show error bars graphic. FALSE want show error bars. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show proportion group graphic. FALSE want show proportion. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\" pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. dodge Width bar, 0 1. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line. Applies labels groups. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. ylab Y label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. caption Caption graphic. export_path Path export results xlsx file. file includes two sheets : table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"many_val — many_val","text":"list contains table graphic","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"many_val — many_val","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding variables eusilc$worker <- 0 eusilc$worker[eusilc$pl030 == \"1\"]<-1 eusilc$worker[eusilc$pl030 == \"2\"]<-1 eusilc$austrian<-0 eusilc$austrian[eusilc$pb220a == \"AT\"]<-1  # Computation, taking sample design into account eusilc_many_prop <- many_prop( eusilc, list_vars = c(worker,austrian), list_vars_lab = c(\"% of workers\",\"% of Austrian\"), facet = rb090, strata = db040, ids = db030, weight = rb050, title = \"Proportion of workers and Autrian according to gender\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Variable(s) entrées : worker, austrian #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 eusilc_many_prop$graph  eusilc_many_prop$tab #> # A tibble: 4 × 12 #>   rb090  list_col       prop prop_low prop_upp n_sample n_true_weighted #>   <fct>  <fct>         <dbl>    <dbl>    <dbl>    <int>           <dbl> #> 1 male   % of workers  0.495    0.484    0.506     7267        1969092. #> 2 female % of workers  0.366    0.355    0.376     7560        1536897. #> 3 male   % of Austrian 0.739    0.728    0.750     7267        2942211. #> 4 female % of Austrian 0.766    0.756    0.777     7560        3219916. #> # ℹ 5 more variables: n_true_weighted_low <dbl>, n_true_weighted_upp <dbl>, #> #   n_tot_weighted <dbl>, n_tot_weighted_low <dbl>, n_tot_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":null,"dir":"Reference","previous_headings":"","what":"many_val_group — many_val_group","title":"many_val_group — many_val_group","text":"Function compare de proportions/means/medians set several binary/continuous variables different groups. can use complex survey data. produces table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"many_val_group — many_val_group","text":"","code":"many_val_group(   data,   group,   list_vars,   type,   list_vars_lab = NULL,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   na.vars = \"rm\",   prop_method = \"beta\",   position = \"dodge\",   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   scale = NULL,   digits = 0,   unit = NULL,   dec = \",\",   pal = \"Egypt\",   direction = 1,   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   wrap_width_leg = 25,   legend_ncol = 4,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   legend_lab = NULL,   caption = NULL,   export_path = NULL )  many_prop_group(..., type = \"prop\")  many_median_group(..., type = \"median\")  many_mean_group(..., type = \"mean\")"},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"many_val_group — many_val_group","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. list_vars vector containing names dummy variables compute proportions type \"mean\" compute means group ; \"median\" compute medians group ; \"prop\" compute proportions group. list_vars_lab Names variables facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.vars treatment NA values variables. \"rm\" removes NA individual variable, \"rm.\" removes every individual least one NA one variable. prop_method Type proportion method use. See svyciprop survey package details. Default beta method. position Position adjustment geom_bar show_ci TRUE want show error bars graphic. FALSE want show error bars. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show proportion group graphic. FALSE want show proportion. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\" pal Color palette used graphic. palettes packages MetBrewer, MoMAColors PrettyCols available. direction Direction palette color. Default 1. opposite direction -1. dodge Width bar, 0 1. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line. Applies labels groups. Default 25. wrap_width_leg Number characters going line. Applies labels legend. Default 25. legend_ncol Number maximum colomn legend. Default 4. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. ylab Y label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. legend_lab Legend (fill) label graphic. caption Caption graphic. export_path Path export results xlsx file. file includes two sheets : table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"many_val_group — many_val_group","text":"list contains table graphic","code":""},{"path":"https://jgires.github.io/fonctionr/reference/many_val_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"many_val_group — many_val_group","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding variables eusilc$worker <- 0 eusilc$worker[eusilc$pl030 == \"1\"]<-1 eusilc$worker[eusilc$pl030 == \"2\"]<-1 eusilc$austrian<-0 eusilc$austrian[eusilc$pb220a == \"AT\"]<-1  # Computation, taking sample design into account eusilc_many_mean_group <- many_mean_group( eusilc, group = rb090, list_vars = c(py010n,py050n,py090n,py100n), list_vars_lab = c(\"Wage\",\"Self-employement income\",\"unemployement benefit\",\"pension\"), strata = db040, ids = db030, weight = rb050, title = \"Average incomes according to gender\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Variable(s) entrées : py010n, py050n, py090n, py100n #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 eusilc_many_mean_group$graph  eusilc_many_mean_group$tab #> # A tibble: 8 × 9 #>   rb090  list_col      mean mean_low mean_upp n_sample n_weighted n_weighted_low #>   <fct>  <fct>        <dbl>    <dbl>    <dbl>    <int>      <dbl>          <dbl> #> 1 male   Wage        12445.   12102.   12787.     5844   3237897.       3178503. #> 2 female Wage         6136.    5902.    6370.     6263   3519368.       3470221. #> 3 male   Self-emplo…  1539.    1369.    1710.     5844   3237897.       3178503. #> 4 female Self-emplo…   689.     600.     778.     6263   3519368.       3470221. #> 5 male   unemployem…   420.     371.     469.     5844   3237897.       3178503. #> 6 female unemployem…   431.     387.     475.     6263   3519368.       3470221. #> 7 male   pension      4123.    3894.    4353.     5844   3237897.       3178503. #> 8 female pension      3438.    3254.    3623.     6263   3519368.       3470221. #> # ℹ 1 more variable: n_weighted_upp <dbl>"},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"pivot_longer_survey — pivot_longer_survey","title":"pivot_longer_survey — pivot_longer_survey","text":"Function pivot wide long agregated data group produced srvyr::summarise","code":""},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"pivot_longer_survey — pivot_longer_survey","text":"","code":"pivot_longer_survey(data, n_groups)"},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"pivot_longer_survey — pivot_longer_survey","text":"data dataframe Agregated data pivot n_groups Number groups data agregated","code":""},{"path":"https://jgires.github.io/fonctionr/reference/pivot_longer_survey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"pivot_longer_survey — pivot_longer_survey","text":"dataframe","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":null,"dir":"Reference","previous_headings":"","what":"prop_group — prop_group","title":"prop_group — prop_group","text":"Function compare proportions different groups complex survey data. produces table, graphic statistical test.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prop_group — prop_group","text":"","code":"prop_group(   data,   group,   prop_exp,   facet = NULL,   filter_exp = NULL,   ...,   na.rm.group = T,   na.rm.facet = T,   na.prop = \"rm\",   prop_method = \"beta\",   reorder = F,   show_ci = T,   show_n = FALSE,   show_value = TRUE,   show_lab = TRUE,   total_name = \"Total\",   scale = 100,   digits = 0,   unit = \"%\",   dec = \",\",   fill = \"deepskyblue3\",   dodge = 0.9,   font = \"Roboto\",   wrap_width_y = 25,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   caption = NULL,   export_path = NULL )"},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prop_group — prop_group","text":"data dataframe object survey package object srvyr package. group variable defining groups compared. prop_exp expression define proportion computed. facet variable defining faceting group. filter_exp expression filters data, preserving design. ... options possible as_survey_design srvyr package. na.rm.group TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.rm.facet TRUE want remove observations NA group variable NA facet variable. FALSE want create group NA value group variable facet NA value facet variable. NA variables included prop_exp affected argument. observation NA variables included prop_exp excluded. na.prop \"rm\" remove NA variables used prop_exp computing proportions, \"include\" compute proportions NA's denominators. Default \"rm\". \"rm\" NA allowed prop_exp. prop_method Type proportion method use. See svyciprop survey package details. Default beta method. reorder TRUE want reorder groups according proportion. NA value, case na.rm.group = FALSE, included reorder. show_ci TRUE want show error bars graphic. FALSE want show error bars. show_n TRUE want show graphic number individuals sample group. FALSE want show number. Default FALSE. show_value TRUE want show proportion group graphic. FALSE want show proportion. show_lab TRUE want show axes, titles caption labels. FALSE want show label axes titles. Default TRUE. total_name Name total shown graphic. Default \"Total\". scale Denominator proportion. Default 100 interprets numbers percentages. digits Numbers digits showed values labels graphic. Default 0. unit Unit showed graphic. Default percent. dec Decimal mark shown graphic. Default \",\" fill Colour bars. NA bar, case na.rm.group = FALSE, total bar always grey. dodge Width bar, 0 1. font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\". wrap_width_y Number characters going line. Applies labels groups. Default 25. title Title graphic. subtitle Subtitle graphic. xlab X label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. ylab Y label graphic. coord_flip() used graphic, xlab refers x label graphic, coord_flip(), x variable data. caption Caption graphic. export_path Path export results xlsx file. file includes two sheets : table graphic.","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"prop_group — prop_group","text":"list contains table, graphic statistical test","code":""},{"path":"https://jgires.github.io/fonctionr/reference/prop_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"prop_group — prop_group","text":"","code":"# Loading of data data(eusilc, package = \"laeken\")  # Recoding eusilc$pl030 into eusilc$pl030_rec eusilc$pl030_rec <- NA eusilc$pl030_rec[eusilc$pl030 == \"1\"] <- \"Working full time\" eusilc$pl030_rec[eusilc$pl030 == \"2\"] <- \"Working part time\" eusilc$pl030_rec[eusilc$pl030 == \"3\"] <- \"Unemployed\" eusilc$pl030_rec[eusilc$pl030 == \"4\"] <- \"Student\" eusilc$pl030_rec[eusilc$pl030 == \"5\"] <- \"Retired\" eusilc$pl030_rec[eusilc$pl030 == \"6\"] <- \"Permanently disabled\" eusilc$pl030_rec[eusilc$pl030 == \"7\"] <- \"Fulfilling domestic tasks\"  # Computation, taking sample design into account eusilc_prop <- prop_group( eusilc, group = pl030_rec, prop_exp = py090n > 0, strata = db040, ids = db030, weight = rb050, title = \"% of ind. receiving unemployment benefits in their hh\", subtitle = \"Example with austrian SILC data from 'laeken' package\" ) #> Input: data.frame #> Sampling design -> ids:  db030, strata:  db040, weights:  rb050 #> Variable(s) détectée(s) dans l'expression : py090n #> 0 lignes supprimées avec valeur(s) manquante(s) pour le(s) variable(s) de l'expression eusilc_prop$graph"},{"path":"https://jgires.github.io/fonctionr/reference/theme_fonctionr.html","id":null,"dir":"Reference","previous_headings":"","what":"theme_fonctionr — theme_fonctionr","title":"theme_fonctionr — theme_fonctionr","text":"theme_fonctionr","code":""},{"path":"https://jgires.github.io/fonctionr/reference/theme_fonctionr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"theme_fonctionr — theme_fonctionr","text":"","code":"theme_fonctionr(font)"},{"path":"https://jgires.github.io/fonctionr/reference/theme_fonctionr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"theme_fonctionr — theme_fonctionr","text":"font Font used graphic. Available fonts, included package , \"Roboto\", \"Montserrat\" \"Gotham Narrow\". Default \"Roboto\".","code":""}]
